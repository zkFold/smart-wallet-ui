var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var require_stdin = __commonJS({
  "<stdin>"(exports, module) {
    (async () => {
      (function() {
        const t = document.createElement("link").relList;
        if (t && t.supports && t.supports("modulepreload")) return;
        for (const n of document.querySelectorAll('link[rel="modulepreload"]')) a(n);
        new MutationObserver((n) => {
          for (const _ of n) if (_.type === "childList") for (const c of _.addedNodes) c.tagName === "LINK" && c.rel === "modulepreload" && a(c);
        }).observe(document, {
          childList: true,
          subtree: true
        });
        function e(n) {
          const _ = {};
          return n.integrity && (_.integrity = n.integrity), n.referrerPolicy && (_.referrerPolicy = n.referrerPolicy), n.crossOrigin === "use-credentials" ? _.credentials = "include" : n.crossOrigin === "anonymous" ? _.credentials = "omit" : _.credentials = "same-origin", _;
        }
        function a(n) {
          if (n.ep) return;
          n.ep = true;
          const _ = e(n);
          fetch(n.href, _);
        }
      })();
      const xl = "/assets/cardano_serialization_lib_bg-jiYOf81c.wasm", El = async (d = {}, t) => {
        let e;
        if (t.startsWith("data:")) {
          const a = t.replace(/^data:.*?base64,/, "");
          let n;
          if (typeof Buffer == "function" && typeof Buffer.from == "function") n = Buffer.from(a, "base64");
          else if (typeof atob == "function") {
            const _ = atob(a);
            n = new Uint8Array(_.length);
            for (let c = 0; c < _.length; c++) n[c] = _.charCodeAt(c);
          } else throw new Error("Cannot decode base64-encoded data URL");
          e = await WebAssembly.instantiate(n, d);
        } else {
          const a = await fetch(t), n = a.headers.get("Content-Type") || "";
          if ("instantiateStreaming" in WebAssembly && n.startsWith("application/wasm")) e = await WebAssembly.instantiateStreaming(a, d);
          else {
            const _ = await a.arrayBuffer();
            e = await WebAssembly.instantiate(_, d);
          }
        }
        return e.instance.exports;
      };
      let r;
      function Cl(d) {
        r = d;
      }
      const Or = new Array(128).fill(void 0);
      Or.push(void 0, null, true, false);
      let An = Or.length;
      function Ot(d) {
        An === Or.length && Or.push(Or.length + 1);
        const t = An;
        return An = Or[t], Or[t] = d, t;
      }
      function It(d) {
        return Or[d];
      }
      function Sl(d) {
        d < 132 || (Or[d] = An, An = d);
      }
      function w(d) {
        const t = It(d);
        return Sl(d), t;
      }
      const Tl = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
      let bd = new Tl("utf-8", {
        ignoreBOM: true,
        fatal: true
      });
      bd.decode();
      let qn = null;
      function vn() {
        return (qn === null || qn.byteLength === 0) && (qn = new Uint8Array(r.memory.buffer)), qn;
      }
      function H(d, t) {
        return d = d >>> 0, bd.decode(vn().subarray(d, d + t));
      }
      let B = 0;
      const jl = typeof TextEncoder > "u" ? (0, module.require)("util").TextEncoder : TextEncoder;
      let Xn = new jl("utf-8");
      const Al = typeof Xn.encodeInto == "function" ? function(d, t) {
        return Xn.encodeInto(d, t);
      } : function(d, t) {
        const e = Xn.encode(d);
        return t.set(e), {
          read: d.length,
          written: e.length
        };
      };
      function q(d, t, e) {
        if (e === void 0) {
          const s = Xn.encode(d), p = t(s.length, 1) >>> 0;
          return vn().subarray(p, p + s.length).set(s), B = s.length, p;
        }
        let a = d.length, n = t(a, 1) >>> 0;
        const _ = vn();
        let c = 0;
        for (; c < a; c++) {
          const s = d.charCodeAt(c);
          if (s > 127) break;
          _[n + c] = s;
        }
        if (c !== a) {
          c !== 0 && (d = d.slice(c)), n = e(n, a, a = c + d.length * 3, 1) >>> 0;
          const s = vn().subarray(n + c, n + a), p = Al(d, s);
          c += p.written, n = e(n, a, c, 1) >>> 0;
        }
        return B = c, n;
      }
      function Gr(d) {
        return d == null;
      }
      let Hn = null;
      function o() {
        return (Hn === null || Hn.byteLength === 0) && (Hn = new Int32Array(r.memory.buffer)), Hn;
      }
      function io(d) {
        const t = typeof d;
        if (t == "number" || t == "boolean" || d == null) return `${d}`;
        if (t == "string") return `"${d}"`;
        if (t == "symbol") {
          const n = d.description;
          return n == null ? "Symbol" : `Symbol(${n})`;
        }
        if (t == "function") {
          const n = d.name;
          return typeof n == "string" && n.length > 0 ? `Function(${n})` : "Function";
        }
        if (Array.isArray(d)) {
          const n = d.length;
          let _ = "[";
          n > 0 && (_ += io(d[0]));
          for (let c = 1; c < n; c++) _ += ", " + io(d[c]);
          return _ += "]", _;
        }
        const e = /\[object ([^\]]+)\]/.exec(toString.call(d));
        let a;
        if (e.length > 1) a = e[1];
        else return toString.call(d);
        if (a == "Object") try {
          return "Object(" + JSON.stringify(d) + ")";
        } catch {
          return "Object";
        }
        return d instanceof Error ? `${d.name}: ${d.message}
${d.stack}` : a;
      }
      function nt(d, t) {
        return d = d >>> 0, vn().subarray(d / 1, d / 1 + t);
      }
      function _t(d, t) {
        const e = t(d.length * 1, 1) >>> 0;
        return vn().set(d, e / 1), B = d.length, e;
      }
      function U(d, t) {
        if (!(d instanceof t)) throw new Error(`expected instance of ${t.name}`);
        return d.ptr;
      }
      function Qr(d, t) {
        try {
          return d.apply(this, t);
        } catch (e) {
          r.__wbindgen_exn_store(Ot(e));
        }
      }
      const So = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_address_free(d >>> 0));
      class _e {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(_e.prototype);
          return e.__wbg_ptr = t, So.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, So.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_address_free(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.address_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return _e.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.address_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.address_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.address_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return _e.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        kind() {
          return r.address_kind(this.__wbg_ptr);
        }
        payment_cred() {
          const t = r.address_payment_cred(this.__wbg_ptr);
          return t === 0 ? void 0 : xt.__wrap(t);
        }
        is_malformed() {
          return r.address_is_malformed(this.__wbg_ptr) !== 0;
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.address_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.address_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return _e.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.address_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32(t) {
          let e, a;
          try {
            const j = r.__wbindgen_add_to_stack_pointer(-16);
            var n = Gr(t) ? 0 : q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), _ = B;
            r.address_to_bech32(j, this.__wbg_ptr, n, _);
            var c = o()[j / 4 + 0], s = o()[j / 4 + 1], p = o()[j / 4 + 2], l = o()[j / 4 + 3], y = c, R = s;
            if (l) throw y = 0, R = 0, w(p);
            return e = y, a = R, H(y, R);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.address_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return _e.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        network_id() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.address_network_id(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return t;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const To = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_anchor_free(d >>> 0));
      class ie {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(ie.prototype);
          return e.__wbg_ptr = t, To.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, To.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_anchor_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchor_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.anchor_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ie.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchor_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.anchor_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ie.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchor_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchor_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.anchor_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ie.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        url() {
          const t = r.anchor_url(this.__wbg_ptr);
          return _a.__wrap(t);
        }
        anchor_data_hash() {
          const t = r.anchor_anchor_data_hash(this.__wbg_ptr);
          return tn.__wrap(t);
        }
        static new(t, e) {
          U(t, _a), U(e, tn);
          const a = r.anchor_new(t.__wbg_ptr, e.__wbg_ptr);
          return ie.__wrap(a);
        }
      }
      const jo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_anchordatahash_free(d >>> 0));
      class tn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(tn.prototype);
          return e.__wbg_ptr = t, jo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, jo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_anchordatahash_free(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.anchordatahash_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return tn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32(t) {
          let e, a;
          try {
            const y = r.__wbindgen_add_to_stack_pointer(-16), R = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), j = B;
            r.anchordatahash_to_bech32(y, this.__wbg_ptr, R, j);
            var n = o()[y / 4 + 0], _ = o()[y / 4 + 1], c = o()[y / 4 + 2], s = o()[y / 4 + 3], p = n, l = _;
            if (s) throw p = 0, l = 0, w(c);
            return e = p, a = l, H(p, l);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.anchordatahash_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return tn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.anchordatahash_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return tn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const Ao = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_assetname_free(d >>> 0));
      class Ie {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Ie.prototype);
          return e.__wbg_ptr = t, Ao.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ao.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_assetname_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.assetname_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.assetname_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ie.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.assetname_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.assetname_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ie.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.assetname_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.assetname_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.assetname_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ie.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.assetname_new(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ie.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        name() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.assetname_name(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const Io = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_assetnames_free(d >>> 0));
      class e_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(e_.prototype);
          return e.__wbg_ptr = t, Io.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Io.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_assetnames_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.assetnames_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.assetnames_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return e_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.assetnames_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.assetnames_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return e_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.assetnames_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.assetnames_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.assetnames_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return e_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.assetnames_new();
          return e_.__wrap(t);
        }
        len() {
          return r.assetnames_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.assetnames_get(this.__wbg_ptr, t);
          return Ie.__wrap(e);
        }
        add(t) {
          U(t, Ie), r.assetnames_add(this.__wbg_ptr, t.__wbg_ptr);
        }
      }
      const Bo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_assets_free(d >>> 0));
      class Ur {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Ur.prototype);
          return e.__wbg_ptr = t, Bo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Bo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_assets_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.assets_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.assets_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ur.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.assets_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.assets_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ur.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.assets_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.assets_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.assets_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ur.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.assets_new();
          return Ur.__wrap(t);
        }
        len() {
          return r.assets_len(this.__wbg_ptr) >>> 0;
        }
        insert(t, e) {
          U(t, Ie), U(e, it);
          const a = r.assets_insert(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
          return a === 0 ? void 0 : it.__wrap(a);
        }
        get(t) {
          U(t, Ie);
          const e = r.assets_get(this.__wbg_ptr, t.__wbg_ptr);
          return e === 0 ? void 0 : it.__wrap(e);
        }
        keys() {
          const t = r.assets_keys(this.__wbg_ptr);
          return e_.__wrap(t);
        }
      }
      const Ro = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_auxiliarydata_free(d >>> 0));
      class Y_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Y_.prototype);
          return e.__wbg_ptr = t, Ro.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ro.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_auxiliarydata_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.auxiliarydata_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.auxiliarydata_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Y_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.auxiliarydata_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.auxiliarydata_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Y_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.auxiliarydata_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.auxiliarydata_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.auxiliarydata_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Y_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.auxiliarydata_new();
          return Y_.__wrap(t);
        }
        metadata() {
          const t = r.auxiliarydata_metadata(this.__wbg_ptr);
          return t === 0 ? void 0 : p_.__wrap(t);
        }
        set_metadata(t) {
          U(t, p_), r.auxiliarydata_set_metadata(this.__wbg_ptr, t.__wbg_ptr);
        }
        native_scripts() {
          const t = r.auxiliarydata_native_scripts(this.__wbg_ptr);
          return t === 0 ? void 0 : Te.__wrap(t);
        }
        set_native_scripts(t) {
          U(t, Te), r.auxiliarydata_set_native_scripts(this.__wbg_ptr, t.__wbg_ptr);
        }
        plutus_scripts() {
          const t = r.auxiliarydata_plutus_scripts(this.__wbg_ptr);
          return t === 0 ? void 0 : lr.__wrap(t);
        }
        set_plutus_scripts(t) {
          U(t, lr), r.auxiliarydata_set_plutus_scripts(this.__wbg_ptr, t.__wbg_ptr);
        }
        prefer_alonzo_format() {
          return r.auxiliarydata_prefer_alonzo_format(this.__wbg_ptr) !== 0;
        }
        set_prefer_alonzo_format(t) {
          r.auxiliarydata_set_prefer_alonzo_format(this.__wbg_ptr, t);
        }
      }
      const No = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_auxiliarydatahash_free(d >>> 0));
      class en {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(en.prototype);
          return e.__wbg_ptr = t, No.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, No.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_auxiliarydatahash_free(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.auxiliarydatahash_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return en.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32(t) {
          let e, a;
          try {
            const y = r.__wbindgen_add_to_stack_pointer(-16), R = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), j = B;
            r.anchordatahash_to_bech32(y, this.__wbg_ptr, R, j);
            var n = o()[y / 4 + 0], _ = o()[y / 4 + 1], c = o()[y / 4 + 2], s = o()[y / 4 + 3], p = n, l = _;
            if (s) throw p = 0, l = 0, w(c);
            return e = p, a = l, H(p, l);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.auxiliarydatahash_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return en.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.auxiliarydatahash_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return en.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_auxiliarydataset_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_baseaddress_free(d >>> 0));
      const Lo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_bigint_free(d >>> 0));
      let Fo = class re {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(re.prototype);
          return e.__wbg_ptr = t, Lo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Lo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_bigint_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bigint_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.bigint_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return re.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.bigint_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bigint_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return re.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.bigint_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bigint_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bigint_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return re.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        is_zero() {
          return r.bigint_is_zero(this.__wbg_ptr) !== 0;
        }
        as_u64() {
          const t = r.bigint_as_u64(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        as_int() {
          const t = r.bigint_as_int(this.__wbg_ptr);
          return t === 0 ? void 0 : Jt.__wrap(t);
        }
        static from_str(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bigint_from_str(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return re.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_str() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.bigint_to_str(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        add(t) {
          U(t, re);
          const e = r.bigint_add(this.__wbg_ptr, t.__wbg_ptr);
          return re.__wrap(e);
        }
        sub(t) {
          U(t, re);
          const e = r.bigint_sub(this.__wbg_ptr, t.__wbg_ptr);
          return re.__wrap(e);
        }
        mul(t) {
          U(t, re);
          const e = r.bigint_mul(this.__wbg_ptr, t.__wbg_ptr);
          return re.__wrap(e);
        }
        pow(t) {
          const e = r.bigint_pow(this.__wbg_ptr, t);
          return re.__wrap(e);
        }
        static one() {
          const t = r.bigint_one();
          return re.__wrap(t);
        }
        static zero() {
          const t = r.bigint_zero();
          return re.__wrap(t);
        }
        abs() {
          const t = r.bigint_abs(this.__wbg_ptr);
          return re.__wrap(t);
        }
        increment() {
          const t = r.bigint_increment(this.__wbg_ptr);
          return re.__wrap(t);
        }
        div_ceil(t) {
          U(t, re);
          const e = r.bigint_div_ceil(this.__wbg_ptr, t.__wbg_ptr);
          return re.__wrap(e);
        }
        div_floor(t) {
          U(t, re);
          const e = r.bigint_div_floor(this.__wbg_ptr, t.__wbg_ptr);
          return re.__wrap(e);
        }
      };
      const Oo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_bignum_free(d >>> 0));
      class it {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(it.prototype);
          return e.__wbg_ptr = t, Oo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Oo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_bignum_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bignum_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.bignum_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return it.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.bignum_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bignum_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return it.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.bignum_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bignum_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bignum_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return it.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_str(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bignum_from_str(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return it.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_str() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.bignum_to_str(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static zero() {
          const t = r.bignum_zero();
          return it.__wrap(t);
        }
        static one() {
          const t = r.bignum_one();
          return it.__wrap(t);
        }
        is_zero() {
          return r.bignum_is_zero(this.__wbg_ptr) !== 0;
        }
        div_floor(t) {
          U(t, it);
          const e = r.bignum_div_floor(this.__wbg_ptr, t.__wbg_ptr);
          return it.__wrap(e);
        }
        checked_mul(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, it), r.bignum_checked_mul(_, this.__wbg_ptr, t.__wbg_ptr);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return it.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        checked_add(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, it), r.bignum_checked_add(_, this.__wbg_ptr, t.__wbg_ptr);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return it.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        checked_sub(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, it), r.bignum_checked_sub(_, this.__wbg_ptr, t.__wbg_ptr);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return it.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        clamped_sub(t) {
          U(t, it);
          const e = r.bignum_clamped_sub(this.__wbg_ptr, t.__wbg_ptr);
          return it.__wrap(e);
        }
        compare(t) {
          return U(t, it), r.bignum_compare(this.__wbg_ptr, t.__wbg_ptr);
        }
        less_than(t) {
          return U(t, it), r.bignum_less_than(this.__wbg_ptr, t.__wbg_ptr) !== 0;
        }
        static max_value() {
          const t = r.bignum_max_value();
          return it.__wrap(t);
        }
        static max(t, e) {
          U(t, it), U(e, it);
          const a = r.bignum_max(t.__wbg_ptr, e.__wbg_ptr);
          return it.__wrap(a);
        }
      }
      const Uo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_bip32privatekey_free(d >>> 0));
      class qe {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(qe.prototype);
          return e.__wbg_ptr = t, Uo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Uo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_bip32privatekey_free(t);
        }
        derive(t) {
          const e = r.bip32privatekey_derive(this.__wbg_ptr, t);
          return qe.__wrap(e);
        }
        static from_128_xprv(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.bip32privatekey_from_128_xprv(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return qe.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_128_xprv() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bip32privatekey_to_128_xprv(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static generate_ed25519_bip32() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bip32privatekey_generate_ed25519_bip32(n);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return qe.__wrap(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_raw_key() {
          const t = r.bip32privatekey_to_raw_key(this.__wbg_ptr);
          return ir.__wrap(t);
        }
        to_public() {
          const t = r.bip32privatekey_to_public(this.__wbg_ptr);
          return r_.__wrap(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.bip32privatekey_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return qe.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        as_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bip32privatekey_as_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bip32privatekey_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return qe.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.bip32privatekey_to_bech32(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_bip39_entropy(t, e) {
          const a = _t(t, r.__wbindgen_malloc), n = B, _ = _t(e, r.__wbindgen_malloc), c = B, s = r.bip32privatekey_from_bip39_entropy(a, n, _, c);
          return qe.__wrap(s);
        }
        chaincode() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bip32privatekey_chaincode(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.bip32privatekey_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bip32privatekey_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return qe.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const zo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_bip32publickey_free(d >>> 0));
      class r_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(r_.prototype);
          return e.__wbg_ptr = t, zo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, zo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_bip32publickey_free(t);
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bip32publickey_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return r_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.bip32publickey_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        chaincode() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bip32publickey_chaincode(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.bip32publickey_to_bech32(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bip32publickey_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return r_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        as_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bip32publickey_as_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.bip32publickey_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return r_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_raw_key() {
          const t = r.bip32publickey_to_raw_key(this.__wbg_ptr);
          return qr.__wrap(t);
        }
        derive(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.bip32publickey_derive(_, this.__wbg_ptr, t);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return r_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_block_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_blockhash_free(d >>> 0));
      const Do = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_bootstrapwitness_free(d >>> 0));
      class zr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(zr.prototype);
          return e.__wbg_ptr = t, Do.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Do.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_bootstrapwitness_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bootstrapwitness_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.bootstrapwitness_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return zr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.bootstrapwitness_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bootstrapwitness_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return zr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.bootstrapwitness_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bootstrapwitness_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bootstrapwitness_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return zr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        vkey() {
          const t = r.bootstrapwitness_vkey(this.__wbg_ptr);
          return ur.__wrap(t);
        }
        signature() {
          const t = r.bootstrapwitness_signature(this.__wbg_ptr);
          return rr.__wrap(t);
        }
        chain_code() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bootstrapwitness_chain_code(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        attributes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bootstrapwitness_attributes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t, e, a, n) {
          U(t, ur), U(e, rr);
          const _ = _t(a, r.__wbindgen_malloc), c = B, s = _t(n, r.__wbindgen_malloc), p = B, l = r.bootstrapwitness_new(t.__wbg_ptr, e.__wbg_ptr, _, c, s, p);
          return zr.__wrap(l);
        }
      }
      const Po = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_bootstrapwitnesses_free(d >>> 0));
      class __ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(__.prototype);
          return e.__wbg_ptr = t, Po.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Po.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_bootstrapwitnesses_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bootstrapwitnesses_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.bootstrapwitnesses_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return __.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.bootstrapwitnesses_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bootstrapwitnesses_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return __.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.bootstrapwitnesses_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.bootstrapwitnesses_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.bootstrapwitnesses_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return __.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.bootstrapwitnesses_new();
          return __.__wrap(t);
        }
        len() {
          return r.bootstrapwitnesses_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.bootstrapwitnesses_get(this.__wbg_ptr, t);
          return zr.__wrap(e);
        }
        add(t) {
          return U(t, zr), r.bootstrapwitnesses_add(this.__wbg_ptr, t.__wbg_ptr) !== 0;
        }
      }
      const Vo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_byronaddress_free(d >>> 0));
      class n_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(n_.prototype);
          return e.__wbg_ptr = t, Vo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Vo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_byronaddress_free(t);
        }
        to_base58() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.byronaddress_to_base58(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.byronaddress_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.byronaddress_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return n_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        byron_protocol_magic() {
          return r.byronaddress_byron_protocol_magic(this.__wbg_ptr) >>> 0;
        }
        byron_address_kind() {
          return r.byronaddress_byron_address_kind(this.__wbg_ptr);
        }
        attributes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.byronaddress_attributes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        network_id() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.byronaddress_network_id(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return t;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_base58(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.byronaddress_from_base58(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return n_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static icarus_from_key(t, e) {
          U(t, r_);
          const a = r.byronaddress_icarus_from_key(t.__wbg_ptr, e);
          return n_.__wrap(a);
        }
        static is_valid(t) {
          const e = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), a = B;
          return r.byronaddress_is_valid(e, a) !== 0;
        }
        to_address() {
          const t = r.byronaddress_to_address(this.__wbg_ptr);
          return _e.__wrap(t);
        }
        static from_address(t) {
          U(t, _e);
          const e = r.byronaddress_from_address(t.__wbg_ptr);
          return e === 0 ? void 0 : n_.__wrap(e);
        }
      }
      const Mo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_certificate_free(d >>> 0));
      class Gt {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Gt.prototype);
          return e.__wbg_ptr = t, Mo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Mo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_certificate_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.certificate_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.certificate_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Gt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.certificate_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.certificate_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Gt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.certificate_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.certificate_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.certificate_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Gt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_stake_registration(t) {
          U(t, Ze);
          const e = r.certificate_new_stake_registration(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_reg_cert(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, Ze), r.certificate_new_reg_cert(_, t.__wbg_ptr);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Gt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_stake_deregistration(t) {
          U(t, Je);
          const e = r.certificate_new_stake_deregistration(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_unreg_cert(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, Je), r.certificate_new_unreg_cert(_, t.__wbg_ptr);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Gt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_stake_delegation(t) {
          U(t, U_);
          const e = r.certificate_new_stake_delegation(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_pool_registration(t) {
          U(t, m_);
          const e = r.certificate_new_pool_registration(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_pool_retirement(t) {
          U(t, k_);
          const e = r.certificate_new_pool_retirement(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_genesis_key_delegation(t) {
          U(t, u_);
          const e = r.certificate_new_genesis_key_delegation(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_move_instantaneous_rewards_cert(t) {
          U(t, h_);
          const e = r.certificate_new_move_instantaneous_rewards_cert(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_committee_hot_auth(t) {
          U(t, o_);
          const e = r.certificate_new_committee_hot_auth(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_committee_cold_resign(t) {
          U(t, yr);
          const e = r.certificate_new_committee_cold_resign(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_drep_deregistration(t) {
          U(t, c_);
          const e = r.certificate_new_drep_deregistration(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_drep_registration(t) {
          U(t, mr);
          const e = r.certificate_new_drep_registration(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_drep_update(t) {
          U(t, kr);
          const e = r.certificate_new_drep_update(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_stake_and_vote_delegation(t) {
          U(t, O_);
          const e = r.certificate_new_stake_and_vote_delegation(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_stake_registration_and_delegation(t) {
          U(t, z_);
          const e = r.certificate_new_stake_registration_and_delegation(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_stake_vote_registration_and_delegation(t) {
          U(t, D_);
          const e = r.certificate_new_stake_vote_registration_and_delegation(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_vote_delegation(t) {
          U(t, K_);
          const e = r.certificate_new_vote_delegation(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        static new_vote_registration_and_delegation(t) {
          U(t, q_);
          const e = r.certificate_new_vote_registration_and_delegation(t.__wbg_ptr);
          return Gt.__wrap(e);
        }
        kind() {
          return r.certificate_kind(this.__wbg_ptr);
        }
        as_stake_registration() {
          const t = r.certificate_as_stake_registration(this.__wbg_ptr);
          return t === 0 ? void 0 : Ze.__wrap(t);
        }
        as_reg_cert() {
          const t = r.certificate_as_reg_cert(this.__wbg_ptr);
          return t === 0 ? void 0 : Ze.__wrap(t);
        }
        as_stake_deregistration() {
          const t = r.certificate_as_stake_deregistration(this.__wbg_ptr);
          return t === 0 ? void 0 : Je.__wrap(t);
        }
        as_unreg_cert() {
          const t = r.certificate_as_unreg_cert(this.__wbg_ptr);
          return t === 0 ? void 0 : Je.__wrap(t);
        }
        as_stake_delegation() {
          const t = r.certificate_as_stake_delegation(this.__wbg_ptr);
          return t === 0 ? void 0 : U_.__wrap(t);
        }
        as_pool_registration() {
          const t = r.certificate_as_pool_registration(this.__wbg_ptr);
          return t === 0 ? void 0 : m_.__wrap(t);
        }
        as_pool_retirement() {
          const t = r.certificate_as_pool_retirement(this.__wbg_ptr);
          return t === 0 ? void 0 : k_.__wrap(t);
        }
        as_genesis_key_delegation() {
          const t = r.certificate_as_genesis_key_delegation(this.__wbg_ptr);
          return t === 0 ? void 0 : u_.__wrap(t);
        }
        as_move_instantaneous_rewards_cert() {
          const t = r.certificate_as_move_instantaneous_rewards_cert(this.__wbg_ptr);
          return t === 0 ? void 0 : h_.__wrap(t);
        }
        as_committee_hot_auth() {
          const t = r.certificate_as_committee_hot_auth(this.__wbg_ptr);
          return t === 0 ? void 0 : o_.__wrap(t);
        }
        as_committee_cold_resign() {
          const t = r.certificate_as_committee_cold_resign(this.__wbg_ptr);
          return t === 0 ? void 0 : yr.__wrap(t);
        }
        as_drep_deregistration() {
          const t = r.certificate_as_drep_deregistration(this.__wbg_ptr);
          return t === 0 ? void 0 : c_.__wrap(t);
        }
        as_drep_registration() {
          const t = r.certificate_as_drep_registration(this.__wbg_ptr);
          return t === 0 ? void 0 : mr.__wrap(t);
        }
        as_drep_update() {
          const t = r.certificate_as_drep_update(this.__wbg_ptr);
          return t === 0 ? void 0 : kr.__wrap(t);
        }
        as_stake_and_vote_delegation() {
          const t = r.certificate_as_stake_and_vote_delegation(this.__wbg_ptr);
          return t === 0 ? void 0 : O_.__wrap(t);
        }
        as_stake_registration_and_delegation() {
          const t = r.certificate_as_stake_registration_and_delegation(this.__wbg_ptr);
          return t === 0 ? void 0 : z_.__wrap(t);
        }
        as_stake_vote_registration_and_delegation() {
          const t = r.certificate_as_stake_vote_registration_and_delegation(this.__wbg_ptr);
          return t === 0 ? void 0 : D_.__wrap(t);
        }
        as_vote_delegation() {
          const t = r.certificate_as_vote_delegation(this.__wbg_ptr);
          return t === 0 ? void 0 : K_.__wrap(t);
        }
        as_vote_registration_and_delegation() {
          const t = r.certificate_as_vote_registration_and_delegation(this.__wbg_ptr);
          return t === 0 ? void 0 : q_.__wrap(t);
        }
        has_required_script_witness() {
          return r.certificate_has_required_script_witness(this.__wbg_ptr) !== 0;
        }
      }
      const Ko = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_certificates_free(d >>> 0));
      class a_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(a_.prototype);
          return e.__wbg_ptr = t, Ko.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ko.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_certificates_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.certificates_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.certificates_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return a_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.certificates_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.certificates_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return a_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.certificates_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.certificates_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.certificates_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return a_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.certificates_new();
          return a_.__wrap(t);
        }
        len() {
          return r.certificates_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.certificates_get(this.__wbg_ptr, t);
          return Gt.__wrap(e);
        }
        add(t) {
          return U(t, Gt), r.certificates_add(this.__wbg_ptr, t.__wbg_ptr) !== 0;
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_certificatesbuilder_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_changeconfig_free(d >>> 0));
      const qo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_committee_free(d >>> 0));
      class Dr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Dr.prototype);
          return e.__wbg_ptr = t, qo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, qo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_committee_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.committee_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.committee_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Dr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.committee_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.committee_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Dr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.committee_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.committee_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.committee_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Dr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t) {
          U(t, vt);
          const e = r.committee_new(t.__wbg_ptr);
          return Dr.__wrap(e);
        }
        members_keys() {
          const t = r.committee_members_keys(this.__wbg_ptr);
          return tr.__wrap(t);
        }
        quorum_threshold() {
          const t = r.committee_quorum_threshold(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        add_member(t, e) {
          U(t, xt), r.committee_add_member(this.__wbg_ptr, t.__wbg_ptr, e);
        }
        get_member_epoch(t) {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, xt), r.committee_get_member_epoch(n, this.__wbg_ptr, t.__wbg_ptr);
            var e = o()[n / 4 + 0], a = o()[n / 4 + 1];
            return e === 0 ? void 0 : a >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const Ho = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_committeecoldresign_free(d >>> 0));
      class yr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(yr.prototype);
          return e.__wbg_ptr = t, Ho.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ho.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_committeecoldresign_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.committeecoldresign_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.committeecoldresign_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return yr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.committeecoldresign_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.committeecoldresign_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return yr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.committeecoldresign_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.committeecoldresign_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.committeecoldresign_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return yr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        committee_cold_credential() {
          const t = r.committeecoldresign_committee_cold_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        anchor() {
          const t = r.committeecoldresign_anchor(this.__wbg_ptr);
          return t === 0 ? void 0 : ie.__wrap(t);
        }
        static new(t) {
          U(t, xt);
          const e = r.committeecoldresign_new(t.__wbg_ptr);
          return yr.__wrap(e);
        }
        static new_with_anchor(t, e) {
          U(t, xt), U(e, ie);
          const a = r.committeecoldresign_new_with_anchor(t.__wbg_ptr, e.__wbg_ptr);
          return yr.__wrap(a);
        }
        has_script_credentials() {
          return r.committeecoldresign_has_script_credentials(this.__wbg_ptr) !== 0;
        }
      }
      const Go = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_committeehotauth_free(d >>> 0));
      class o_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(o_.prototype);
          return e.__wbg_ptr = t, Go.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Go.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_committeehotauth_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.committeehotauth_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.committeehotauth_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return o_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.committeehotauth_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.committeehotauth_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return o_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.committeehotauth_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.committeehotauth_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.committeehotauth_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return o_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        committee_cold_credential() {
          const t = r.committeehotauth_committee_cold_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        committee_hot_credential() {
          const t = r.committeehotauth_committee_hot_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        static new(t, e) {
          U(t, xt), U(e, xt);
          const a = r.committeehotauth_new(t.__wbg_ptr, e.__wbg_ptr);
          return o_.__wrap(a);
        }
        has_script_credentials() {
          return r.committeehotauth_has_script_credentials(this.__wbg_ptr) !== 0;
        }
      }
      const Wo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_constitution_free(d >>> 0));
      class dr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(dr.prototype);
          return e.__wbg_ptr = t, Wo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Wo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_constitution_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.constitution_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.constitution_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return dr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.constitution_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.constitution_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return dr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.constitution_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.constitution_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.constitution_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return dr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        anchor() {
          const t = r.constitution_anchor(this.__wbg_ptr);
          return ie.__wrap(t);
        }
        script_hash() {
          const t = r.constitution_script_hash(this.__wbg_ptr);
          return t === 0 ? void 0 : Mt.__wrap(t);
        }
        static new(t) {
          U(t, ie);
          const e = r.constitution_new(t.__wbg_ptr);
          return dr.__wrap(e);
        }
        static new_with_script_hash(t, e) {
          U(t, ie), U(e, Mt);
          const a = r.constitution_new_with_script_hash(t.__wbg_ptr, e.__wbg_ptr);
          return dr.__wrap(a);
        }
      }
      const Qo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_constrplutusdata_free(d >>> 0));
      class rn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(rn.prototype);
          return e.__wbg_ptr = t, Qo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Qo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_constrplutusdata_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.constrplutusdata_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.constrplutusdata_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return rn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.constrplutusdata_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.constrplutusdata_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return rn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        alternative() {
          const t = r.constrplutusdata_alternative(this.__wbg_ptr);
          return it.__wrap(t);
        }
        data() {
          const t = r.constrplutusdata_data(this.__wbg_ptr);
          return Ge.__wrap(t);
        }
        static new(t, e) {
          U(t, it), U(e, Ge);
          const a = r.constrplutusdata_new(t.__wbg_ptr, e.__wbg_ptr);
          return rn.__wrap(a);
        }
      }
      const $o = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_costmodel_free(d >>> 0));
      class Pr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Pr.prototype);
          return e.__wbg_ptr = t, $o.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, $o.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_costmodel_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.costmodel_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.costmodel_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Pr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.costmodel_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.costmodel_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Pr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.costmodel_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.costmodel_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.costmodel_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Pr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.costmodel_new();
          return Pr.__wrap(t);
        }
        set(t, e) {
          try {
            const c = r.__wbindgen_add_to_stack_pointer(-16);
            U(e, Jt), r.costmodel_set(c, this.__wbg_ptr, t, e.__wbg_ptr);
            var a = o()[c / 4 + 0], n = o()[c / 4 + 1], _ = o()[c / 4 + 2];
            if (_) throw w(n);
            return Jt.__wrap(a);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        get(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.costmodel_get(_, this.__wbg_ptr, t);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Jt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        len() {
          return r.costmodel_len(this.__wbg_ptr) >>> 0;
        }
      }
      const Yo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_costmdls_free(d >>> 0));
      class vr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(vr.prototype);
          return e.__wbg_ptr = t, Yo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Yo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_costmdls_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.costmdls_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.costmdls_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return vr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.costmdls_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.costmdls_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return vr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.costmdls_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.costmdls_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.costmdls_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return vr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.costmdls_new();
          return vr.__wrap(t);
        }
        len() {
          return r.costmdls_len(this.__wbg_ptr) >>> 0;
        }
        insert(t, e) {
          U(t, Se), U(e, Pr);
          const a = r.costmdls_insert(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
          return a === 0 ? void 0 : Pr.__wrap(a);
        }
        get(t) {
          U(t, Se);
          const e = r.costmdls_get(this.__wbg_ptr, t.__wbg_ptr);
          return e === 0 ? void 0 : Pr.__wrap(e);
        }
        keys() {
          const t = r.costmdls_keys(this.__wbg_ptr);
          return mn.__wrap(t);
        }
        retain_language_versions(t) {
          U(t, mn);
          const e = r.costmdls_retain_language_versions(this.__wbg_ptr, t.__wbg_ptr);
          return vr.__wrap(e);
        }
      }
      const Xo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_credential_free(d >>> 0));
      class xt {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(xt.prototype);
          return e.__wbg_ptr = t, Xo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Xo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_credential_free(t);
        }
        static from_keyhash(t) {
          U(t, Dt);
          const e = r.credential_from_keyhash(t.__wbg_ptr);
          return xt.__wrap(e);
        }
        static from_scripthash(t) {
          U(t, Mt);
          const e = r.credential_from_scripthash(t.__wbg_ptr);
          return xt.__wrap(e);
        }
        to_keyhash() {
          const t = r.credential_to_keyhash(this.__wbg_ptr);
          return t === 0 ? void 0 : Dt.__wrap(t);
        }
        to_scripthash() {
          const t = r.credential_to_scripthash(this.__wbg_ptr);
          return t === 0 ? void 0 : Mt.__wrap(t);
        }
        kind() {
          return r.credential_kind(this.__wbg_ptr);
        }
        has_script_hash() {
          return r.credential_has_script_hash(this.__wbg_ptr) !== 0;
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.credential_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.credential_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return xt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.credential_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.credential_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return xt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.credential_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.credential_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.credential_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return xt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const Jo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_credentials_free(d >>> 0));
      class tr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(tr.prototype);
          return e.__wbg_ptr = t, Jo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Jo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_credentials_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.credentials_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.credentials_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return tr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.credentials_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.credentials_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return tr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.credentials_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.credentials_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.credentials_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return tr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.credentials_new();
          return tr.__wrap(t);
        }
        len() {
          return r.credentials_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.credentials_get(this.__wbg_ptr, t);
          return xt.__wrap(e);
        }
        add(t) {
          return U(t, xt), r.credentials_add(this.__wbg_ptr, t.__wbg_ptr) !== 0;
        }
      }
      const Zo = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_dnsrecordaoraaaa_free(d >>> 0));
      class s_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(s_.prototype);
          return e.__wbg_ptr = t, Zo.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Zo.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_dnsrecordaoraaaa_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.dnsrecordaoraaaa_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.dnsrecordaoraaaa_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return s_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.dnsrecordaoraaaa_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.dnsrecordaoraaaa_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return s_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.dnsrecordaoraaaa_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.dnsrecordaoraaaa_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.dnsrecordaoraaaa_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return s_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.dnsrecordaoraaaa_new(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return s_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        record() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.dnsrecordaoraaaa_record(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
      }
      const ts = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_dnsrecordsrv_free(d >>> 0));
      class i_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(i_.prototype);
          return e.__wbg_ptr = t, ts.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ts.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_dnsrecordsrv_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.dnsrecordsrv_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.dnsrecordsrv_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return i_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.dnsrecordsrv_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.dnsrecordsrv_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return i_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.dnsrecordaoraaaa_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.dnsrecordaoraaaa_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.dnsrecordsrv_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return i_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.dnsrecordsrv_new(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return i_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        record() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.dnsrecordaoraaaa_record(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
      }
      const es = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_drep_free(d >>> 0));
      class se {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(se.prototype);
          return e.__wbg_ptr = t, es.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, es.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_drep_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.drep_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.drep_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return se.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.drep_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.drep_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return se.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.drep_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.drep_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.drep_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return se.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_key_hash(t) {
          U(t, Dt);
          const e = r.drep_new_key_hash(t.__wbg_ptr);
          return se.__wrap(e);
        }
        static new_script_hash(t) {
          U(t, Mt);
          const e = r.drep_new_script_hash(t.__wbg_ptr);
          return se.__wrap(e);
        }
        static new_always_abstain() {
          const t = r.drep_new_always_abstain();
          return se.__wrap(t);
        }
        static new_always_no_confidence() {
          const t = r.drep_new_always_no_confidence();
          return se.__wrap(t);
        }
        static new_from_credential(t) {
          U(t, xt);
          const e = r.drep_new_from_credential(t.__wbg_ptr);
          return se.__wrap(e);
        }
        kind() {
          return r.drep_kind(this.__wbg_ptr);
        }
        to_key_hash() {
          const t = r.drep_to_key_hash(this.__wbg_ptr);
          return t === 0 ? void 0 : Dt.__wrap(t);
        }
        to_script_hash() {
          const t = r.drep_to_script_hash(this.__wbg_ptr);
          return t === 0 ? void 0 : Mt.__wrap(t);
        }
        to_bech32(t) {
          let e, a;
          try {
            const y = r.__wbindgen_add_to_stack_pointer(-16);
            r.drep_to_bech32(y, this.__wbg_ptr, t);
            var n = o()[y / 4 + 0], _ = o()[y / 4 + 1], c = o()[y / 4 + 2], s = o()[y / 4 + 3], p = n, l = _;
            if (s) throw p = 0, l = 0, w(c);
            return e = p, a = l, H(p, l);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.drep_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return se.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const rs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_drepderegistration_free(d >>> 0));
      class c_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(c_.prototype);
          return e.__wbg_ptr = t, rs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, rs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_drepderegistration_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepderegistration_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.drepderegistration_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return c_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepderegistration_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.drepderegistration_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return c_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepderegistration_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepderegistration_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.drepderegistration_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return c_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        voting_credential() {
          const t = r.drepderegistration_voting_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        coin() {
          const t = r.drepderegistration_coin(this.__wbg_ptr);
          return it.__wrap(t);
        }
        static new(t, e) {
          U(t, xt), U(e, it);
          const a = r.drepderegistration_new(t.__wbg_ptr, e.__wbg_ptr);
          return c_.__wrap(a);
        }
        has_script_credentials() {
          return r.drepderegistration_has_script_credentials(this.__wbg_ptr) !== 0;
        }
      }
      const _s = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_drepregistration_free(d >>> 0));
      class mr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(mr.prototype);
          return e.__wbg_ptr = t, _s.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, _s.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_drepregistration_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepregistration_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.drepregistration_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return mr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepregistration_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.drepregistration_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return mr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepregistration_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepregistration_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.drepregistration_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return mr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        voting_credential() {
          const t = r.drepregistration_voting_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        coin() {
          const t = r.drepregistration_coin(this.__wbg_ptr);
          return it.__wrap(t);
        }
        anchor() {
          const t = r.drepregistration_anchor(this.__wbg_ptr);
          return t === 0 ? void 0 : ie.__wrap(t);
        }
        static new(t, e) {
          U(t, xt), U(e, it);
          const a = r.drepregistration_new(t.__wbg_ptr, e.__wbg_ptr);
          return mr.__wrap(a);
        }
        static new_with_anchor(t, e, a) {
          U(t, xt), U(e, it), U(a, ie);
          const n = r.drepregistration_new_with_anchor(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr);
          return mr.__wrap(n);
        }
        has_script_credentials() {
          return r.drepregistration_has_script_credentials(this.__wbg_ptr) !== 0;
        }
      }
      const ns = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_drepupdate_free(d >>> 0));
      class kr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(kr.prototype);
          return e.__wbg_ptr = t, ns.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ns.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_drepupdate_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepupdate_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.drepupdate_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return kr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepupdate_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.drepupdate_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return kr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepupdate_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepupdate_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.drepupdate_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return kr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        voting_credential() {
          const t = r.drepupdate_voting_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        anchor() {
          const t = r.drepupdate_anchor(this.__wbg_ptr);
          return t === 0 ? void 0 : ie.__wrap(t);
        }
        static new(t) {
          U(t, xt);
          const e = r.drepupdate_new(t.__wbg_ptr);
          return kr.__wrap(e);
        }
        static new_with_anchor(t, e) {
          U(t, xt), U(e, ie);
          const a = r.drepupdate_new_with_anchor(t.__wbg_ptr, e.__wbg_ptr);
          return kr.__wrap(a);
        }
        has_script_credentials() {
          return r.drepupdate_has_script_credentials(this.__wbg_ptr) !== 0;
        }
      }
      const as = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_drepvotingthresholds_free(d >>> 0));
      class d_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(d_.prototype);
          return e.__wbg_ptr = t, as.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, as.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_drepvotingthresholds_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepvotingthresholds_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.drepvotingthresholds_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return d_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepvotingthresholds_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.drepvotingthresholds_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return d_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepvotingthresholds_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.drepvotingthresholds_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.drepvotingthresholds_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return d_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t, e, a, n, _, c, s, p, l, y) {
          U(t, vt), U(e, vt), U(a, vt), U(n, vt), U(_, vt), U(c, vt), U(s, vt), U(p, vt), U(l, vt), U(y, vt);
          const R = r.drepvotingthresholds_new(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr, n.__wbg_ptr, _.__wbg_ptr, c.__wbg_ptr, s.__wbg_ptr, p.__wbg_ptr, l.__wbg_ptr, y.__wbg_ptr);
          return d_.__wrap(R);
        }
        set_motion_no_confidence(t) {
          U(t, vt), r.drepvotingthresholds_set_motion_no_confidence(this.__wbg_ptr, t.__wbg_ptr);
        }
        set_committee_normal(t) {
          U(t, vt), r.drepvotingthresholds_set_committee_normal(this.__wbg_ptr, t.__wbg_ptr);
        }
        set_committee_no_confidence(t) {
          U(t, vt), r.drepvotingthresholds_set_committee_no_confidence(this.__wbg_ptr, t.__wbg_ptr);
        }
        set_update_constitution(t) {
          U(t, vt), r.drepvotingthresholds_set_update_constitution(this.__wbg_ptr, t.__wbg_ptr);
        }
        set_hard_fork_initiation(t) {
          U(t, vt), r.drepvotingthresholds_set_hard_fork_initiation(this.__wbg_ptr, t.__wbg_ptr);
        }
        set_pp_network_group(t) {
          U(t, vt), r.drepvotingthresholds_set_pp_network_group(this.__wbg_ptr, t.__wbg_ptr);
        }
        set_pp_economic_group(t) {
          U(t, vt), r.drepvotingthresholds_set_pp_economic_group(this.__wbg_ptr, t.__wbg_ptr);
        }
        set_pp_technical_group(t) {
          U(t, vt), r.drepvotingthresholds_set_pp_technical_group(this.__wbg_ptr, t.__wbg_ptr);
        }
        set_pp_governance_group(t) {
          U(t, vt), r.drepvotingthresholds_set_pp_governance_group(this.__wbg_ptr, t.__wbg_ptr);
        }
        set_treasury_withdrawal(t) {
          U(t, vt), r.drepvotingthresholds_set_treasury_withdrawal(this.__wbg_ptr, t.__wbg_ptr);
        }
        motion_no_confidence() {
          const t = r.drepvotingthresholds_motion_no_confidence(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        committee_normal() {
          const t = r.drepvotingthresholds_committee_normal(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        committee_no_confidence() {
          const t = r.drepvotingthresholds_committee_no_confidence(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        update_constitution() {
          const t = r.drepvotingthresholds_update_constitution(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        hard_fork_initiation() {
          const t = r.drepvotingthresholds_hard_fork_initiation(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        pp_network_group() {
          const t = r.drepvotingthresholds_pp_network_group(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        pp_economic_group() {
          const t = r.drepvotingthresholds_pp_economic_group(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        pp_technical_group() {
          const t = r.drepvotingthresholds_pp_technical_group(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        pp_governance_group() {
          const t = r.drepvotingthresholds_pp_governance_group(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        treasury_withdrawal() {
          const t = r.drepvotingthresholds_treasury_withdrawal(this.__wbg_ptr);
          return vt.__wrap(t);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_datacost_free(d >>> 0));
      const os = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_datahash_free(d >>> 0));
      class _n {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(_n.prototype);
          return e.__wbg_ptr = t, os.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, os.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_datahash_free(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.datahash_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return _n.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32(t) {
          let e, a;
          try {
            const y = r.__wbindgen_add_to_stack_pointer(-16), R = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), j = B;
            r.anchordatahash_to_bech32(y, this.__wbg_ptr, R, j);
            var n = o()[y / 4 + 0], _ = o()[y / 4 + 1], c = o()[y / 4 + 2], s = o()[y / 4 + 3], p = n, l = _;
            if (s) throw p = 0, l = 0, w(c);
            return e = p, a = l, H(p, l);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.datahash_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return _n.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.datahash_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return _n.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_datumsource_free(d >>> 0));
      const ss = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_ed25519keyhash_free(d >>> 0));
      class Dt {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Dt.prototype);
          return e.__wbg_ptr = t, ss.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ss.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_ed25519keyhash_free(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.ed25519keyhash_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Dt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519keyhash_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32(t) {
          let e, a;
          try {
            const y = r.__wbindgen_add_to_stack_pointer(-16), R = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), j = B;
            r.ed25519keyhash_to_bech32(y, this.__wbg_ptr, R, j);
            var n = o()[y / 4 + 0], _ = o()[y / 4 + 1], c = o()[y / 4 + 2], s = o()[y / 4 + 3], p = n, l = _;
            if (s) throw p = 0, l = 0, w(c);
            return e = p, a = l, H(p, l);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.ed25519keyhash_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Dt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519keyhash_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.ed25519keyhash_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Dt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const is = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_ed25519keyhashes_free(d >>> 0));
      class He {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(He.prototype);
          return e.__wbg_ptr = t, is.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, is.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_ed25519keyhashes_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519keyhashes_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.ed25519keyhashes_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return He.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519keyhashes_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.ed25519keyhashes_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return He.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519keyhashes_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519keyhashes_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.ed25519keyhashes_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return He.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.ed25519keyhashes_new();
          return He.__wrap(t);
        }
        len() {
          return r.ed25519keyhashes_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.ed25519keyhashes_get(this.__wbg_ptr, t);
          return Dt.__wrap(e);
        }
        add(t) {
          return U(t, Dt), r.ed25519keyhashes_add(this.__wbg_ptr, t.__wbg_ptr) !== 0;
        }
        contains(t) {
          return U(t, Dt), r.ed25519keyhashes_contains(this.__wbg_ptr, t.__wbg_ptr) !== 0;
        }
        to_option() {
          const t = r.ed25519keyhashes_to_option(this.__wbg_ptr);
          return t === 0 ? void 0 : He.__wrap(t);
        }
      }
      const cs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_ed25519signature_free(d >>> 0));
      class rr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(rr.prototype);
          return e.__wbg_ptr = t, cs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, cs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_ed25519signature_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519signature_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519signature_to_bech32(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519signature_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.ed25519signature_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return rr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.ed25519signature_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return rr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.ed25519signature_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return rr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_enterpriseaddress_free(d >>> 0));
      const ds = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_exunitprices_free(d >>> 0));
      class l_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(l_.prototype);
          return e.__wbg_ptr = t, ds.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ds.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_exunitprices_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.exunitprices_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.exunitprices_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return l_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.exunitprices_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.exunitprices_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return l_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.exunitprices_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.exunitprices_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.exunitprices_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return l_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        mem_price() {
          const t = r.drepvotingthresholds_motion_no_confidence(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        step_price() {
          const t = r.drepvotingthresholds_committee_normal(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        static new(t, e) {
          U(t, vt), U(e, vt);
          const a = r.exunitprices_new(t.__wbg_ptr, e.__wbg_ptr);
          return l_.__wrap(a);
        }
      }
      const ls = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_exunits_free(d >>> 0));
      class Ve {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Ve.prototype);
          return e.__wbg_ptr = t, ls.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ls.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_exunits_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.exunits_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.exunits_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ve.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.exunits_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.exunits_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ve.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.exunits_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.exunits_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.exunits_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ve.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        mem() {
          const t = r.exunits_mem(this.__wbg_ptr);
          return it.__wrap(t);
        }
        steps() {
          const t = r.exunits_steps(this.__wbg_ptr);
          return it.__wrap(t);
        }
        static new(t, e) {
          U(t, it), U(e, it);
          const a = r.exunits_new(t.__wbg_ptr, e.__wbg_ptr);
          return Ve.__wrap(a);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_fixedblock_free(d >>> 0));
      const ps = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_fixedtransaction_free(d >>> 0));
      class Jr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Jr.prototype);
          return e.__wbg_ptr = t, ps.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ps.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_fixedtransaction_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.fixedtransaction_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.fixedtransaction_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Jr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.fixedtransaction_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.fixedtransaction_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Jr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t, e, a) {
          try {
            const s = r.__wbindgen_add_to_stack_pointer(-16), p = _t(t, r.__wbindgen_malloc), l = B, y = _t(e, r.__wbindgen_malloc), R = B;
            r.fixedtransaction_new(s, p, l, y, R, a);
            var n = o()[s / 4 + 0], _ = o()[s / 4 + 1], c = o()[s / 4 + 2];
            if (c) throw w(_);
            return Jr.__wrap(n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_with_auxiliary(t, e, a, n) {
          try {
            const p = r.__wbindgen_add_to_stack_pointer(-16), l = _t(t, r.__wbindgen_malloc), y = B, R = _t(e, r.__wbindgen_malloc), j = B, b = _t(a, r.__wbindgen_malloc), C = B;
            r.fixedtransaction_new_with_auxiliary(p, l, y, R, j, b, C, n);
            var _ = o()[p / 4 + 0], c = o()[p / 4 + 1], s = o()[p / 4 + 2];
            if (s) throw w(c);
            return Jr.__wrap(_);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_from_body_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.fixedtransaction_new_from_body_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Jr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        body() {
          const t = r.fixedtransaction_body(this.__wbg_ptr);
          return t_.__wrap(t);
        }
        raw_body() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.fixedtransaction_raw_body(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_body(t) {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16), _ = _t(t, r.__wbindgen_malloc), c = B;
            r.fixedtransaction_set_body(n, this.__wbg_ptr, _, c);
            var e = o()[n / 4 + 0], a = o()[n / 4 + 1];
            if (a) throw w(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_witness_set(t) {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16), _ = _t(t, r.__wbindgen_malloc), c = B;
            r.fixedtransaction_set_witness_set(n, this.__wbg_ptr, _, c);
            var e = o()[n / 4 + 0], a = o()[n / 4 + 1];
            if (a) throw w(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        witness_set() {
          const t = r.fixedtransaction_witness_set(this.__wbg_ptr);
          return Z_.__wrap(t);
        }
        raw_witness_set() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.fixedtransaction_raw_witness_set(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_is_valid(t) {
          r.fixedtransaction_set_is_valid(this.__wbg_ptr, t);
        }
        is_valid() {
          return r.fixedtransaction_is_valid(this.__wbg_ptr) !== 0;
        }
        set_auxiliary_data(t) {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16), _ = _t(t, r.__wbindgen_malloc), c = B;
            r.fixedtransaction_set_auxiliary_data(n, this.__wbg_ptr, _, c);
            var e = o()[n / 4 + 0], a = o()[n / 4 + 1];
            if (a) throw w(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        auxiliary_data() {
          const t = r.fixedtransaction_auxiliary_data(this.__wbg_ptr);
          return t === 0 ? void 0 : Y_.__wrap(t);
        }
        raw_auxiliary_data() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.fixedtransaction_raw_auxiliary_data(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            let n;
            return t !== 0 && (n = nt(t, e).slice(), r.__wbindgen_free(t, e * 1, 1)), n;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        transaction_hash() {
          const t = r.fixedtransaction_transaction_hash(this.__wbg_ptr);
          return fr.__wrap(t);
        }
        add_vkey_witness(t) {
          U(t, Mr), r.fixedtransaction_add_vkey_witness(this.__wbg_ptr, t.__wbg_ptr);
        }
        add_bootstrap_witness(t) {
          U(t, zr), r.fixedtransaction_add_bootstrap_witness(this.__wbg_ptr, t.__wbg_ptr);
        }
        sign_and_add_vkey_signature(t) {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, ir), r.fixedtransaction_sign_and_add_vkey_signature(n, this.__wbg_ptr, t.__wbg_ptr);
            var e = o()[n / 4 + 0], a = o()[n / 4 + 1];
            if (a) throw w(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        sign_and_add_icarus_bootstrap_signature(t, e) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, n_), U(e, qe), r.fixedtransaction_sign_and_add_icarus_bootstrap_signature(_, this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            if (n) throw w(a);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        sign_and_add_daedalus_bootstrap_signature(t, e) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, n_), U(e, ra), r.fixedtransaction_sign_and_add_daedalus_bootstrap_signature(_, this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            if (n) throw w(a);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_fixedtransactionbodies_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_fixedtransactionbody_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_fixedtxwitnessesset_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_fixedversionedblock_free(d >>> 0));
      const us = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_generaltransactionmetadata_free(d >>> 0));
      class p_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(p_.prototype);
          return e.__wbg_ptr = t, us.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, us.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_generaltransactionmetadata_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.generaltransactionmetadata_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.generaltransactionmetadata_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return p_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.generaltransactionmetadata_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.generaltransactionmetadata_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return p_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.generaltransactionmetadata_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.generaltransactionmetadata_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.generaltransactionmetadata_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return p_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.generaltransactionmetadata_new();
          return p_.__wrap(t);
        }
        len() {
          return r.generaltransactionmetadata_len(this.__wbg_ptr) >>> 0;
        }
        insert(t, e) {
          U(t, it), U(e, Wt);
          const a = r.generaltransactionmetadata_insert(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
          return a === 0 ? void 0 : Wt.__wrap(a);
        }
        get(t) {
          U(t, it);
          const e = r.generaltransactionmetadata_get(this.__wbg_ptr, t.__wbg_ptr);
          return e === 0 ? void 0 : Wt.__wrap(e);
        }
        keys() {
          const t = r.generaltransactionmetadata_keys(this.__wbg_ptr);
          return yn.__wrap(t);
        }
      }
      const fs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_genesisdelegatehash_free(d >>> 0));
      class nn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(nn.prototype);
          return e.__wbg_ptr = t, fs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, fs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_genesisdelegatehash_free(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.genesisdelegatehash_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return nn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519keyhash_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32(t) {
          let e, a;
          try {
            const y = r.__wbindgen_add_to_stack_pointer(-16), R = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), j = B;
            r.ed25519keyhash_to_bech32(y, this.__wbg_ptr, R, j);
            var n = o()[y / 4 + 0], _ = o()[y / 4 + 1], c = o()[y / 4 + 2], s = o()[y / 4 + 3], p = n, l = _;
            if (s) throw p = 0, l = 0, w(c);
            return e = p, a = l, H(p, l);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.genesisdelegatehash_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return nn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519keyhash_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.genesisdelegatehash_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return nn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const gs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_genesishash_free(d >>> 0));
      class _r {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(_r.prototype);
          return e.__wbg_ptr = t, gs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, gs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_genesishash_free(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.genesishash_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return _r.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519keyhash_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32(t) {
          let e, a;
          try {
            const y = r.__wbindgen_add_to_stack_pointer(-16), R = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), j = B;
            r.ed25519keyhash_to_bech32(y, this.__wbg_ptr, R, j);
            var n = o()[y / 4 + 0], _ = o()[y / 4 + 1], c = o()[y / 4 + 2], s = o()[y / 4 + 3], p = n, l = _;
            if (s) throw p = 0, l = 0, w(c);
            return e = p, a = l, H(p, l);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.genesishash_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return _r.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519keyhash_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.genesishash_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return _r.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const ws = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_genesishashes_free(d >>> 0));
      class X_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(X_.prototype);
          return e.__wbg_ptr = t, ws.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ws.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_genesishashes_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.genesishashes_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.genesishashes_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return X_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.genesishashes_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.genesishashes_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return X_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.genesishashes_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.genesishashes_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.genesishashes_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return X_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.genesishashes_new();
          return X_.__wrap(t);
        }
        len() {
          return r.genesishashes_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.genesishashes_get(this.__wbg_ptr, t);
          return _r.__wrap(e);
        }
        add(t) {
          U(t, _r), r.genesishashes_add(this.__wbg_ptr, t.__wbg_ptr);
        }
      }
      const hs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_genesiskeydelegation_free(d >>> 0));
      class u_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(u_.prototype);
          return e.__wbg_ptr = t, hs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, hs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_genesiskeydelegation_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.genesiskeydelegation_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.genesiskeydelegation_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return u_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.genesiskeydelegation_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.genesiskeydelegation_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return u_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.genesiskeydelegation_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.genesiskeydelegation_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.genesiskeydelegation_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return u_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        genesishash() {
          const t = r.genesiskeydelegation_genesishash(this.__wbg_ptr);
          return _r.__wrap(t);
        }
        genesis_delegate_hash() {
          const t = r.genesiskeydelegation_genesis_delegate_hash(this.__wbg_ptr);
          return nn.__wrap(t);
        }
        vrf_keyhash() {
          const t = r.genesiskeydelegation_vrf_keyhash(this.__wbg_ptr);
          return Hr.__wrap(t);
        }
        static new(t, e, a) {
          U(t, _r), U(e, nn), U(a, Hr);
          const n = r.genesiskeydelegation_new(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr);
          return u_.__wrap(n);
        }
      }
      const bs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_governanceaction_free(d >>> 0));
      class Be {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Be.prototype);
          return e.__wbg_ptr = t, bs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, bs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_governanceaction_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.governanceaction_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.governanceaction_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Be.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.governanceaction_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.governanceaction_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Be.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.governanceaction_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.governanceaction_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.governanceaction_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Be.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_parameter_change_action(t) {
          U(t, Ye);
          const e = r.governanceaction_new_parameter_change_action(t.__wbg_ptr);
          return Be.__wrap(e);
        }
        static new_hard_fork_initiation_action(t) {
          U(t, xr);
          const e = r.governanceaction_new_hard_fork_initiation_action(t.__wbg_ptr);
          return Be.__wrap(e);
        }
        static new_treasury_withdrawals_action(t) {
          U(t, Rr);
          const e = r.governanceaction_new_treasury_withdrawals_action(t.__wbg_ptr);
          return Be.__wrap(e);
        }
        static new_no_confidence_action(t) {
          U(t, jr);
          const e = r.governanceaction_new_no_confidence_action(t.__wbg_ptr);
          return Be.__wrap(e);
        }
        static new_new_committee_action(t) {
          U(t, Nr);
          const e = r.governanceaction_new_new_committee_action(t.__wbg_ptr);
          return Be.__wrap(e);
        }
        static new_new_constitution_action(t) {
          U(t, Tr);
          const e = r.governanceaction_new_new_constitution_action(t.__wbg_ptr);
          return Be.__wrap(e);
        }
        static new_info_action(t) {
          U(t, Nn);
          const e = r.governanceaction_new_info_action(t.__wbg_ptr);
          return Be.__wrap(e);
        }
        kind() {
          return r.governanceaction_kind(this.__wbg_ptr);
        }
        as_parameter_change_action() {
          const t = r.governanceaction_as_parameter_change_action(this.__wbg_ptr);
          return t === 0 ? void 0 : Ye.__wrap(t);
        }
        as_hard_fork_initiation_action() {
          const t = r.governanceaction_as_hard_fork_initiation_action(this.__wbg_ptr);
          return t === 0 ? void 0 : xr.__wrap(t);
        }
        as_treasury_withdrawals_action() {
          const t = r.governanceaction_as_treasury_withdrawals_action(this.__wbg_ptr);
          return t === 0 ? void 0 : Rr.__wrap(t);
        }
        as_no_confidence_action() {
          const t = r.governanceaction_as_no_confidence_action(this.__wbg_ptr);
          return t === 0 ? void 0 : jr.__wrap(t);
        }
        as_new_committee_action() {
          const t = r.governanceaction_as_new_committee_action(this.__wbg_ptr);
          return t === 0 ? void 0 : Nr.__wrap(t);
        }
        as_new_constitution_action() {
          const t = r.governanceaction_as_new_constitution_action(this.__wbg_ptr);
          return t === 0 ? void 0 : Tr.__wrap(t);
        }
        as_info_action() {
          const t = r.governanceaction_as_info_action(this.__wbg_ptr);
          return t === 0 ? void 0 : Nn.__wrap(t);
        }
      }
      const ys = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_governanceactionid_free(d >>> 0));
      class ne {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(ne.prototype);
          return e.__wbg_ptr = t, ys.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ys.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_governanceactionid_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.governanceactionid_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.governanceactionid_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ne.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.governanceactionid_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.governanceactionid_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ne.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.governanceactionid_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.governanceactionid_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.governanceactionid_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ne.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        transaction_id() {
          const t = r.governanceactionid_transaction_id(this.__wbg_ptr);
          return fr.__wrap(t);
        }
        index() {
          return r.governanceactionid_index(this.__wbg_ptr) >>> 0;
        }
        static new(t, e) {
          U(t, fr);
          const a = r.governanceactionid_new(t.__wbg_ptr, e);
          return ne.__wrap(a);
        }
      }
      const vs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_governanceactionids_free(d >>> 0));
      class In {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(In.prototype);
          return e.__wbg_ptr = t, vs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, vs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_governanceactionids_free(t);
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.governanceactionids_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.governanceactionids_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.governanceactionids_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return In.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.governanceactionids_new();
          return In.__wrap(t);
        }
        add(t) {
          U(t, ne), r.governanceactionids_add(this.__wbg_ptr, t.__wbg_ptr);
        }
        get(t) {
          const e = r.governanceactionids_get(this.__wbg_ptr, t);
          return e === 0 ? void 0 : ne.__wrap(e);
        }
        len() {
          return r.governanceactionids_len(this.__wbg_ptr) >>> 0;
        }
      }
      const ms = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_hardforkinitiationaction_free(d >>> 0));
      class xr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(xr.prototype);
          return e.__wbg_ptr = t, ms.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ms.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_hardforkinitiationaction_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.hardforkinitiationaction_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.hardforkinitiationaction_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return xr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.hardforkinitiationaction_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.hardforkinitiationaction_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return xr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.hardforkinitiationaction_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.hardforkinitiationaction_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.hardforkinitiationaction_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return xr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        gov_action_id() {
          const t = r.hardforkinitiationaction_gov_action_id(this.__wbg_ptr);
          return t === 0 ? void 0 : ne.__wrap(t);
        }
        protocol_version() {
          const t = r.hardforkinitiationaction_protocol_version(this.__wbg_ptr);
          return er.__wrap(t);
        }
        static new(t) {
          U(t, er);
          const e = r.hardforkinitiationaction_new(t.__wbg_ptr);
          return xr.__wrap(e);
        }
        static new_with_action_id(t, e) {
          U(t, ne), U(e, er);
          const a = r.hardforkinitiationaction_new_with_action_id(t.__wbg_ptr, e.__wbg_ptr);
          return xr.__wrap(a);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_header_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_headerbody_free(d >>> 0));
      const ks = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_infoaction_free(d >>> 0));
      class Nn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Nn.prototype);
          return e.__wbg_ptr = t, ks.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ks.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_infoaction_free(t);
        }
        static new() {
          const t = r.infoaction_new();
          return Nn.__wrap(t);
        }
      }
      const xs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_int_free(d >>> 0));
      class Jt {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Jt.prototype);
          return e.__wbg_ptr = t, xs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, xs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_int_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.int_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.int_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Jt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.int_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.int_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Jt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.int_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.int_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.int_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Jt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t) {
          U(t, it);
          const e = r.int_new(t.__wbg_ptr);
          return Jt.__wrap(e);
        }
        static new_negative(t) {
          U(t, it);
          const e = r.int_new_negative(t.__wbg_ptr);
          return Jt.__wrap(e);
        }
        static new_i32(t) {
          const e = r.int_new_i32(t);
          return Jt.__wrap(e);
        }
        is_positive() {
          return r.int_is_positive(this.__wbg_ptr) !== 0;
        }
        as_positive() {
          const t = r.int_as_positive(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        as_negative() {
          const t = r.int_as_negative(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        as_i32() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.int_as_i32(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        as_i32_or_nothing() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.int_as_i32_or_nothing(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        as_i32_or_fail() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.int_as_i32_or_fail(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return t;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_str() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.int_to_str(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_str(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.int_from_str(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Jt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const Es = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_ipv4_free(d >>> 0));
      class f_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(f_.prototype);
          return e.__wbg_ptr = t, Es.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Es.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_ipv4_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.ipv4_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.ipv4_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return f_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.ipv4_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.ipv4_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return f_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.ipv4_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.ipv4_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.ipv4_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return f_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.ipv4_new(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return f_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        ip() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.ipv4_ip(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const Cs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_ipv6_free(d >>> 0));
      class g_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(g_.prototype);
          return e.__wbg_ptr = t, Cs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Cs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_ipv6_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.ipv6_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.ipv6_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return g_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.ipv6_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.ipv6_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return g_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.ipv6_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.ipv6_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.ipv6_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return g_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.ipv6_new(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return g_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        ip() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.ipv6_ip(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_kessignature_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_kesvkey_free(d >>> 0));
      const Ss = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_language_free(d >>> 0));
      class Se {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Se.prototype);
          return e.__wbg_ptr = t, Ss.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ss.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_language_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.language_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.language_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Se.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.language_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.language_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Se.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.language_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.language_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.language_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Se.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_plutus_v1() {
          const t = r.language_new_plutus_v1();
          return Se.__wrap(t);
        }
        static new_plutus_v2() {
          const t = r.language_new_plutus_v2();
          return Se.__wrap(t);
        }
        static new_plutus_v3() {
          const t = r.language_new_plutus_v3();
          return Se.__wrap(t);
        }
        kind() {
          return r.language_kind(this.__wbg_ptr);
        }
      }
      const Ts = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_languages_free(d >>> 0));
      class mn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(mn.prototype);
          return e.__wbg_ptr = t, Ts.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ts.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_languages_free(t);
        }
        static new() {
          const t = r.languages_new();
          return mn.__wrap(t);
        }
        len() {
          return r.languages_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.languages_get(this.__wbg_ptr, t);
          return Se.__wrap(e);
        }
        add(t) {
          U(t, Se);
          var e = t.__destroy_into_raw();
          r.languages_add(this.__wbg_ptr, e);
        }
        static list() {
          const t = r.languages_list();
          return mn.__wrap(t);
        }
      }
      const js = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_legacydaedalusprivatekey_free(d >>> 0));
      class ra {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(ra.prototype);
          return e.__wbg_ptr = t, js.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, js.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_legacydaedalusprivatekey_free(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.legacydaedalusprivatekey_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ra.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        as_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.legacydaedalusprivatekey_as_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        chaincode() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.legacydaedalusprivatekey_chaincode(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_linearfee_free(d >>> 0));
      const As = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_mirtostakecredentials_free(d >>> 0));
      class w_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(w_.prototype);
          return e.__wbg_ptr = t, As.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, As.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_mirtostakecredentials_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.mirtostakecredentials_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.mirtostakecredentials_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return w_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.mirtostakecredentials_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.mirtostakecredentials_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return w_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.mirtostakecredentials_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.mirtostakecredentials_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.mirtostakecredentials_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return w_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.mirtostakecredentials_new();
          return w_.__wrap(t);
        }
        len() {
          return r.mirtostakecredentials_len(this.__wbg_ptr) >>> 0;
        }
        insert(t, e) {
          U(t, xt), U(e, Jt);
          const a = r.mirtostakecredentials_insert(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
          return a === 0 ? void 0 : Jt.__wrap(a);
        }
        get(t) {
          U(t, xt);
          const e = r.mirtostakecredentials_get(this.__wbg_ptr, t.__wbg_ptr);
          return e === 0 ? void 0 : Jt.__wrap(e);
        }
        keys() {
          const t = r.mirtostakecredentials_keys(this.__wbg_ptr);
          return tr.__wrap(t);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_malformedaddress_free(d >>> 0));
      const Is = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_metadatalist_free(d >>> 0));
      class Q_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Q_.prototype);
          return e.__wbg_ptr = t, Is.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Is.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_metadatalist_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.metadatalist_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.metadatalist_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Q_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.metadatalist_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.metadatalist_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Q_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.metadatalist_new();
          return Q_.__wrap(t);
        }
        len() {
          return r.metadatalist_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.metadatalist_get(this.__wbg_ptr, t);
          return Wt.__wrap(e);
        }
        add(t) {
          U(t, Wt), r.metadatalist_add(this.__wbg_ptr, t.__wbg_ptr);
        }
      }
      const Bs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_metadatamap_free(d >>> 0));
      class an {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(an.prototype);
          return e.__wbg_ptr = t, Bs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Bs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_metadatamap_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.metadatamap_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.metadatamap_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return an.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.metadatamap_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.metadatamap_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return an.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.generaltransactionmetadata_new();
          return an.__wrap(t);
        }
        len() {
          return r.generaltransactionmetadata_len(this.__wbg_ptr) >>> 0;
        }
        insert(t, e) {
          U(t, Wt), U(e, Wt);
          const a = r.metadatamap_insert(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
          return a === 0 ? void 0 : Wt.__wrap(a);
        }
        insert_str(t, e) {
          try {
            const c = r.__wbindgen_add_to_stack_pointer(-16), s = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), p = B;
            U(e, Wt), r.metadatamap_insert_str(c, this.__wbg_ptr, s, p, e.__wbg_ptr);
            var a = o()[c / 4 + 0], n = o()[c / 4 + 1], _ = o()[c / 4 + 2];
            if (_) throw w(n);
            return a === 0 ? void 0 : Wt.__wrap(a);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        insert_i32(t, e) {
          U(e, Wt);
          const a = r.metadatamap_insert_i32(this.__wbg_ptr, t, e.__wbg_ptr);
          return a === 0 ? void 0 : Wt.__wrap(a);
        }
        get(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, Wt), r.metadatamap_get(_, this.__wbg_ptr, t.__wbg_ptr);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Wt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        get_str(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.metadatamap_get_str(_, this.__wbg_ptr, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Wt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        get_i32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.metadatamap_get_i32(_, this.__wbg_ptr, t);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Wt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        has(t) {
          return U(t, Wt), r.metadatamap_has(this.__wbg_ptr, t.__wbg_ptr) !== 0;
        }
        keys() {
          const t = r.metadatamap_keys(this.__wbg_ptr);
          return Q_.__wrap(t);
        }
      }
      const Rs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_mint_free(d >>> 0));
      class Er {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Er.prototype);
          return e.__wbg_ptr = t, Rs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Rs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_mint_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.mint_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.mint_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Er.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.mint_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.mint_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Er.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.mint_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.mint_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.mint_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Er.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.assetnames_new();
          return Er.__wrap(t);
        }
        static new_from_entry(t, e) {
          U(t, Mt), U(e, Wr);
          const a = r.mint_new_from_entry(t.__wbg_ptr, e.__wbg_ptr);
          return Er.__wrap(a);
        }
        len() {
          return r.mint_len(this.__wbg_ptr) >>> 0;
        }
        insert(t, e) {
          U(t, Mt), U(e, Wr);
          const a = r.mint_insert(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
          return a === 0 ? void 0 : Wr.__wrap(a);
        }
        get(t) {
          U(t, Mt);
          const e = r.mint_get(this.__wbg_ptr, t.__wbg_ptr);
          return e === 0 ? void 0 : Bn.__wrap(e);
        }
        keys() {
          const t = r.mint_keys(this.__wbg_ptr);
          return B_.__wrap(t);
        }
        as_positive_multiasset() {
          const t = r.mint_as_positive_multiasset(this.__wbg_ptr);
          return Re.__wrap(t);
        }
        as_negative_multiasset() {
          const t = r.mint_as_negative_multiasset(this.__wbg_ptr);
          return Re.__wrap(t);
        }
      }
      const Ns = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_mintassets_free(d >>> 0));
      class Wr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Wr.prototype);
          return e.__wbg_ptr = t, Ns.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ns.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_mintassets_free(t);
        }
        static new() {
          const t = r.assets_new();
          return Wr.__wrap(t);
        }
        static new_from_entry(t, e) {
          try {
            const c = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, Ie), U(e, Jt), r.mintassets_new_from_entry(c, t.__wbg_ptr, e.__wbg_ptr);
            var a = o()[c / 4 + 0], n = o()[c / 4 + 1], _ = o()[c / 4 + 2];
            if (_) throw w(n);
            return Wr.__wrap(a);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        len() {
          return r.assets_len(this.__wbg_ptr) >>> 0;
        }
        insert(t, e) {
          try {
            const c = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, Ie), U(e, Jt), r.mintassets_insert(c, this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
            var a = o()[c / 4 + 0], n = o()[c / 4 + 1], _ = o()[c / 4 + 2];
            if (_) throw w(n);
            return a === 0 ? void 0 : Jt.__wrap(a);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        get(t) {
          U(t, Ie);
          const e = r.mintassets_get(this.__wbg_ptr, t.__wbg_ptr);
          return e === 0 ? void 0 : Jt.__wrap(e);
        }
        keys() {
          const t = r.mintassets_keys(this.__wbg_ptr);
          return e_.__wrap(t);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_mintbuilder_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_mintwitness_free(d >>> 0));
      const Ls = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_mintsassets_free(d >>> 0));
      class Bn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Bn.prototype);
          return e.__wbg_ptr = t, Ls.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ls.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_mintsassets_free(t);
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.mintsassets_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.mintsassets_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.mintsassets_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Bn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.assetnames_new();
          return Bn.__wrap(t);
        }
        add(t) {
          U(t, Wr), r.mintsassets_add(this.__wbg_ptr, t.__wbg_ptr);
        }
        get(t) {
          const e = r.mintsassets_get(this.__wbg_ptr, t);
          return e === 0 ? void 0 : Wr.__wrap(e);
        }
        len() {
          return r.assetnames_len(this.__wbg_ptr) >>> 0;
        }
      }
      const Fs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_moveinstantaneousreward_free(d >>> 0));
      class Cr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Cr.prototype);
          return e.__wbg_ptr = t, Fs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Fs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_moveinstantaneousreward_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.moveinstantaneousreward_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.moveinstantaneousreward_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Cr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.moveinstantaneousreward_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.moveinstantaneousreward_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Cr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.moveinstantaneousreward_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.moveinstantaneousreward_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.moveinstantaneousreward_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Cr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_to_other_pot(t, e) {
          U(e, it);
          const a = r.moveinstantaneousreward_new_to_other_pot(t, e.__wbg_ptr);
          return Cr.__wrap(a);
        }
        static new_to_stake_creds(t, e) {
          U(e, w_);
          const a = r.moveinstantaneousreward_new_to_stake_creds(t, e.__wbg_ptr);
          return Cr.__wrap(a);
        }
        pot() {
          return r.moveinstantaneousreward_pot(this.__wbg_ptr);
        }
        kind() {
          return r.moveinstantaneousreward_kind(this.__wbg_ptr);
        }
        as_to_other_pot() {
          const t = r.moveinstantaneousreward_as_to_other_pot(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        as_to_stake_creds() {
          const t = r.moveinstantaneousreward_as_to_stake_creds(this.__wbg_ptr);
          return t === 0 ? void 0 : w_.__wrap(t);
        }
      }
      const Os = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_moveinstantaneousrewardscert_free(d >>> 0));
      class h_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(h_.prototype);
          return e.__wbg_ptr = t, Os.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Os.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_moveinstantaneousrewardscert_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.moveinstantaneousrewardscert_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.moveinstantaneousrewardscert_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return h_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.moveinstantaneousrewardscert_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.moveinstantaneousrewardscert_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return h_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.moveinstantaneousrewardscert_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.moveinstantaneousrewardscert_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.moveinstantaneousrewardscert_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return h_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        move_instantaneous_reward() {
          const t = r.moveinstantaneousrewardscert_move_instantaneous_reward(this.__wbg_ptr);
          return Cr.__wrap(t);
        }
        static new(t) {
          U(t, Cr);
          const e = r.moveinstantaneousrewardscert_new(t.__wbg_ptr);
          return h_.__wrap(e);
        }
      }
      const Us = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_multiasset_free(d >>> 0));
      class Re {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Re.prototype);
          return e.__wbg_ptr = t, Us.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Us.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_multiasset_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.multiasset_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.multiasset_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Re.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.multiasset_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.multiasset_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Re.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.multiasset_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.multiasset_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.multiasset_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Re.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.assets_new();
          return Re.__wrap(t);
        }
        len() {
          return r.assets_len(this.__wbg_ptr) >>> 0;
        }
        insert(t, e) {
          U(t, Mt), U(e, Ur);
          const a = r.multiasset_insert(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
          return a === 0 ? void 0 : Ur.__wrap(a);
        }
        get(t) {
          U(t, Mt);
          const e = r.multiasset_get(this.__wbg_ptr, t.__wbg_ptr);
          return e === 0 ? void 0 : Ur.__wrap(e);
        }
        set_asset(t, e, a) {
          U(t, Mt), U(e, Ie), U(a, it);
          const n = r.multiasset_set_asset(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr);
          return n === 0 ? void 0 : it.__wrap(n);
        }
        get_asset(t, e) {
          U(t, Mt), U(e, Ie);
          const a = r.multiasset_get_asset(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
          return it.__wrap(a);
        }
        keys() {
          const t = r.multiasset_keys(this.__wbg_ptr);
          return B_.__wrap(t);
        }
        sub(t) {
          U(t, Re);
          const e = r.multiasset_sub(this.__wbg_ptr, t.__wbg_ptr);
          return Re.__wrap(e);
        }
      }
      const zs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_multihostname_free(d >>> 0));
      class b_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(b_.prototype);
          return e.__wbg_ptr = t, zs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, zs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_multihostname_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.multihostname_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.multihostname_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return b_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.multihostname_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.multihostname_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return b_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.multihostname_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.multihostname_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.multihostname_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return b_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        dns_name() {
          const t = r.multihostname_dns_name(this.__wbg_ptr);
          return i_.__wrap(t);
        }
        static new(t) {
          U(t, i_);
          const e = r.multihostname_dns_name(t.__wbg_ptr);
          return b_.__wrap(e);
        }
      }
      const Ds = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_nativescript_free(d >>> 0));
      class Ae {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Ae.prototype);
          return e.__wbg_ptr = t, Ds.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ds.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_nativescript_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.nativescript_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.nativescript_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ae.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.nativescript_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.nativescript_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ae.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.nativescript_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.nativescript_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.nativescript_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ae.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        hash() {
          const t = r.nativescript_hash(this.__wbg_ptr);
          return Mt.__wrap(t);
        }
        static new_script_pubkey(t) {
          U(t, N_);
          const e = r.nativescript_new_script_pubkey(t.__wbg_ptr);
          return Ae.__wrap(e);
        }
        static new_script_all(t) {
          U(t, A_);
          const e = r.nativescript_new_script_all(t.__wbg_ptr);
          return Ae.__wrap(e);
        }
        static new_script_any(t) {
          U(t, I_);
          const e = r.nativescript_new_script_any(t.__wbg_ptr);
          return Ae.__wrap(e);
        }
        static new_script_n_of_k(t) {
          U(t, R_);
          const e = r.nativescript_new_script_n_of_k(t.__wbg_ptr);
          return Ae.__wrap(e);
        }
        static new_timelock_start(t) {
          U(t, Br);
          const e = r.nativescript_new_timelock_start(t.__wbg_ptr);
          return Ae.__wrap(e);
        }
        static new_timelock_expiry(t) {
          U(t, Ir);
          const e = r.nativescript_new_timelock_expiry(t.__wbg_ptr);
          return Ae.__wrap(e);
        }
        kind() {
          return r.nativescript_kind(this.__wbg_ptr);
        }
        as_script_pubkey() {
          const t = r.nativescript_as_script_pubkey(this.__wbg_ptr);
          return t === 0 ? void 0 : N_.__wrap(t);
        }
        as_script_all() {
          const t = r.nativescript_as_script_all(this.__wbg_ptr);
          return t === 0 ? void 0 : A_.__wrap(t);
        }
        as_script_any() {
          const t = r.nativescript_as_script_any(this.__wbg_ptr);
          return t === 0 ? void 0 : I_.__wrap(t);
        }
        as_script_n_of_k() {
          const t = r.nativescript_as_script_n_of_k(this.__wbg_ptr);
          return t === 0 ? void 0 : R_.__wrap(t);
        }
        as_timelock_start() {
          const t = r.nativescript_as_timelock_start(this.__wbg_ptr);
          return t === 0 ? void 0 : Br.__wrap(t);
        }
        as_timelock_expiry() {
          const t = r.nativescript_as_timelock_expiry(this.__wbg_ptr);
          return t === 0 ? void 0 : Ir.__wrap(t);
        }
        get_required_signers() {
          const t = r.nativescript_get_required_signers(this.__wbg_ptr);
          return He.__wrap(t);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_nativescriptsource_free(d >>> 0));
      const Ps = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_nativescripts_free(d >>> 0));
      class Te {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Te.prototype);
          return e.__wbg_ptr = t, Ps.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ps.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_nativescripts_free(t);
        }
        static new() {
          const t = r.nativescripts_new();
          return Te.__wrap(t);
        }
        len() {
          return r.nativescripts_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.nativescripts_get(this.__wbg_ptr, t);
          return Ae.__wrap(e);
        }
        add(t) {
          U(t, Ae), r.nativescripts_add(this.__wbg_ptr, t.__wbg_ptr);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.nativescripts_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.nativescripts_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Te.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.nativescripts_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.nativescripts_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Te.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.nativescripts_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.nativescripts_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.nativescripts_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Te.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const Vs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_networkid_free(d >>> 0));
      class Sr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Sr.prototype);
          return e.__wbg_ptr = t, Vs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Vs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_networkid_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.networkid_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.networkid_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Sr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.networkid_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.networkid_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Sr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.networkid_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.networkid_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.networkid_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Sr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static testnet() {
          const t = r.networkid_testnet();
          return Sr.__wrap(t);
        }
        static mainnet() {
          const t = r.networkid_mainnet();
          return Sr.__wrap(t);
        }
        kind() {
          return r.networkid_kind(this.__wbg_ptr);
        }
      }
      const Ms = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_networkinfo_free(d >>> 0));
      class J_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(J_.prototype);
          return e.__wbg_ptr = t, Ms.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ms.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_networkinfo_free(t);
        }
        static new(t, e) {
          const a = r.networkinfo_new(t, e);
          return J_.__wrap(a);
        }
        network_id() {
          return r.networkinfo_network_id(this.__wbg_ptr);
        }
        protocol_magic() {
          return r.networkinfo_protocol_magic(this.__wbg_ptr) >>> 0;
        }
        static testnet_preview() {
          const t = r.networkinfo_testnet_preview();
          return J_.__wrap(t);
        }
        static testnet_preprod() {
          const t = r.networkinfo_testnet_preprod();
          return J_.__wrap(t);
        }
        static mainnet() {
          const t = r.networkinfo_mainnet();
          return J_.__wrap(t);
        }
      }
      const Ks = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_newconstitutionaction_free(d >>> 0));
      class Tr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Tr.prototype);
          return e.__wbg_ptr = t, Ks.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ks.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_newconstitutionaction_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.newconstitutionaction_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.newconstitutionaction_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Tr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.newconstitutionaction_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.newconstitutionaction_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Tr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.newconstitutionaction_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.newconstitutionaction_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.newconstitutionaction_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Tr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        gov_action_id() {
          const t = r.hardforkinitiationaction_gov_action_id(this.__wbg_ptr);
          return t === 0 ? void 0 : ne.__wrap(t);
        }
        constitution() {
          const t = r.newconstitutionaction_constitution(this.__wbg_ptr);
          return dr.__wrap(t);
        }
        static new(t) {
          U(t, dr);
          const e = r.newconstitutionaction_new(t.__wbg_ptr);
          return Tr.__wrap(e);
        }
        static new_with_action_id(t, e) {
          U(t, ne), U(e, dr);
          const a = r.newconstitutionaction_new_with_action_id(t.__wbg_ptr, e.__wbg_ptr);
          return Tr.__wrap(a);
        }
        has_script_hash() {
          return r.newconstitutionaction_has_script_hash(this.__wbg_ptr) !== 0;
        }
      }
      const qs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_noconfidenceaction_free(d >>> 0));
      class jr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(jr.prototype);
          return e.__wbg_ptr = t, qs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, qs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_noconfidenceaction_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.noconfidenceaction_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.noconfidenceaction_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return jr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.noconfidenceaction_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.noconfidenceaction_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return jr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.noconfidenceaction_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.noconfidenceaction_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.noconfidenceaction_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return jr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        gov_action_id() {
          const t = r.noconfidenceaction_gov_action_id(this.__wbg_ptr);
          return t === 0 ? void 0 : ne.__wrap(t);
        }
        static new() {
          const t = r.noconfidenceaction_new();
          return jr.__wrap(t);
        }
        static new_with_action_id(t) {
          U(t, ne);
          const e = r.noconfidenceaction_new_with_action_id(t.__wbg_ptr);
          return jr.__wrap(e);
        }
      }
      const Hs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_nonce_free(d >>> 0));
      class Zr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Zr.prototype);
          return e.__wbg_ptr = t, Hs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Hs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_nonce_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.nonce_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.nonce_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Zr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.nonce_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.nonce_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Zr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.nonce_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.nonce_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.nonce_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Zr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_identity() {
          const t = r.nonce_new_identity();
          return Zr.__wrap(t);
        }
        static new_from_hash(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.nonce_new_from_hash(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Zr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        get_hash() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.nonce_get_hash(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            let n;
            return t !== 0 && (n = nt(t, e).slice(), r.__wbindgen_free(t, e * 1, 1)), n;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_operationalcert_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_outputdatum_free(d >>> 0));
      const Gs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_parameterchangeaction_free(d >>> 0));
      class Ye {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Ye.prototype);
          return e.__wbg_ptr = t, Gs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Gs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_parameterchangeaction_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.parameterchangeaction_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.parameterchangeaction_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ye.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.parameterchangeaction_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.parameterchangeaction_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ye.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.parameterchangeaction_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.parameterchangeaction_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.parameterchangeaction_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ye.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        gov_action_id() {
          const t = r.parameterchangeaction_gov_action_id(this.__wbg_ptr);
          return t === 0 ? void 0 : ne.__wrap(t);
        }
        protocol_param_updates() {
          const t = r.parameterchangeaction_protocol_param_updates(this.__wbg_ptr);
          return Le.__wrap(t);
        }
        policy_hash() {
          const t = r.parameterchangeaction_policy_hash(this.__wbg_ptr);
          return t === 0 ? void 0 : Mt.__wrap(t);
        }
        static new(t) {
          U(t, Le);
          const e = r.parameterchangeaction_new(t.__wbg_ptr);
          return Ye.__wrap(e);
        }
        static new_with_action_id(t, e) {
          U(t, ne), U(e, Le);
          const a = r.parameterchangeaction_new_with_action_id(t.__wbg_ptr, e.__wbg_ptr);
          return Ye.__wrap(a);
        }
        static new_with_policy_hash(t, e) {
          U(t, Le), U(e, Mt);
          const a = r.parameterchangeaction_new_with_policy_hash(t.__wbg_ptr, e.__wbg_ptr);
          return Ye.__wrap(a);
        }
        static new_with_policy_hash_and_action_id(t, e, a) {
          U(t, ne), U(e, Le), U(a, Mt);
          const n = r.parameterchangeaction_new_with_policy_hash_and_action_id(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr);
          return Ye.__wrap(n);
        }
      }
      const Ws = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_plutusdata_free(d >>> 0));
      class Yt {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Yt.prototype);
          return e.__wbg_ptr = t, Ws.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ws.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_plutusdata_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutusdata_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.plutusdata_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Yt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutusdata_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.plutusdata_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Yt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_constr_plutus_data(t) {
          U(t, rn);
          const e = r.plutusdata_new_constr_plutus_data(t.__wbg_ptr);
          return Yt.__wrap(e);
        }
        static new_empty_constr_plutus_data(t) {
          U(t, it);
          const e = r.plutusdata_new_empty_constr_plutus_data(t.__wbg_ptr);
          return Yt.__wrap(e);
        }
        static new_single_value_constr_plutus_data(t, e) {
          U(t, it), U(e, Yt);
          const a = r.plutusdata_new_single_value_constr_plutus_data(t.__wbg_ptr, e.__wbg_ptr);
          return Yt.__wrap(a);
        }
        static new_map(t) {
          U(t, on);
          const e = r.plutusdata_new_map(t.__wbg_ptr);
          return Yt.__wrap(e);
        }
        static new_list(t) {
          U(t, Ge);
          const e = r.plutusdata_new_list(t.__wbg_ptr);
          return Yt.__wrap(e);
        }
        static new_integer(t) {
          U(t, Fo);
          const e = r.plutusdata_new_integer(t.__wbg_ptr);
          return Yt.__wrap(e);
        }
        static new_bytes(t) {
          const e = _t(t, r.__wbindgen_malloc), a = B, n = r.plutusdata_new_bytes(e, a);
          return Yt.__wrap(n);
        }
        kind() {
          return r.plutusdata_kind(this.__wbg_ptr);
        }
        as_constr_plutus_data() {
          const t = r.plutusdata_as_constr_plutus_data(this.__wbg_ptr);
          return t === 0 ? void 0 : rn.__wrap(t);
        }
        as_map() {
          const t = r.plutusdata_as_map(this.__wbg_ptr);
          return t === 0 ? void 0 : on.__wrap(t);
        }
        as_list() {
          const t = r.plutusdata_as_list(this.__wbg_ptr);
          return t === 0 ? void 0 : Ge.__wrap(t);
        }
        as_integer() {
          const t = r.plutusdata_as_integer(this.__wbg_ptr);
          return t === 0 ? void 0 : Fo.__wrap(t);
        }
        as_bytes() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutusdata_as_bytes(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            let n;
            return t !== 0 && (n = nt(t, e).slice(), r.__wbindgen_free(t, e * 1, 1)), n;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json(t) {
          let e, a;
          try {
            const y = r.__wbindgen_add_to_stack_pointer(-16);
            r.decode_plutus_datum_to_json_str(y, this.__wbg_ptr, t);
            var n = o()[y / 4 + 0], _ = o()[y / 4 + 1], c = o()[y / 4 + 2], s = o()[y / 4 + 3], p = n, l = _;
            if (s) throw p = 0, l = 0, w(c);
            return e = p, a = l, H(p, l);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_json(t, e) {
          try {
            const c = r.__wbindgen_add_to_stack_pointer(-16), s = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), p = B;
            r.encode_json_str_to_plutus_datum(c, s, p, e);
            var a = o()[c / 4 + 0], n = o()[c / 4 + 1], _ = o()[c / 4 + 2];
            if (_) throw w(n);
            return Yt.__wrap(a);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_address(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, _e), r.plutusdata_from_address(_, t.__wbg_ptr);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Yt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        as_address(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, J_), r.plutusdata_as_address(_, this.__wbg_ptr, t.__wbg_ptr);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return _e.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const Qs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_plutuslist_free(d >>> 0));
      class Ge {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Ge.prototype);
          return e.__wbg_ptr = t, Qs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Qs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_plutuslist_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutuslist_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.plutuslist_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ge.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutuslist_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.plutuslist_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ge.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.plutuslist_new();
          return Ge.__wrap(t);
        }
        len() {
          return r.plutuslist_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.plutuslist_get(this.__wbg_ptr, t);
          return Yt.__wrap(e);
        }
        add(t) {
          U(t, Yt), r.plutuslist_add(this.__wbg_ptr, t.__wbg_ptr);
        }
      }
      const $s = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_plutusmap_free(d >>> 0));
      class on {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(on.prototype);
          return e.__wbg_ptr = t, $s.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, $s.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_plutusmap_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutusmap_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.plutusmap_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return on.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutusmap_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.plutusmap_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return on.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.generaltransactionmetadata_new();
          return on.__wrap(t);
        }
        len() {
          return r.generaltransactionmetadata_len(this.__wbg_ptr) >>> 0;
        }
        insert(t, e) {
          U(t, Yt), U(e, kn);
          const a = r.plutusmap_insert(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
          return a === 0 ? void 0 : kn.__wrap(a);
        }
        get(t) {
          U(t, Yt);
          const e = r.plutusmap_get(this.__wbg_ptr, t.__wbg_ptr);
          return e === 0 ? void 0 : kn.__wrap(e);
        }
        keys() {
          const t = r.plutusmap_keys(this.__wbg_ptr);
          return Ge.__wrap(t);
        }
      }
      const Ys = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_plutusmapvalues_free(d >>> 0));
      class kn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(kn.prototype);
          return e.__wbg_ptr = t, Ys.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ys.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_plutusmapvalues_free(t);
        }
        static new() {
          const t = r.plutusmapvalues_new();
          return kn.__wrap(t);
        }
        len() {
          return r.plutuslist_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.plutusmapvalues_get(this.__wbg_ptr, t);
          return e === 0 ? void 0 : Yt.__wrap(e);
        }
        add(t) {
          U(t, Yt), r.plutusmapvalues_add(this.__wbg_ptr, t.__wbg_ptr);
        }
      }
      const Xs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_plutusscript_free(d >>> 0));
      class Ce {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Ce.prototype);
          return e.__wbg_ptr = t, Xs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Xs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_plutusscript_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutusscript_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.plutusscript_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ce.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutusscript_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.plutusscript_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ce.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t) {
          const e = _t(t, r.__wbindgen_malloc), a = B, n = r.plutusscript_new(e, a);
          return Ce.__wrap(n);
        }
        static new_v2(t) {
          const e = _t(t, r.__wbindgen_malloc), a = B, n = r.plutusscript_new_v2(e, a);
          return Ce.__wrap(n);
        }
        static new_v3(t) {
          const e = _t(t, r.__wbindgen_malloc), a = B, n = r.plutusscript_new_v3(e, a);
          return Ce.__wrap(n);
        }
        static new_with_version(t, e) {
          const a = _t(t, r.__wbindgen_malloc), n = B;
          U(e, Se);
          const _ = r.plutusscript_new_with_version(a, n, e.__wbg_ptr);
          return Ce.__wrap(_);
        }
        bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutusscript_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes_v2(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.plutusscript_from_bytes_v2(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ce.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes_v3(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.plutusscript_from_bytes_v3(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ce.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes_with_version(t, e) {
          try {
            const c = r.__wbindgen_add_to_stack_pointer(-16), s = _t(t, r.__wbindgen_malloc), p = B;
            U(e, Se), r.plutusscript_from_bytes_with_version(c, s, p, e.__wbg_ptr);
            var a = o()[c / 4 + 0], n = o()[c / 4 + 1], _ = o()[c / 4 + 2];
            if (_) throw w(n);
            return Ce.__wrap(a);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_hex_with_version(t, e) {
          try {
            const c = r.__wbindgen_add_to_stack_pointer(-16), s = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), p = B;
            U(e, Se), r.plutusscript_from_hex_with_version(c, s, p, e.__wbg_ptr);
            var a = o()[c / 4 + 0], n = o()[c / 4 + 1], _ = o()[c / 4 + 2];
            if (_) throw w(n);
            return Ce.__wrap(a);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        hash() {
          const t = r.plutusscript_hash(this.__wbg_ptr);
          return Mt.__wrap(t);
        }
        language_version() {
          const t = r.plutusscript_language_version(this.__wbg_ptr);
          return Se.__wrap(t);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_plutusscriptsource_free(d >>> 0));
      const Js = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_plutusscripts_free(d >>> 0));
      class lr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(lr.prototype);
          return e.__wbg_ptr = t, Js.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Js.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_plutusscripts_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutusscripts_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.plutusscripts_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return lr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutusscripts_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.plutusscripts_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return lr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutusscripts_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.plutusscripts_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.plutusscripts_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return lr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.plutusscripts_new();
          return lr.__wrap(t);
        }
        len() {
          return r.plutusscripts_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.plutusscripts_get(this.__wbg_ptr, t);
          return Ce.__wrap(e);
        }
        add(t) {
          U(t, Ce), r.plutusscripts_add(this.__wbg_ptr, t.__wbg_ptr);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_plutuswitness_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_plutuswitnesses_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_pointer_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_pointeraddress_free(d >>> 0));
      const Zs = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_poolmetadata_free(d >>> 0));
      class y_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(y_.prototype);
          return e.__wbg_ptr = t, Zs.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Zs.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_poolmetadata_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolmetadata_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.poolmetadata_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return y_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolmetadata_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.poolmetadata_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return y_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolmetadata_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolmetadata_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.poolmetadata_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return y_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        url() {
          const t = r.multihostname_dns_name(this.__wbg_ptr);
          return _a.__wrap(t);
        }
        pool_metadata_hash() {
          const t = r.poolmetadata_pool_metadata_hash(this.__wbg_ptr);
          return sn.__wrap(t);
        }
        static new(t, e) {
          U(t, _a), U(e, sn);
          const a = r.poolmetadata_new(t.__wbg_ptr, e.__wbg_ptr);
          return y_.__wrap(a);
        }
      }
      const ti = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_poolmetadatahash_free(d >>> 0));
      class sn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(sn.prototype);
          return e.__wbg_ptr = t, ti.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ti.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_poolmetadatahash_free(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.poolmetadatahash_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return sn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32(t) {
          let e, a;
          try {
            const y = r.__wbindgen_add_to_stack_pointer(-16), R = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), j = B;
            r.anchordatahash_to_bech32(y, this.__wbg_ptr, R, j);
            var n = o()[y / 4 + 0], _ = o()[y / 4 + 1], c = o()[y / 4 + 2], s = o()[y / 4 + 3], p = n, l = _;
            if (s) throw p = 0, l = 0, w(c);
            return e = p, a = l, H(p, l);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.poolmetadatahash_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return sn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.poolmetadatahash_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return sn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const ei = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_poolparams_free(d >>> 0));
      class v_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(v_.prototype);
          return e.__wbg_ptr = t, ei.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ei.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_poolparams_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolparams_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.poolparams_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return v_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolparams_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.poolparams_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return v_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolparams_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolparams_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.poolparams_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return v_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        operator() {
          const t = r.poolparams_operator(this.__wbg_ptr);
          return Dt.__wrap(t);
        }
        vrf_keyhash() {
          const t = r.poolparams_vrf_keyhash(this.__wbg_ptr);
          return Hr.__wrap(t);
        }
        pledge() {
          const t = r.poolparams_pledge(this.__wbg_ptr);
          return it.__wrap(t);
        }
        cost() {
          const t = r.poolparams_cost(this.__wbg_ptr);
          return it.__wrap(t);
        }
        margin() {
          const t = r.poolparams_margin(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        reward_account() {
          const t = r.poolparams_reward_account(this.__wbg_ptr);
          return Fe.__wrap(t);
        }
        pool_owners() {
          const t = r.poolparams_pool_owners(this.__wbg_ptr);
          return He.__wrap(t);
        }
        relays() {
          const t = r.poolparams_relays(this.__wbg_ptr);
          return T_.__wrap(t);
        }
        pool_metadata() {
          const t = r.poolparams_pool_metadata(this.__wbg_ptr);
          return t === 0 ? void 0 : y_.__wrap(t);
        }
        static new(t, e, a, n, _, c, s, p, l) {
          U(t, Dt), U(e, Hr), U(a, it), U(n, it), U(_, vt), U(c, Fe), U(s, He), U(p, T_);
          let y = 0;
          Gr(l) || (U(l, y_), y = l.__destroy_into_raw());
          const R = r.poolparams_new(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr, n.__wbg_ptr, _.__wbg_ptr, c.__wbg_ptr, s.__wbg_ptr, p.__wbg_ptr, y);
          return v_.__wrap(R);
        }
      }
      const ri = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_poolregistration_free(d >>> 0));
      class m_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(m_.prototype);
          return e.__wbg_ptr = t, ri.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ri.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_poolregistration_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolregistration_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.poolregistration_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return m_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolregistration_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.poolregistration_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return m_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolregistration_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolregistration_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.poolregistration_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return m_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        pool_params() {
          const t = r.poolregistration_pool_params(this.__wbg_ptr);
          return v_.__wrap(t);
        }
        static new(t) {
          U(t, v_);
          const e = r.poolregistration_new(t.__wbg_ptr);
          return m_.__wrap(e);
        }
      }
      const _i = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_poolretirement_free(d >>> 0));
      class k_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(k_.prototype);
          return e.__wbg_ptr = t, _i.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, _i.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_poolretirement_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolretirement_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.poolretirement_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return k_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolretirement_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.poolretirement_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return k_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolretirement_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolretirement_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.poolretirement_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return k_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        pool_keyhash() {
          const t = r.poolretirement_pool_keyhash(this.__wbg_ptr);
          return Dt.__wrap(t);
        }
        epoch() {
          return r.poolretirement_epoch(this.__wbg_ptr) >>> 0;
        }
        static new(t, e) {
          U(t, Dt);
          const a = r.poolretirement_new(t.__wbg_ptr, e);
          return k_.__wrap(a);
        }
      }
      const ni = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_poolvotingthresholds_free(d >>> 0));
      class x_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(x_.prototype);
          return e.__wbg_ptr = t, ni.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ni.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_poolvotingthresholds_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolvotingthresholds_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.poolvotingthresholds_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return x_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolvotingthresholds_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.poolvotingthresholds_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return x_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolvotingthresholds_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.poolvotingthresholds_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.poolvotingthresholds_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return x_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t, e, a, n, _) {
          U(t, vt), U(e, vt), U(a, vt), U(n, vt), U(_, vt);
          const c = r.poolvotingthresholds_new(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr, n.__wbg_ptr, _.__wbg_ptr);
          return x_.__wrap(c);
        }
        motion_no_confidence() {
          const t = r.drepvotingthresholds_motion_no_confidence(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        committee_normal() {
          const t = r.drepvotingthresholds_committee_normal(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        committee_no_confidence() {
          const t = r.drepvotingthresholds_committee_no_confidence(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        hard_fork_initiation() {
          const t = r.drepvotingthresholds_update_constitution(this.__wbg_ptr);
          return vt.__wrap(t);
        }
        security_relevant_threshold() {
          const t = r.drepvotingthresholds_hard_fork_initiation(this.__wbg_ptr);
          return vt.__wrap(t);
        }
      }
      const ai = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_privatekey_free(d >>> 0));
      class ir {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(ir.prototype);
          return e.__wbg_ptr = t, ai.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ai.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_privatekey_free(t);
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.privatekey_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ir.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.privatekey_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        sign(t) {
          const e = _t(t, r.__wbindgen_malloc), a = B, n = r.privatekey_sign(this.__wbg_ptr, e, a);
          return rr.__wrap(n);
        }
        static from_normal_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.privatekey_from_normal_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ir.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_extended_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.privatekey_from_extended_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ir.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        as_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.privatekey_as_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.privatekey_to_bech32(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.privatekey_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ir.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static generate_ed25519extended() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.privatekey_generate_ed25519extended(n);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return ir.__wrap(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static generate_ed25519() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.privatekey_generate_ed25519(n);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return ir.__wrap(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_public() {
          const t = r.privatekey_to_public(this.__wbg_ptr);
          return qr.__wrap(t);
        }
      }
      const oi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_proposedprotocolparameterupdates_free(d >>> 0));
      class E_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(E_.prototype);
          return e.__wbg_ptr = t, oi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, oi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_proposedprotocolparameterupdates_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.proposedprotocolparameterupdates_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.proposedprotocolparameterupdates_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return E_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.proposedprotocolparameterupdates_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.proposedprotocolparameterupdates_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return E_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.proposedprotocolparameterupdates_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.proposedprotocolparameterupdates_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.proposedprotocolparameterupdates_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return E_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.auxiliarydataset_new();
          return E_.__wrap(t);
        }
        len() {
          return r.auxiliarydataset_len(this.__wbg_ptr) >>> 0;
        }
        insert(t, e) {
          U(t, _r), U(e, Le);
          const a = r.proposedprotocolparameterupdates_insert(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
          return a === 0 ? void 0 : Le.__wrap(a);
        }
        get(t) {
          U(t, _r);
          const e = r.proposedprotocolparameterupdates_get(this.__wbg_ptr, t.__wbg_ptr);
          return e === 0 ? void 0 : Le.__wrap(e);
        }
        keys() {
          const t = r.proposedprotocolparameterupdates_keys(this.__wbg_ptr);
          return X_.__wrap(t);
        }
      }
      const si = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_protocolparamupdate_free(d >>> 0));
      class Le {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Le.prototype);
          return e.__wbg_ptr = t, si.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, si.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_protocolparamupdate_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.protocolparamupdate_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Le.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.protocolparamupdate_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Le.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.protocolparamupdate_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Le.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_minfee_a(t) {
          U(t, it), r.protocolparamupdate_set_minfee_a(this.__wbg_ptr, t.__wbg_ptr);
        }
        minfee_a() {
          const t = r.protocolparamupdate_minfee_a(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        set_minfee_b(t) {
          U(t, it), r.protocolparamupdate_set_minfee_b(this.__wbg_ptr, t.__wbg_ptr);
        }
        minfee_b() {
          const t = r.protocolparamupdate_minfee_b(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        set_max_block_body_size(t) {
          r.protocolparamupdate_set_max_block_body_size(this.__wbg_ptr, t);
        }
        max_block_body_size() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_max_block_body_size(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_max_tx_size(t) {
          r.protocolparamupdate_set_max_tx_size(this.__wbg_ptr, t);
        }
        max_tx_size() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_max_tx_size(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_max_block_header_size(t) {
          r.protocolparamupdate_set_max_block_header_size(this.__wbg_ptr, t);
        }
        max_block_header_size() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_max_block_header_size(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_key_deposit(t) {
          U(t, it), r.protocolparamupdate_set_key_deposit(this.__wbg_ptr, t.__wbg_ptr);
        }
        key_deposit() {
          const t = r.protocolparamupdate_key_deposit(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        set_pool_deposit(t) {
          U(t, it), r.protocolparamupdate_set_pool_deposit(this.__wbg_ptr, t.__wbg_ptr);
        }
        pool_deposit() {
          const t = r.protocolparamupdate_pool_deposit(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        set_max_epoch(t) {
          r.protocolparamupdate_set_max_epoch(this.__wbg_ptr, t);
        }
        max_epoch() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_max_epoch(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_n_opt(t) {
          r.protocolparamupdate_set_n_opt(this.__wbg_ptr, t);
        }
        n_opt() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_n_opt(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_pool_pledge_influence(t) {
          U(t, vt), r.protocolparamupdate_set_pool_pledge_influence(this.__wbg_ptr, t.__wbg_ptr);
        }
        pool_pledge_influence() {
          const t = r.protocolparamupdate_pool_pledge_influence(this.__wbg_ptr);
          return t === 0 ? void 0 : vt.__wrap(t);
        }
        set_expansion_rate(t) {
          U(t, vt), r.protocolparamupdate_set_expansion_rate(this.__wbg_ptr, t.__wbg_ptr);
        }
        expansion_rate() {
          const t = r.protocolparamupdate_expansion_rate(this.__wbg_ptr);
          return t === 0 ? void 0 : vt.__wrap(t);
        }
        set_treasury_growth_rate(t) {
          U(t, vt), r.protocolparamupdate_set_treasury_growth_rate(this.__wbg_ptr, t.__wbg_ptr);
        }
        treasury_growth_rate() {
          const t = r.protocolparamupdate_treasury_growth_rate(this.__wbg_ptr);
          return t === 0 ? void 0 : vt.__wrap(t);
        }
        d() {
          const t = r.protocolparamupdate_d(this.__wbg_ptr);
          return t === 0 ? void 0 : vt.__wrap(t);
        }
        extra_entropy() {
          const t = r.protocolparamupdate_extra_entropy(this.__wbg_ptr);
          return t === 0 ? void 0 : Zr.__wrap(t);
        }
        set_protocol_version(t) {
          U(t, er), r.protocolparamupdate_set_protocol_version(this.__wbg_ptr, t.__wbg_ptr);
        }
        protocol_version() {
          const t = r.protocolparamupdate_protocol_version(this.__wbg_ptr);
          return t === 0 ? void 0 : er.__wrap(t);
        }
        set_min_pool_cost(t) {
          U(t, it), r.protocolparamupdate_set_min_pool_cost(this.__wbg_ptr, t.__wbg_ptr);
        }
        min_pool_cost() {
          const t = r.protocolparamupdate_min_pool_cost(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        set_ada_per_utxo_byte(t) {
          U(t, it), r.protocolparamupdate_set_ada_per_utxo_byte(this.__wbg_ptr, t.__wbg_ptr);
        }
        ada_per_utxo_byte() {
          const t = r.protocolparamupdate_ada_per_utxo_byte(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        set_cost_models(t) {
          U(t, vr), r.protocolparamupdate_set_cost_models(this.__wbg_ptr, t.__wbg_ptr);
        }
        cost_models() {
          const t = r.protocolparamupdate_cost_models(this.__wbg_ptr);
          return t === 0 ? void 0 : vr.__wrap(t);
        }
        set_execution_costs(t) {
          U(t, l_), r.protocolparamupdate_set_execution_costs(this.__wbg_ptr, t.__wbg_ptr);
        }
        execution_costs() {
          const t = r.protocolparamupdate_execution_costs(this.__wbg_ptr);
          return t === 0 ? void 0 : l_.__wrap(t);
        }
        set_max_tx_ex_units(t) {
          U(t, Ve), r.protocolparamupdate_set_max_tx_ex_units(this.__wbg_ptr, t.__wbg_ptr);
        }
        max_tx_ex_units() {
          const t = r.protocolparamupdate_max_tx_ex_units(this.__wbg_ptr);
          return t === 0 ? void 0 : Ve.__wrap(t);
        }
        set_max_block_ex_units(t) {
          U(t, Ve), r.protocolparamupdate_set_max_block_ex_units(this.__wbg_ptr, t.__wbg_ptr);
        }
        max_block_ex_units() {
          const t = r.protocolparamupdate_max_block_ex_units(this.__wbg_ptr);
          return t === 0 ? void 0 : Ve.__wrap(t);
        }
        set_max_value_size(t) {
          r.protocolparamupdate_set_max_value_size(this.__wbg_ptr, t);
        }
        max_value_size() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_max_value_size(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_collateral_percentage(t) {
          r.protocolparamupdate_set_collateral_percentage(this.__wbg_ptr, t);
        }
        collateral_percentage() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_collateral_percentage(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_max_collateral_inputs(t) {
          r.protocolparamupdate_set_max_collateral_inputs(this.__wbg_ptr, t);
        }
        max_collateral_inputs() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_max_collateral_inputs(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_pool_voting_thresholds(t) {
          U(t, x_), r.protocolparamupdate_set_pool_voting_thresholds(this.__wbg_ptr, t.__wbg_ptr);
        }
        pool_voting_thresholds() {
          const t = r.protocolparamupdate_pool_voting_thresholds(this.__wbg_ptr);
          return t === 0 ? void 0 : x_.__wrap(t);
        }
        set_drep_voting_thresholds(t) {
          U(t, d_), r.protocolparamupdate_set_drep_voting_thresholds(this.__wbg_ptr, t.__wbg_ptr);
        }
        drep_voting_thresholds() {
          const t = r.protocolparamupdate_drep_voting_thresholds(this.__wbg_ptr);
          return t === 0 ? void 0 : d_.__wrap(t);
        }
        set_min_committee_size(t) {
          r.protocolparamupdate_set_min_committee_size(this.__wbg_ptr, t);
        }
        min_committee_size() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_min_committee_size(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_committee_term_limit(t) {
          r.protocolparamupdate_set_committee_term_limit(this.__wbg_ptr, t);
        }
        committee_term_limit() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_committee_term_limit(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_governance_action_validity_period(t) {
          r.protocolparamupdate_set_governance_action_validity_period(this.__wbg_ptr, t);
        }
        governance_action_validity_period() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_governance_action_validity_period(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_governance_action_deposit(t) {
          U(t, it), r.protocolparamupdate_set_governance_action_deposit(this.__wbg_ptr, t.__wbg_ptr);
        }
        governance_action_deposit() {
          const t = r.protocolparamupdate_governance_action_deposit(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        set_drep_deposit(t) {
          U(t, it), r.protocolparamupdate_set_drep_deposit(this.__wbg_ptr, t.__wbg_ptr);
        }
        drep_deposit() {
          const t = r.protocolparamupdate_drep_deposit(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        set_drep_inactivity_period(t) {
          r.protocolparamupdate_set_drep_inactivity_period(this.__wbg_ptr, t);
        }
        drep_inactivity_period() {
          try {
            const a = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolparamupdate_drep_inactivity_period(a, this.__wbg_ptr);
            var t = o()[a / 4 + 0], e = o()[a / 4 + 1];
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_ref_script_coins_per_byte(t) {
          U(t, vt), r.protocolparamupdate_set_ref_script_coins_per_byte(this.__wbg_ptr, t.__wbg_ptr);
        }
        ref_script_coins_per_byte() {
          const t = r.protocolparamupdate_ref_script_coins_per_byte(this.__wbg_ptr);
          return t === 0 ? void 0 : vt.__wrap(t);
        }
        static new() {
          const t = r.protocolparamupdate_new();
          return Le.__wrap(t);
        }
      }
      const ii = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_protocolversion_free(d >>> 0));
      class er {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(er.prototype);
          return e.__wbg_ptr = t, ii.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ii.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_protocolversion_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolversion_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.protocolversion_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return er.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolversion_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.protocolversion_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return er.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolversion_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.protocolversion_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.protocolversion_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return er.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        major() {
          return r.protocolversion_major(this.__wbg_ptr) >>> 0;
        }
        minor() {
          return r.protocolversion_minor(this.__wbg_ptr) >>> 0;
        }
        static new(t, e) {
          const a = r.protocolversion_new(t, e);
          return er.__wrap(a);
        }
      }
      const ci = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_publickey_free(d >>> 0));
      class qr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(qr.prototype);
          return e.__wbg_ptr = t, ci.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ci.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_publickey_free(t);
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.publickey_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return qr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.publickey_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        hash() {
          const t = r.publickey_hash(this.__wbg_ptr);
          return Dt.__wrap(t);
        }
        verify(t, e) {
          const a = _t(t, r.__wbindgen_malloc), n = B;
          return U(e, rr), r.publickey_verify(this.__wbg_ptr, a, n, e.__wbg_ptr) !== 0;
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.publickey_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return qr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        as_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.publickey_as_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.publickey_to_bech32(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.publickey_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return qr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_publickeys_free(d >>> 0));
      const di = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_redeemer_free(d >>> 0));
      class C_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(C_.prototype);
          return e.__wbg_ptr = t, di.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, di.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_redeemer_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.redeemer_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.redeemer_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return C_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.redeemer_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.redeemer_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return C_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.redeemer_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.redeemer_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.redeemer_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return C_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        tag() {
          const t = r.redeemer_tag(this.__wbg_ptr);
          return De.__wrap(t);
        }
        index() {
          const t = r.redeemer_index(this.__wbg_ptr);
          return it.__wrap(t);
        }
        data() {
          const t = r.redeemer_data(this.__wbg_ptr);
          return Yt.__wrap(t);
        }
        ex_units() {
          const t = r.redeemer_ex_units(this.__wbg_ptr);
          return Ve.__wrap(t);
        }
        static new(t, e, a, n) {
          U(t, De), U(e, it), U(a, Yt), U(n, Ve);
          const _ = r.redeemer_new(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr, n.__wbg_ptr);
          return C_.__wrap(_);
        }
      }
      const li = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_redeemertag_free(d >>> 0));
      class De {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(De.prototype);
          return e.__wbg_ptr = t, li.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, li.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_redeemertag_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.redeemertag_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.redeemertag_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return De.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.redeemertag_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.redeemertag_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return De.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.redeemertag_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.redeemertag_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.redeemertag_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return De.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_spend() {
          const t = r.redeemertag_new_spend();
          return De.__wrap(t);
        }
        static new_mint() {
          const t = r.redeemertag_new_mint();
          return De.__wrap(t);
        }
        static new_cert() {
          const t = r.redeemertag_new_cert();
          return De.__wrap(t);
        }
        static new_reward() {
          const t = r.redeemertag_new_reward();
          return De.__wrap(t);
        }
        static new_vote() {
          const t = r.redeemertag_new_vote();
          return De.__wrap(t);
        }
        static new_voting_proposal() {
          const t = r.redeemertag_new_voting_proposal();
          return De.__wrap(t);
        }
        kind() {
          return r.redeemertag_kind(this.__wbg_ptr);
        }
      }
      const pi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_redeemers_free(d >>> 0));
      class S_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(S_.prototype);
          return e.__wbg_ptr = t, pi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, pi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_redeemers_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.redeemers_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.redeemers_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return S_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.redeemers_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.redeemers_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return S_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.redeemers_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.redeemers_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.redeemers_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return S_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.redeemers_new();
          return S_.__wrap(t);
        }
        len() {
          return r.redeemers_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.redeemers_get(this.__wbg_ptr, t);
          return C_.__wrap(e);
        }
        add(t) {
          U(t, C_), r.redeemers_add(this.__wbg_ptr, t.__wbg_ptr);
        }
        get_container_type() {
          return r.redeemers_get_container_type(this.__wbg_ptr);
        }
        total_ex_units() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.redeemers_total_ex_units(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return Ve.__wrap(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const ui = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_relay_free(d >>> 0));
      class cr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(cr.prototype);
          return e.__wbg_ptr = t, ui.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ui.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_relay_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.relay_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.relay_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return cr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.relay_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.relay_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return cr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.relay_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.relay_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.relay_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return cr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_single_host_addr(t) {
          U(t, L_);
          const e = r.relay_new_single_host_addr(t.__wbg_ptr);
          return cr.__wrap(e);
        }
        static new_single_host_name(t) {
          U(t, F_);
          const e = r.relay_new_single_host_name(t.__wbg_ptr);
          return cr.__wrap(e);
        }
        static new_multi_host_name(t) {
          U(t, b_);
          const e = r.relay_new_multi_host_name(t.__wbg_ptr);
          return cr.__wrap(e);
        }
        kind() {
          return r.relay_kind(this.__wbg_ptr);
        }
        as_single_host_addr() {
          const t = r.relay_as_single_host_addr(this.__wbg_ptr);
          return t === 0 ? void 0 : L_.__wrap(t);
        }
        as_single_host_name() {
          const t = r.relay_as_single_host_name(this.__wbg_ptr);
          return t === 0 ? void 0 : F_.__wrap(t);
        }
        as_multi_host_name() {
          const t = r.relay_as_multi_host_name(this.__wbg_ptr);
          return t === 0 ? void 0 : b_.__wrap(t);
        }
      }
      const fi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_relays_free(d >>> 0));
      class T_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(T_.prototype);
          return e.__wbg_ptr = t, fi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, fi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_relays_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.relays_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.relays_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return T_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.relays_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.relays_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return T_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.relays_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.relays_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.relays_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return T_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.relays_new();
          return T_.__wrap(t);
        }
        len() {
          return r.relays_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.relays_get(this.__wbg_ptr, t);
          return cr.__wrap(e);
        }
        add(t) {
          U(t, cr), r.relays_add(this.__wbg_ptr, t.__wbg_ptr);
        }
      }
      const gi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_rewardaddress_free(d >>> 0));
      class Fe {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Fe.prototype);
          return e.__wbg_ptr = t, gi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, gi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_rewardaddress_free(t);
        }
        static new(t, e) {
          U(e, xt);
          const a = r.enterpriseaddress_new(t, e.__wbg_ptr);
          return Fe.__wrap(a);
        }
        payment_cred() {
          const t = r.baseaddress_payment_cred(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        to_address() {
          const t = r.rewardaddress_to_address(this.__wbg_ptr);
          return _e.__wrap(t);
        }
        static from_address(t) {
          U(t, _e);
          const e = r.rewardaddress_from_address(t.__wbg_ptr);
          return e === 0 ? void 0 : Fe.__wrap(e);
        }
        network_id() {
          return r.enterpriseaddress_network_id(this.__wbg_ptr);
        }
      }
      const wi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_rewardaddresses_free(d >>> 0));
      class j_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(j_.prototype);
          return e.__wbg_ptr = t, wi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, wi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_rewardaddresses_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.rewardaddresses_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.rewardaddresses_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return j_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.rewardaddresses_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.rewardaddresses_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return j_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.rewardaddresses_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.rewardaddresses_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.rewardaddresses_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return j_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.genesishashes_new();
          return j_.__wrap(t);
        }
        len() {
          return r.rewardaddresses_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.rewardaddresses_get(this.__wbg_ptr, t);
          return Fe.__wrap(e);
        }
        add(t) {
          U(t, Fe), r.rewardaddresses_add(this.__wbg_ptr, t.__wbg_ptr);
        }
      }
      const hi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_scriptall_free(d >>> 0));
      class A_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(A_.prototype);
          return e.__wbg_ptr = t, hi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, hi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_scriptall_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptall_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.scriptall_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return A_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptall_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scriptall_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return A_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptall_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptall_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scriptall_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return A_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        native_scripts() {
          const t = r.scriptall_native_scripts(this.__wbg_ptr);
          return Te.__wrap(t);
        }
        static new(t) {
          U(t, Te);
          const e = r.scriptall_new(t.__wbg_ptr);
          return A_.__wrap(e);
        }
      }
      const bi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_scriptany_free(d >>> 0));
      class I_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(I_.prototype);
          return e.__wbg_ptr = t, bi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, bi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_scriptany_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptany_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.scriptany_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return I_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptany_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scriptany_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return I_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptany_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptany_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scriptany_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return I_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        native_scripts() {
          const t = r.scriptall_native_scripts(this.__wbg_ptr);
          return Te.__wrap(t);
        }
        static new(t) {
          U(t, Te);
          const e = r.scriptall_new(t.__wbg_ptr);
          return I_.__wrap(e);
        }
      }
      const yi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_scriptdatahash_free(d >>> 0));
      class cn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(cn.prototype);
          return e.__wbg_ptr = t, yi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, yi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_scriptdatahash_free(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.scriptdatahash_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return cn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32(t) {
          let e, a;
          try {
            const y = r.__wbindgen_add_to_stack_pointer(-16), R = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), j = B;
            r.anchordatahash_to_bech32(y, this.__wbg_ptr, R, j);
            var n = o()[y / 4 + 0], _ = o()[y / 4 + 1], c = o()[y / 4 + 2], s = o()[y / 4 + 3], p = n, l = _;
            if (s) throw p = 0, l = 0, w(c);
            return e = p, a = l, H(p, l);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scriptdatahash_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return cn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scriptdatahash_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return cn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const vi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_scripthash_free(d >>> 0));
      class Mt {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Mt.prototype);
          return e.__wbg_ptr = t, vi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, vi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_scripthash_free(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.scripthash_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Mt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519keyhash_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32(t) {
          let e, a;
          try {
            const y = r.__wbindgen_add_to_stack_pointer(-16), R = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), j = B;
            r.ed25519keyhash_to_bech32(y, this.__wbg_ptr, R, j);
            var n = o()[y / 4 + 0], _ = o()[y / 4 + 1], c = o()[y / 4 + 2], s = o()[y / 4 + 3], p = n, l = _;
            if (s) throw p = 0, l = 0, w(c);
            return e = p, a = l, H(p, l);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scripthash_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Mt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.ed25519keyhash_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scripthash_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Mt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const mi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_scripthashes_free(d >>> 0));
      class B_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(B_.prototype);
          return e.__wbg_ptr = t, mi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, mi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_scripthashes_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.scripthashes_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.scripthashes_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return B_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.scripthashes_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scripthashes_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return B_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.scripthashes_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.scripthashes_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scripthashes_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return B_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.genesishashes_new();
          return B_.__wrap(t);
        }
        len() {
          return r.genesishashes_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.scripthashes_get(this.__wbg_ptr, t);
          return Mt.__wrap(e);
        }
        add(t) {
          U(t, Mt), r.scripthashes_add(this.__wbg_ptr, t.__wbg_ptr);
        }
      }
      const ki = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_scriptnofk_free(d >>> 0));
      class R_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(R_.prototype);
          return e.__wbg_ptr = t, ki.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ki.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_scriptnofk_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptnofk_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.scriptnofk_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return R_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptnofk_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scriptnofk_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return R_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptnofk_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptnofk_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scriptnofk_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return R_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        n() {
          return r.scriptnofk_n(this.__wbg_ptr) >>> 0;
        }
        native_scripts() {
          const t = r.scriptall_native_scripts(this.__wbg_ptr);
          return Te.__wrap(t);
        }
        static new(t, e) {
          U(e, Te);
          const a = r.scriptnofk_new(t, e.__wbg_ptr);
          return R_.__wrap(a);
        }
      }
      const xi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_scriptpubkey_free(d >>> 0));
      class N_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(N_.prototype);
          return e.__wbg_ptr = t, xi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, xi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_scriptpubkey_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptpubkey_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.scriptpubkey_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return N_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptpubkey_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scriptpubkey_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return N_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptpubkey_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptpubkey_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scriptpubkey_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return N_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        addr_keyhash() {
          const t = r.scriptpubkey_addr_keyhash(this.__wbg_ptr);
          return Dt.__wrap(t);
        }
        static new(t) {
          U(t, Dt);
          const e = r.scriptpubkey_new(t.__wbg_ptr);
          return N_.__wrap(e);
        }
      }
      const Ei = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_scriptref_free(d >>> 0));
      class Ar {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Ar.prototype);
          return e.__wbg_ptr = t, Ei.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ei.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_scriptref_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptref_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.scriptref_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ar.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptref_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scriptref_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ar.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptref_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptref_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.scriptref_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ar.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_native_script(t) {
          U(t, Ae);
          const e = r.scriptref_new_native_script(t.__wbg_ptr);
          return Ar.__wrap(e);
        }
        static new_plutus_script(t) {
          U(t, Ce);
          const e = r.scriptref_new_plutus_script(t.__wbg_ptr);
          return Ar.__wrap(e);
        }
        is_native_script() {
          return r.scriptref_is_native_script(this.__wbg_ptr) !== 0;
        }
        is_plutus_script() {
          return r.scriptref_is_plutus_script(this.__wbg_ptr) !== 0;
        }
        native_script() {
          const t = r.scriptref_native_script(this.__wbg_ptr);
          return t === 0 ? void 0 : Ae.__wrap(t);
        }
        plutus_script() {
          const t = r.scriptref_plutus_script(this.__wbg_ptr);
          return t === 0 ? void 0 : Ce.__wrap(t);
        }
        to_unwrapped_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.scriptref_to_unwrapped_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const Ci = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_singlehostaddr_free(d >>> 0));
      class L_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(L_.prototype);
          return e.__wbg_ptr = t, Ci.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ci.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_singlehostaddr_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.singlehostaddr_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.singlehostaddr_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return L_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.singlehostaddr_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.singlehostaddr_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return L_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.singlehostaddr_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.singlehostaddr_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.singlehostaddr_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return L_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        port() {
          const t = r.singlehostaddr_port(this.__wbg_ptr);
          return t === 16777215 ? void 0 : t;
        }
        ipv4() {
          const t = r.singlehostaddr_ipv4(this.__wbg_ptr);
          return t === 0 ? void 0 : f_.__wrap(t);
        }
        ipv6() {
          const t = r.singlehostaddr_ipv6(this.__wbg_ptr);
          return t === 0 ? void 0 : g_.__wrap(t);
        }
        static new(t, e, a) {
          let n = 0;
          Gr(e) || (U(e, f_), n = e.__destroy_into_raw());
          let _ = 0;
          Gr(a) || (U(a, g_), _ = a.__destroy_into_raw());
          const c = r.singlehostaddr_new(Gr(t) ? 16777215 : t, n, _);
          return L_.__wrap(c);
        }
      }
      const Si = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_singlehostname_free(d >>> 0));
      class F_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(F_.prototype);
          return e.__wbg_ptr = t, Si.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Si.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_singlehostname_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.singlehostname_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.singlehostname_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return F_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.singlehostname_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.singlehostname_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return F_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.singlehostname_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.singlehostname_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.singlehostname_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return F_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        port() {
          const t = r.singlehostname_port(this.__wbg_ptr);
          return t === 16777215 ? void 0 : t;
        }
        dns_name() {
          const t = r.multihostname_dns_name(this.__wbg_ptr);
          return s_.__wrap(t);
        }
        static new(t, e) {
          U(e, s_);
          const a = r.singlehostname_new(Gr(t) ? 16777215 : t, e.__wbg_ptr);
          return F_.__wrap(a);
        }
      }
      const Ti = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_stakeandvotedelegation_free(d >>> 0));
      class O_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(O_.prototype);
          return e.__wbg_ptr = t, Ti.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ti.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_stakeandvotedelegation_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakeandvotedelegation_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.stakeandvotedelegation_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return O_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakeandvotedelegation_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.stakeandvotedelegation_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return O_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakeandvotedelegation_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakeandvotedelegation_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.stakeandvotedelegation_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return O_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        stake_credential() {
          const t = r.committeehotauth_committee_cold_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        pool_keyhash() {
          const t = r.stakeandvotedelegation_pool_keyhash(this.__wbg_ptr);
          return Dt.__wrap(t);
        }
        drep() {
          const t = r.stakeandvotedelegation_drep(this.__wbg_ptr);
          return se.__wrap(t);
        }
        static new(t, e, a) {
          U(t, xt), U(e, Dt), U(a, se);
          const n = r.stakeandvotedelegation_new(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr);
          return O_.__wrap(n);
        }
        has_script_credentials() {
          return r.committeehotauth_has_script_credentials(this.__wbg_ptr) !== 0;
        }
      }
      const ji = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_stakedelegation_free(d >>> 0));
      class U_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(U_.prototype);
          return e.__wbg_ptr = t, ji.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ji.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_stakedelegation_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakedelegation_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.stakedelegation_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return U_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakedelegation_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.stakedelegation_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return U_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakedelegation_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakedelegation_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.stakedelegation_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return U_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        stake_credential() {
          const t = r.stakedelegation_stake_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        pool_keyhash() {
          const t = r.stakedelegation_pool_keyhash(this.__wbg_ptr);
          return Dt.__wrap(t);
        }
        static new(t, e) {
          U(t, xt), U(e, Dt);
          const a = r.stakedelegation_new(t.__wbg_ptr, e.__wbg_ptr);
          return U_.__wrap(a);
        }
        has_script_credentials() {
          return r.stakedelegation_has_script_credentials(this.__wbg_ptr) !== 0;
        }
      }
      const Ai = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_stakederegistration_free(d >>> 0));
      class Je {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Je.prototype);
          return e.__wbg_ptr = t, Ai.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ai.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_stakederegistration_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakederegistration_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.stakederegistration_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Je.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakederegistration_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.stakederegistration_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Je.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakederegistration_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakederegistration_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.stakederegistration_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Je.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        stake_credential() {
          const t = r.stakederegistration_stake_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        coin() {
          const t = r.stakederegistration_coin(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        static new(t) {
          U(t, xt);
          const e = r.stakederegistration_new(t.__wbg_ptr);
          return Je.__wrap(e);
        }
        static new_with_explicit_refund(t, e) {
          U(t, xt), U(e, it);
          const a = r.stakederegistration_new_with_explicit_refund(t.__wbg_ptr, e.__wbg_ptr);
          return Je.__wrap(a);
        }
        has_script_credentials() {
          return r.stakederegistration_has_script_credentials(this.__wbg_ptr) !== 0;
        }
      }
      const Ii = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_stakeregistration_free(d >>> 0));
      class Ze {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Ze.prototype);
          return e.__wbg_ptr = t, Ii.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ii.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_stakeregistration_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakeregistration_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.stakeregistration_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ze.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakeregistration_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.stakeregistration_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ze.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakeregistration_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakeregistration_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.stakeregistration_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ze.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        stake_credential() {
          const t = r.stakeregistration_stake_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        coin() {
          const t = r.stakeregistration_coin(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        static new(t) {
          U(t, xt);
          const e = r.stakeregistration_new(t.__wbg_ptr);
          return Ze.__wrap(e);
        }
        static new_with_explicit_deposit(t, e) {
          U(t, xt), U(e, it);
          const a = r.stakeregistration_new_with_explicit_deposit(t.__wbg_ptr, e.__wbg_ptr);
          return Ze.__wrap(a);
        }
        has_script_credentials() {
          return r.stakeregistration_has_script_credentials(this.__wbg_ptr) !== 0;
        }
      }
      const Bi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_stakeregistrationanddelegation_free(d >>> 0));
      class z_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(z_.prototype);
          return e.__wbg_ptr = t, Bi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Bi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_stakeregistrationanddelegation_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakeregistrationanddelegation_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.stakeregistrationanddelegation_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return z_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakeregistrationanddelegation_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.stakeregistrationanddelegation_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return z_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakeregistrationanddelegation_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakeregistrationanddelegation_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.stakeregistrationanddelegation_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return z_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        stake_credential() {
          const t = r.stakeregistrationanddelegation_stake_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        pool_keyhash() {
          const t = r.stakeregistrationanddelegation_pool_keyhash(this.__wbg_ptr);
          return Dt.__wrap(t);
        }
        coin() {
          const t = r.stakeregistrationanddelegation_coin(this.__wbg_ptr);
          return it.__wrap(t);
        }
        static new(t, e, a) {
          U(t, xt), U(e, Dt), U(a, it);
          const n = r.stakeregistrationanddelegation_new(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr);
          return z_.__wrap(n);
        }
        has_script_credentials() {
          return r.stakeregistrationanddelegation_has_script_credentials(this.__wbg_ptr) !== 0;
        }
      }
      const Ri = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_stakevoteregistrationanddelegation_free(d >>> 0));
      class D_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(D_.prototype);
          return e.__wbg_ptr = t, Ri.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ri.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_stakevoteregistrationanddelegation_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakevoteregistrationanddelegation_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.stakevoteregistrationanddelegation_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return D_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakevoteregistrationanddelegation_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.stakevoteregistrationanddelegation_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return D_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakevoteregistrationanddelegation_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.stakevoteregistrationanddelegation_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.stakevoteregistrationanddelegation_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return D_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        stake_credential() {
          const t = r.stakevoteregistrationanddelegation_stake_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        pool_keyhash() {
          const t = r.stakeregistrationanddelegation_pool_keyhash(this.__wbg_ptr);
          return Dt.__wrap(t);
        }
        drep() {
          const t = r.stakevoteregistrationanddelegation_drep(this.__wbg_ptr);
          return se.__wrap(t);
        }
        coin() {
          const t = r.stakeregistrationanddelegation_coin(this.__wbg_ptr);
          return it.__wrap(t);
        }
        static new(t, e, a, n) {
          U(t, xt), U(e, Dt), U(a, se), U(n, it);
          const _ = r.stakevoteregistrationanddelegation_new(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr, n.__wbg_ptr);
          return D_.__wrap(_);
        }
        has_script_credentials() {
          return r.stakevoteregistrationanddelegation_has_script_credentials(this.__wbg_ptr) !== 0;
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_strings_free(d >>> 0));
      const Ni = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_timelockexpiry_free(d >>> 0));
      class Ir {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Ir.prototype);
          return e.__wbg_ptr = t, Ni.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ni.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_timelockexpiry_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.timelockexpiry_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.timelockexpiry_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ir.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.timelockexpiry_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.timelockexpiry_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ir.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.timelockexpiry_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.timelockexpiry_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.timelockexpiry_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ir.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        slot() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.timelockexpiry_slot(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return t >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        slot_bignum() {
          const t = r.timelockexpiry_slot_bignum(this.__wbg_ptr);
          return it.__wrap(t);
        }
        static new(t) {
          const e = r.timelockexpiry_new(t);
          return Ir.__wrap(e);
        }
        static new_timelockexpiry(t) {
          U(t, it);
          const e = r.timelockexpiry_new_timelockexpiry(t.__wbg_ptr);
          return Ir.__wrap(e);
        }
      }
      const Li = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_timelockstart_free(d >>> 0));
      class Br {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Br.prototype);
          return e.__wbg_ptr = t, Li.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Li.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_timelockstart_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.timelockstart_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.timelockstart_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Br.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.timelockstart_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.timelockstart_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Br.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.timelockstart_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.timelockstart_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.timelockstart_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Br.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        slot() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.timelockexpiry_slot(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return t >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        slot_bignum() {
          const t = r.timelockexpiry_slot_bignum(this.__wbg_ptr);
          return it.__wrap(t);
        }
        static new(t) {
          const e = r.timelockexpiry_new(t);
          return Br.__wrap(e);
        }
        static new_timelockstart(t) {
          U(t, it);
          const e = r.timelockexpiry_new_timelockexpiry(t.__wbg_ptr);
          return Br.__wrap(e);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_transaction_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_transactionbatch_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_transactionbatchlist_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_transactionbodies_free(d >>> 0));
      const Fi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_transactionbody_free(d >>> 0));
      class t_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(t_.prototype);
          return e.__wbg_ptr = t, Fi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Fi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_transactionbody_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionbody_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.transactionbody_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return t_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionbody_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactionbody_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return t_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionbody_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionbody_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactionbody_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return t_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        inputs() {
          const t = r.transactionbody_inputs(this.__wbg_ptr);
          return Ne.__wrap(t);
        }
        outputs() {
          const t = r.transactionbody_outputs(this.__wbg_ptr);
          return Vr.__wrap(t);
        }
        fee() {
          const t = r.transactionbody_fee(this.__wbg_ptr);
          return it.__wrap(t);
        }
        ttl() {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionbody_ttl(_, this.__wbg_ptr);
            var t = o()[_ / 4 + 0], e = o()[_ / 4 + 1], a = o()[_ / 4 + 2], n = o()[_ / 4 + 3];
            if (n) throw w(a);
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        ttl_bignum() {
          const t = r.transactionbody_ttl_bignum(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        set_ttl(t) {
          U(t, it), r.transactionbody_set_ttl(this.__wbg_ptr, t.__wbg_ptr);
        }
        remove_ttl() {
          r.transactionbody_remove_ttl(this.__wbg_ptr);
        }
        set_certs(t) {
          U(t, a_), r.transactionbody_set_certs(this.__wbg_ptr, t.__wbg_ptr);
        }
        certs() {
          const t = r.transactionbody_certs(this.__wbg_ptr);
          return t === 0 ? void 0 : a_.__wrap(t);
        }
        set_withdrawals(t) {
          U(t, G_), r.transactionbody_set_withdrawals(this.__wbg_ptr, t.__wbg_ptr);
        }
        withdrawals() {
          const t = r.transactionbody_withdrawals(this.__wbg_ptr);
          return t === 0 ? void 0 : G_.__wrap(t);
        }
        set_update(t) {
          U(t, V_), r.transactionbody_set_update(this.__wbg_ptr, t.__wbg_ptr);
        }
        update() {
          const t = r.transactionbody_update(this.__wbg_ptr);
          return t === 0 ? void 0 : V_.__wrap(t);
        }
        set_auxiliary_data_hash(t) {
          U(t, en), r.transactionbody_set_auxiliary_data_hash(this.__wbg_ptr, t.__wbg_ptr);
        }
        auxiliary_data_hash() {
          const t = r.transactionbody_auxiliary_data_hash(this.__wbg_ptr);
          return t === 0 ? void 0 : en.__wrap(t);
        }
        set_validity_start_interval(t) {
          r.transactionbody_set_validity_start_interval(this.__wbg_ptr, t);
        }
        set_validity_start_interval_bignum(t) {
          U(t, it), r.transactionbody_set_validity_start_interval_bignum(this.__wbg_ptr, t.__wbg_ptr);
        }
        validity_start_interval_bignum() {
          const t = r.transactionbody_validity_start_interval_bignum(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        validity_start_interval() {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionbody_validity_start_interval(_, this.__wbg_ptr);
            var t = o()[_ / 4 + 0], e = o()[_ / 4 + 1], a = o()[_ / 4 + 2], n = o()[_ / 4 + 3];
            if (n) throw w(a);
            return t === 0 ? void 0 : e >>> 0;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_mint(t) {
          U(t, Er), r.transactionbody_set_mint(this.__wbg_ptr, t.__wbg_ptr);
        }
        mint() {
          const t = r.transactionbody_mint(this.__wbg_ptr);
          return t === 0 ? void 0 : Er.__wrap(t);
        }
        set_reference_inputs(t) {
          U(t, Ne), r.transactionbody_set_reference_inputs(this.__wbg_ptr, t.__wbg_ptr);
        }
        reference_inputs() {
          const t = r.transactionbody_reference_inputs(this.__wbg_ptr);
          return t === 0 ? void 0 : Ne.__wrap(t);
        }
        set_script_data_hash(t) {
          U(t, cn), r.transactionbody_set_script_data_hash(this.__wbg_ptr, t.__wbg_ptr);
        }
        script_data_hash() {
          const t = r.transactionbody_script_data_hash(this.__wbg_ptr);
          return t === 0 ? void 0 : cn.__wrap(t);
        }
        set_collateral(t) {
          U(t, Ne), r.transactionbody_set_collateral(this.__wbg_ptr, t.__wbg_ptr);
        }
        collateral() {
          const t = r.transactionbody_collateral(this.__wbg_ptr);
          return t === 0 ? void 0 : Ne.__wrap(t);
        }
        set_required_signers(t) {
          U(t, He), r.transactionbody_set_required_signers(this.__wbg_ptr, t.__wbg_ptr);
        }
        required_signers() {
          const t = r.transactionbody_required_signers(this.__wbg_ptr);
          return t === 0 ? void 0 : He.__wrap(t);
        }
        set_network_id(t) {
          U(t, Sr), r.transactionbody_set_network_id(this.__wbg_ptr, t.__wbg_ptr);
        }
        network_id() {
          const t = r.transactionbody_network_id(this.__wbg_ptr);
          return t === 0 ? void 0 : Sr.__wrap(t);
        }
        set_collateral_return(t) {
          U(t, pr), r.transactionbody_set_collateral_return(this.__wbg_ptr, t.__wbg_ptr);
        }
        collateral_return() {
          const t = r.transactionbody_collateral_return(this.__wbg_ptr);
          return t === 0 ? void 0 : pr.__wrap(t);
        }
        set_total_collateral(t) {
          U(t, it), r.transactionbody_set_total_collateral(this.__wbg_ptr, t.__wbg_ptr);
        }
        total_collateral() {
          const t = r.transactionbody_total_collateral(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        set_voting_procedures(t) {
          U(t, H_), r.transactionbody_set_voting_procedures(this.__wbg_ptr, t.__wbg_ptr);
        }
        voting_procedures() {
          const t = r.transactionbody_voting_procedures(this.__wbg_ptr);
          return t === 0 ? void 0 : H_.__wrap(t);
        }
        set_voting_proposals(t) {
          U(t, Fr), r.transactionbody_set_voting_proposals(this.__wbg_ptr, t.__wbg_ptr);
        }
        voting_proposals() {
          const t = r.transactionbody_voting_proposals(this.__wbg_ptr);
          return t === 0 ? void 0 : Fr.__wrap(t);
        }
        set_donation(t) {
          U(t, it), r.transactionbody_set_donation(this.__wbg_ptr, t.__wbg_ptr);
        }
        donation() {
          const t = r.transactionbody_donation(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        set_current_treasury_value(t) {
          U(t, it), r.transactionbody_set_current_treasury_value(this.__wbg_ptr, t.__wbg_ptr);
        }
        current_treasury_value() {
          const t = r.transactionbody_current_treasury_value(this.__wbg_ptr);
          return t === 0 ? void 0 : it.__wrap(t);
        }
        static new(t, e, a, n) {
          U(t, Ne), U(e, Vr), U(a, it);
          const _ = r.transactionbody_new(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr, !Gr(n), Gr(n) ? 0 : n);
          return t_.__wrap(_);
        }
        static new_tx_body(t, e, a) {
          U(t, Ne), U(e, Vr), U(a, it);
          const n = r.transactionbody_new_tx_body(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr);
          return t_.__wrap(n);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_transactionbuilder_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_transactionbuilderconfig_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_transactionbuilderconfigbuilder_free(d >>> 0));
      const Oi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_transactionhash_free(d >>> 0));
      class fr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(fr.prototype);
          return e.__wbg_ptr = t, Oi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Oi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_transactionhash_free(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.transactionhash_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return fr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32(t) {
          let e, a;
          try {
            const y = r.__wbindgen_add_to_stack_pointer(-16), R = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), j = B;
            r.anchordatahash_to_bech32(y, this.__wbg_ptr, R, j);
            var n = o()[y / 4 + 0], _ = o()[y / 4 + 1], c = o()[y / 4 + 2], s = o()[y / 4 + 3], p = n, l = _;
            if (s) throw p = 0, l = 0, w(c);
            return e = p, a = l, H(p, l);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactionhash_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return fr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactionhash_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return fr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const Ui = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_transactioninput_free(d >>> 0));
      class P_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(P_.prototype);
          return e.__wbg_ptr = t, Ui.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ui.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_transactioninput_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactioninput_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.transactioninput_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return P_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactioninput_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactioninput_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return P_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactioninput_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactioninput_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactioninput_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return P_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        transaction_id() {
          const t = r.governanceactionid_transaction_id(this.__wbg_ptr);
          return fr.__wrap(t);
        }
        index() {
          return r.governanceactionid_index(this.__wbg_ptr) >>> 0;
        }
        static new(t, e) {
          U(t, fr);
          const a = r.governanceactionid_new(t.__wbg_ptr, e);
          return P_.__wrap(a);
        }
      }
      const zi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_transactioninputs_free(d >>> 0));
      class Ne {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Ne.prototype);
          return e.__wbg_ptr = t, zi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, zi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_transactioninputs_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactioninputs_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.transactioninputs_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ne.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactioninputs_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactioninputs_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ne.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactioninputs_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactioninputs_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactioninputs_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ne.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.transactioninputs_new();
          return Ne.__wrap(t);
        }
        len() {
          return r.transactioninputs_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.transactioninputs_get(this.__wbg_ptr, t);
          return P_.__wrap(e);
        }
        add(t) {
          return U(t, P_), r.transactioninputs_add(this.__wbg_ptr, t.__wbg_ptr) !== 0;
        }
        to_option() {
          const t = r.transactioninputs_to_option(this.__wbg_ptr);
          return t === 0 ? void 0 : Ne.__wrap(t);
        }
      }
      const Di = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_transactionmetadatum_free(d >>> 0));
      class Wt {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Wt.prototype);
          return e.__wbg_ptr = t, Di.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Di.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_transactionmetadatum_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionmetadatum_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.transactionmetadatum_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Wt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionmetadatum_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactionmetadatum_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Wt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_map(t) {
          U(t, an);
          const e = r.transactionmetadatum_new_map(t.__wbg_ptr);
          return Wt.__wrap(e);
        }
        static new_list(t) {
          U(t, Q_);
          const e = r.transactionmetadatum_new_list(t.__wbg_ptr);
          return Wt.__wrap(e);
        }
        static new_int(t) {
          U(t, Jt);
          const e = r.transactionmetadatum_new_int(t.__wbg_ptr);
          return Wt.__wrap(e);
        }
        static new_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.transactionmetadatum_new_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Wt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_text(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactionmetadatum_new_text(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Wt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        kind() {
          return r.transactionmetadatum_kind(this.__wbg_ptr);
        }
        as_map() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionmetadatum_as_map(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return an.__wrap(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        as_list() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionmetadatum_as_list(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return Q_.__wrap(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        as_int() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionmetadatum_as_int(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return Jt.__wrap(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        as_bytes() {
          try {
            const c = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionmetadatum_as_bytes(c, this.__wbg_ptr);
            var t = o()[c / 4 + 0], e = o()[c / 4 + 1], a = o()[c / 4 + 2], n = o()[c / 4 + 3];
            if (n) throw w(a);
            var _ = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), _;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        as_text() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionmetadatum_as_text(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
      }
      const Pi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_transactionmetadatumlabels_free(d >>> 0));
      class yn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(yn.prototype);
          return e.__wbg_ptr = t, Pi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Pi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_transactionmetadatumlabels_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionmetadatumlabels_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.transactionmetadatumlabels_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return yn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionmetadatumlabels_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactionmetadatumlabels_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return yn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.plutusmapvalues_new();
          return yn.__wrap(t);
        }
        len() {
          return r.transactionmetadatumlabels_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.transactionmetadatumlabels_get(this.__wbg_ptr, t);
          return it.__wrap(e);
        }
        add(t) {
          U(t, it), r.transactionmetadatumlabels_add(this.__wbg_ptr, t.__wbg_ptr);
        }
      }
      const Vi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_transactionoutput_free(d >>> 0));
      class pr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(pr.prototype);
          return e.__wbg_ptr = t, Vi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Vi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_transactionoutput_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionoutput_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.transactionoutput_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return pr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionoutput_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactionoutput_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return pr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionoutput_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionoutput_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactionoutput_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return pr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        address() {
          const t = r.transactionoutput_address(this.__wbg_ptr);
          return _e.__wrap(t);
        }
        amount() {
          const t = r.transactionoutput_amount(this.__wbg_ptr);
          return Ee.__wrap(t);
        }
        data_hash() {
          const t = r.transactionoutput_data_hash(this.__wbg_ptr);
          return t === 0 ? void 0 : _n.__wrap(t);
        }
        plutus_data() {
          const t = r.transactionoutput_plutus_data(this.__wbg_ptr);
          return t === 0 ? void 0 : Yt.__wrap(t);
        }
        script_ref() {
          const t = r.transactionoutput_script_ref(this.__wbg_ptr);
          return t === 0 ? void 0 : Ar.__wrap(t);
        }
        set_script_ref(t) {
          U(t, Ar), r.transactionoutput_set_script_ref(this.__wbg_ptr, t.__wbg_ptr);
        }
        set_plutus_data(t) {
          U(t, Yt), r.transactionoutput_set_plutus_data(this.__wbg_ptr, t.__wbg_ptr);
        }
        set_data_hash(t) {
          U(t, _n), r.transactionoutput_set_data_hash(this.__wbg_ptr, t.__wbg_ptr);
        }
        has_plutus_data() {
          return r.transactionoutput_has_plutus_data(this.__wbg_ptr) !== 0;
        }
        has_data_hash() {
          return r.transactionoutput_has_data_hash(this.__wbg_ptr) !== 0;
        }
        has_script_ref() {
          return r.transactionoutput_has_script_ref(this.__wbg_ptr) !== 0;
        }
        static new(t, e) {
          U(t, _e), U(e, Ee);
          const a = r.transactionoutput_new(t.__wbg_ptr, e.__wbg_ptr);
          return pr.__wrap(a);
        }
        serialization_format() {
          const t = r.transactionoutput_serialization_format(this.__wbg_ptr);
          return t === 2 ? void 0 : t;
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_transactionoutputamountbuilder_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_transactionoutputbuilder_free(d >>> 0));
      const Mi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_transactionoutputs_free(d >>> 0));
      class Vr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Vr.prototype);
          return e.__wbg_ptr = t, Mi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Mi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_transactionoutputs_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionoutputs_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.transactionoutputs_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Vr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionoutputs_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactionoutputs_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Vr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionoutputs_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionoutputs_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactionoutputs_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Vr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.transactionoutputs_new();
          return Vr.__wrap(t);
        }
        len() {
          return r.transactionoutputs_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.transactionoutputs_get(this.__wbg_ptr, t);
          return pr.__wrap(e);
        }
        add(t) {
          U(t, pr), r.transactionoutputs_add(this.__wbg_ptr, t.__wbg_ptr);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_transactionunspentoutput_free(d >>> 0));
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_transactionunspentoutputs_free(d >>> 0));
      const Ki = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_transactionwitnessset_free(d >>> 0));
      class Z_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Z_.prototype);
          return e.__wbg_ptr = t, Ki.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ki.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_transactionwitnessset_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionwitnessset_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.transactionwitnessset_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Z_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionwitnessset_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactionwitnessset_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Z_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionwitnessset_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.transactionwitnessset_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.transactionwitnessset_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Z_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        set_vkeys(t) {
          U(t, M_), r.transactionwitnessset_set_vkeys(this.__wbg_ptr, t.__wbg_ptr);
        }
        vkeys() {
          const t = r.transactionwitnessset_vkeys(this.__wbg_ptr);
          return t === 0 ? void 0 : M_.__wrap(t);
        }
        set_native_scripts(t) {
          U(t, Te), r.transactionwitnessset_set_native_scripts(this.__wbg_ptr, t.__wbg_ptr);
        }
        native_scripts() {
          const t = r.transactionwitnessset_native_scripts(this.__wbg_ptr);
          return t === 0 ? void 0 : Te.__wrap(t);
        }
        set_bootstraps(t) {
          U(t, __), r.transactionwitnessset_set_bootstraps(this.__wbg_ptr, t.__wbg_ptr);
        }
        bootstraps() {
          const t = r.transactionwitnessset_bootstraps(this.__wbg_ptr);
          return t === 0 ? void 0 : __.__wrap(t);
        }
        set_plutus_scripts(t) {
          U(t, lr), r.transactionwitnessset_set_plutus_scripts(this.__wbg_ptr, t.__wbg_ptr);
        }
        plutus_scripts() {
          const t = r.transactionwitnessset_plutus_scripts(this.__wbg_ptr);
          return t === 0 ? void 0 : lr.__wrap(t);
        }
        set_plutus_data(t) {
          U(t, Ge), r.transactionwitnessset_set_plutus_data(this.__wbg_ptr, t.__wbg_ptr);
        }
        plutus_data() {
          const t = r.transactionwitnessset_plutus_data(this.__wbg_ptr);
          return t === 0 ? void 0 : Ge.__wrap(t);
        }
        set_redeemers(t) {
          U(t, S_), r.transactionwitnessset_set_redeemers(this.__wbg_ptr, t.__wbg_ptr);
        }
        redeemers() {
          const t = r.transactionwitnessset_redeemers(this.__wbg_ptr);
          return t === 0 ? void 0 : S_.__wrap(t);
        }
        static new() {
          const t = r.transactionwitnessset_new();
          return Z_.__wrap(t);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_transactionwitnesssets_free(d >>> 0));
      const qi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_treasurywithdrawals_free(d >>> 0));
      class ln {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(ln.prototype);
          return e.__wbg_ptr = t, qi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, qi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_treasurywithdrawals_free(t);
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.treasurywithdrawals_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.treasurywithdrawals_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.treasurywithdrawals_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ln.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.treasurywithdrawals_new();
          return ln.__wrap(t);
        }
        get(t) {
          U(t, Fe);
          const e = r.treasurywithdrawals_get(this.__wbg_ptr, t.__wbg_ptr);
          return e === 0 ? void 0 : it.__wrap(e);
        }
        insert(t, e) {
          U(t, Fe), U(e, it), r.treasurywithdrawals_insert(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
        }
        keys() {
          const t = r.treasurywithdrawals_keys(this.__wbg_ptr);
          return j_.__wrap(t);
        }
        len() {
          return r.treasurywithdrawals_len(this.__wbg_ptr) >>> 0;
        }
      }
      const Hi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_treasurywithdrawalsaction_free(d >>> 0));
      class Rr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Rr.prototype);
          return e.__wbg_ptr = t, Hi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Hi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_treasurywithdrawalsaction_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.treasurywithdrawalsaction_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.treasurywithdrawalsaction_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Rr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.treasurywithdrawalsaction_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.treasurywithdrawalsaction_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Rr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.treasurywithdrawalsaction_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.treasurywithdrawalsaction_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.treasurywithdrawalsaction_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Rr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        withdrawals() {
          const t = r.treasurywithdrawalsaction_withdrawals(this.__wbg_ptr);
          return ln.__wrap(t);
        }
        policy_hash() {
          const t = r.treasurywithdrawalsaction_policy_hash(this.__wbg_ptr);
          return t === 0 ? void 0 : Mt.__wrap(t);
        }
        static new(t) {
          U(t, ln);
          const e = r.treasurywithdrawalsaction_new(t.__wbg_ptr);
          return Rr.__wrap(e);
        }
        static new_with_policy_hash(t, e) {
          U(t, ln), U(e, Mt);
          const a = r.treasurywithdrawalsaction_new_with_policy_hash(t.__wbg_ptr, e.__wbg_ptr);
          return Rr.__wrap(a);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_txinputsbuilder_free(d >>> 0));
      const Gi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_url_free(d >>> 0));
      let _a = class bn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(bn.prototype);
          return e.__wbg_ptr = t, Gi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Gi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_url_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.url_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.url_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return bn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.url_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.url_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return bn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.dnsrecordaoraaaa_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.dnsrecordaoraaaa_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.url_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return bn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.url_new(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return bn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        url() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.dnsrecordaoraaaa_record(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
      };
      const Wi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_unitinterval_free(d >>> 0));
      class vt {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(vt.prototype);
          return e.__wbg_ptr = t, Wi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Wi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_unitinterval_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.unitinterval_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.unitinterval_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return vt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.unitinterval_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.unitinterval_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return vt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.unitinterval_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.unitinterval_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.unitinterval_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return vt.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        numerator() {
          const t = r.datacost_coins_per_byte(this.__wbg_ptr);
          return it.__wrap(t);
        }
        denominator() {
          const t = r.unitinterval_denominator(this.__wbg_ptr);
          return it.__wrap(t);
        }
        static new(t, e) {
          U(t, it), U(e, it);
          const a = r.unitinterval_new(t.__wbg_ptr, e.__wbg_ptr);
          return vt.__wrap(a);
        }
      }
      const Qi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_update_free(d >>> 0));
      class V_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(V_.prototype);
          return e.__wbg_ptr = t, Qi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Qi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_update_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.update_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.update_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return V_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.update_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.update_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return V_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.update_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.update_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.update_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return V_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        proposed_protocol_parameter_updates() {
          const t = r.update_proposed_protocol_parameter_updates(this.__wbg_ptr);
          return E_.__wrap(t);
        }
        epoch() {
          return r.update_epoch(this.__wbg_ptr) >>> 0;
        }
        static new(t, e) {
          U(t, E_);
          const a = r.update_new(t.__wbg_ptr, e);
          return V_.__wrap(a);
        }
      }
      const $i = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_updatecommitteeaction_free(d >>> 0));
      class Nr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Nr.prototype);
          return e.__wbg_ptr = t, $i.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, $i.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_updatecommitteeaction_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.updatecommitteeaction_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.updatecommitteeaction_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Nr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.updatecommitteeaction_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.updatecommitteeaction_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Nr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.updatecommitteeaction_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.updatecommitteeaction_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.updatecommitteeaction_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Nr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        gov_action_id() {
          const t = r.updatecommitteeaction_gov_action_id(this.__wbg_ptr);
          return t === 0 ? void 0 : ne.__wrap(t);
        }
        committee() {
          const t = r.updatecommitteeaction_committee(this.__wbg_ptr);
          return Dr.__wrap(t);
        }
        members_to_remove() {
          const t = r.updatecommitteeaction_members_to_remove(this.__wbg_ptr);
          return tr.__wrap(t);
        }
        static new(t, e) {
          U(t, Dr), U(e, tr);
          const a = r.updatecommitteeaction_new(t.__wbg_ptr, e.__wbg_ptr);
          return Nr.__wrap(a);
        }
        static new_with_action_id(t, e, a) {
          U(t, ne), U(e, Dr), U(a, tr);
          const n = r.updatecommitteeaction_new_with_action_id(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr);
          return Nr.__wrap(n);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_vrfcert_free(d >>> 0));
      const Yi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_vrfkeyhash_free(d >>> 0));
      class Hr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Hr.prototype);
          return e.__wbg_ptr = t, Yi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Yi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_vrfkeyhash_free(t);
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.vrfkeyhash_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Hr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_bech32(t) {
          let e, a;
          try {
            const y = r.__wbindgen_add_to_stack_pointer(-16), R = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), j = B;
            r.anchordatahash_to_bech32(y, this.__wbg_ptr, R, j);
            var n = o()[y / 4 + 0], _ = o()[y / 4 + 1], c = o()[y / 4 + 2], s = o()[y / 4 + 3], p = n, l = _;
            if (s) throw p = 0, l = 0, w(c);
            return e = p, a = l, H(p, l);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(e, a, 1);
          }
        }
        static from_bech32(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.vrfkeyhash_from_bech32(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Hr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.anchordatahash_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.vrfkeyhash_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Hr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_vrfvkey_free(d >>> 0));
      const Xi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_value_free(d >>> 0));
      class Ee {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Ee.prototype);
          return e.__wbg_ptr = t, Xi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Xi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_value_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.value_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.value_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ee.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.value_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.value_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ee.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.value_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.value_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.value_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ee.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t) {
          U(t, it);
          const e = r.value_new(t.__wbg_ptr);
          return Ee.__wrap(e);
        }
        static new_from_assets(t) {
          U(t, Re);
          const e = r.value_new_from_assets(t.__wbg_ptr);
          return Ee.__wrap(e);
        }
        static new_with_assets(t, e) {
          U(t, it), U(e, Re);
          const a = r.value_new_with_assets(t.__wbg_ptr, e.__wbg_ptr);
          return Ee.__wrap(a);
        }
        static zero() {
          const t = r.value_zero();
          return Ee.__wrap(t);
        }
        is_zero() {
          return r.value_is_zero(this.__wbg_ptr) !== 0;
        }
        coin() {
          const t = r.value_coin(this.__wbg_ptr);
          return it.__wrap(t);
        }
        set_coin(t) {
          U(t, it), r.value_set_coin(this.__wbg_ptr, t.__wbg_ptr);
        }
        multiasset() {
          const t = r.value_multiasset(this.__wbg_ptr);
          return t === 0 ? void 0 : Re.__wrap(t);
        }
        set_multiasset(t) {
          U(t, Re), r.value_set_multiasset(this.__wbg_ptr, t.__wbg_ptr);
        }
        checked_add(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, Ee), r.value_checked_add(_, this.__wbg_ptr, t.__wbg_ptr);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ee.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        checked_sub(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            U(t, Ee), r.value_checked_sub(_, this.__wbg_ptr, t.__wbg_ptr);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Ee.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        clamped_sub(t) {
          U(t, Ee);
          const e = r.value_clamped_sub(this.__wbg_ptr, t.__wbg_ptr);
          return Ee.__wrap(e);
        }
        compare(t) {
          U(t, Ee);
          const e = r.value_compare(this.__wbg_ptr, t.__wbg_ptr);
          return e === 16777215 ? void 0 : e;
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_versionedblock_free(d >>> 0));
      const Ji = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_vkey_free(d >>> 0));
      class ur {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(ur.prototype);
          return e.__wbg_ptr = t, Ji.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ji.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_vkey_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.vkey_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.vkey_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ur.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.vkey_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.vkey_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ur.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.vkey_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.vkey_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.vkey_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return ur.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t) {
          U(t, qr);
          const e = r.vkey_new(t.__wbg_ptr);
          return ur.__wrap(e);
        }
        public_key() {
          const t = r.vkey_public_key(this.__wbg_ptr);
          return qr.__wrap(t);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_vkeys_free(d >>> 0));
      const Zi = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_vkeywitness_free(d >>> 0));
      class Mr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Mr.prototype);
          return e.__wbg_ptr = t, Zi.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Zi.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_vkeywitness_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.vkeywitness_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.vkeywitness_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Mr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.vkeywitness_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.vkeywitness_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Mr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.vkeywitness_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.vkeywitness_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.vkeywitness_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Mr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t, e) {
          U(t, ur), U(e, rr);
          const a = r.vkeywitness_new(t.__wbg_ptr, e.__wbg_ptr);
          return Mr.__wrap(a);
        }
        vkey() {
          const t = r.vkeywitness_vkey(this.__wbg_ptr);
          return ur.__wrap(t);
        }
        signature() {
          const t = r.vkeywitness_signature(this.__wbg_ptr);
          return rr.__wrap(t);
        }
      }
      const tc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_vkeywitnesses_free(d >>> 0));
      class M_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(M_.prototype);
          return e.__wbg_ptr = t, tc.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, tc.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_vkeywitnesses_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.vkeywitnesses_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.vkeywitnesses_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return M_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.vkeywitnesses_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.vkeywitnesses_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return M_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.vkeywitnesses_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.vkeywitnesses_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.vkeywitnesses_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return M_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.bootstrapwitnesses_new();
          return M_.__wrap(t);
        }
        len() {
          return r.bootstrapwitnesses_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.vkeywitnesses_get(this.__wbg_ptr, t);
          return Mr.__wrap(e);
        }
        add(t) {
          return U(t, Mr), r.vkeywitnesses_add(this.__wbg_ptr, t.__wbg_ptr) !== 0;
        }
      }
      const ec = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_votedelegation_free(d >>> 0));
      class K_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(K_.prototype);
          return e.__wbg_ptr = t, ec.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ec.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_votedelegation_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.votedelegation_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.votedelegation_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return K_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.votedelegation_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.votedelegation_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return K_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.votedelegation_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.votedelegation_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.votedelegation_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return K_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        stake_credential() {
          const t = r.committeehotauth_committee_cold_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        drep() {
          const t = r.stakeandvotedelegation_drep(this.__wbg_ptr);
          return se.__wrap(t);
        }
        static new(t, e) {
          U(t, xt), U(e, se);
          const a = r.votedelegation_new(t.__wbg_ptr, e.__wbg_ptr);
          return K_.__wrap(a);
        }
        has_script_credentials() {
          return r.committeehotauth_has_script_credentials(this.__wbg_ptr) !== 0;
        }
      }
      const rc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_voteregistrationanddelegation_free(d >>> 0));
      class q_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(q_.prototype);
          return e.__wbg_ptr = t, rc.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, rc.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_voteregistrationanddelegation_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.voteregistrationanddelegation_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.voteregistrationanddelegation_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return q_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.voteregistrationanddelegation_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.voteregistrationanddelegation_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return q_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.voteregistrationanddelegation_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.voteregistrationanddelegation_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.voteregistrationanddelegation_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return q_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        stake_credential() {
          const t = r.voteregistrationanddelegation_stake_credential(this.__wbg_ptr);
          return xt.__wrap(t);
        }
        drep() {
          const t = r.voteregistrationanddelegation_drep(this.__wbg_ptr);
          return se.__wrap(t);
        }
        coin() {
          const t = r.stakeregistrationanddelegation_coin(this.__wbg_ptr);
          return it.__wrap(t);
        }
        static new(t, e, a) {
          U(t, xt), U(e, se), U(a, it);
          const n = r.voteregistrationanddelegation_new(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr);
          return q_.__wrap(n);
        }
        has_script_credentials() {
          return r.voteregistrationanddelegation_has_script_credentials(this.__wbg_ptr) !== 0;
        }
      }
      const _c = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_voter_free(d >>> 0));
      class Pe {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Pe.prototype);
          return e.__wbg_ptr = t, _c.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, _c.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_voter_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.voter_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.voter_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Pe.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.voter_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.voter_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Pe.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.voter_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.voter_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.voter_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Pe.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new_constitutional_committee_hot_credential(t) {
          U(t, xt);
          const e = r.voter_new_constitutional_committee_hot_credential(t.__wbg_ptr);
          return Pe.__wrap(e);
        }
        static new_drep_credential(t) {
          U(t, xt);
          const e = r.voter_new_drep_credential(t.__wbg_ptr);
          return Pe.__wrap(e);
        }
        static new_stake_pool_key_hash(t) {
          U(t, Dt);
          const e = r.voter_new_stake_pool_key_hash(t.__wbg_ptr);
          return Pe.__wrap(e);
        }
        kind() {
          return r.voter_kind(this.__wbg_ptr);
        }
        to_constitutional_committee_hot_credential() {
          const t = r.voter_to_constitutional_committee_hot_credential(this.__wbg_ptr);
          return t === 0 ? void 0 : xt.__wrap(t);
        }
        to_drep_credential() {
          const t = r.voter_to_drep_credential(this.__wbg_ptr);
          return t === 0 ? void 0 : xt.__wrap(t);
        }
        to_stake_pool_key_hash() {
          const t = r.voter_to_stake_pool_key_hash(this.__wbg_ptr);
          return t === 0 ? void 0 : Dt.__wrap(t);
        }
        has_script_credentials() {
          return r.voter_has_script_credentials(this.__wbg_ptr) !== 0;
        }
        to_key_hash() {
          const t = r.voter_to_key_hash(this.__wbg_ptr);
          return t === 0 ? void 0 : Dt.__wrap(t);
        }
      }
      const nc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_voters_free(d >>> 0));
      class Rn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Rn.prototype);
          return e.__wbg_ptr = t, nc.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, nc.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_voters_free(t);
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.voters_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.voters_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.voters_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Rn.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.voters_new();
          return Rn.__wrap(t);
        }
        add(t) {
          U(t, Pe), r.voters_add(this.__wbg_ptr, t.__wbg_ptr);
        }
        get(t) {
          const e = r.voters_get(this.__wbg_ptr, t);
          return e === 0 ? void 0 : Pe.__wrap(e);
        }
        len() {
          return r.voters_len(this.__wbg_ptr) >>> 0;
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_votingbuilder_free(d >>> 0));
      const ac = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_votingprocedure_free(d >>> 0));
      class Lr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Lr.prototype);
          return e.__wbg_ptr = t, ac.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ac.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_votingprocedure_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingprocedure_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.votingprocedure_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Lr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingprocedure_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.votingprocedure_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Lr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingprocedure_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingprocedure_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.votingprocedure_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Lr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new(t) {
          const e = r.votingprocedure_new(t);
          return Lr.__wrap(e);
        }
        static new_with_anchor(t, e) {
          U(e, ie);
          const a = r.votingprocedure_new_with_anchor(t, e.__wbg_ptr);
          return Lr.__wrap(a);
        }
        vote_kind() {
          return r.votingprocedure_vote_kind(this.__wbg_ptr);
        }
        anchor() {
          const t = r.committeecoldresign_anchor(this.__wbg_ptr);
          return t === 0 ? void 0 : ie.__wrap(t);
        }
      }
      const oc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_votingprocedures_free(d >>> 0));
      class H_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(H_.prototype);
          return e.__wbg_ptr = t, oc.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, oc.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_votingprocedures_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingprocedures_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.votingprocedures_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return H_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingprocedures_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.votingprocedures_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return H_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingprocedures_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingprocedures_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.votingprocedures_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return H_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.treasurywithdrawals_new();
          return H_.__wrap(t);
        }
        insert(t, e, a) {
          U(t, Pe), U(e, ne), U(a, Lr), r.votingprocedures_insert(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr);
        }
        get(t, e) {
          U(t, Pe), U(e, ne);
          const a = r.votingprocedures_get(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
          return a === 0 ? void 0 : Lr.__wrap(a);
        }
        get_voters() {
          const t = r.votingprocedures_get_voters(this.__wbg_ptr);
          return Rn.__wrap(t);
        }
        get_governance_action_ids_by_voter(t) {
          U(t, Pe);
          const e = r.votingprocedures_get_governance_action_ids_by_voter(this.__wbg_ptr, t.__wbg_ptr);
          return In.__wrap(e);
        }
      }
      const sc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_votingproposal_free(d >>> 0));
      class Kr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Kr.prototype);
          return e.__wbg_ptr = t, sc.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, sc.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_votingproposal_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingproposal_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.votingproposal_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Kr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingproposal_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.votingproposal_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Kr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingproposal_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingproposal_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.votingproposal_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Kr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        governance_action() {
          const t = r.votingproposal_governance_action(this.__wbg_ptr);
          return Be.__wrap(t);
        }
        anchor() {
          const t = r.votingproposal_anchor(this.__wbg_ptr);
          return ie.__wrap(t);
        }
        reward_account() {
          const t = r.votingproposal_reward_account(this.__wbg_ptr);
          return Fe.__wrap(t);
        }
        deposit() {
          const t = r.votingproposal_deposit(this.__wbg_ptr);
          return it.__wrap(t);
        }
        static new(t, e, a, n) {
          U(t, Be), U(e, ie), U(a, Fe), U(n, it);
          const _ = r.votingproposal_new(t.__wbg_ptr, e.__wbg_ptr, a.__wbg_ptr, n.__wbg_ptr);
          return Kr.__wrap(_);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_votingproposalbuilder_free(d >>> 0));
      const ic = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_votingproposals_free(d >>> 0));
      class Fr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Fr.prototype);
          return e.__wbg_ptr = t, ic.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ic.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_votingproposals_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingproposals_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.votingproposals_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Fr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingproposals_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.votingproposals_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Fr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingproposals_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.votingproposals_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.votingproposals_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return Fr.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.certificates_new();
          return Fr.__wrap(t);
        }
        len() {
          return r.certificates_len(this.__wbg_ptr) >>> 0;
        }
        get(t) {
          const e = r.votingproposals_get(this.__wbg_ptr, t);
          return Kr.__wrap(e);
        }
        add(t) {
          return U(t, Kr), r.votingproposals_add(this.__wbg_ptr, t.__wbg_ptr) !== 0;
        }
        contains(t) {
          return U(t, Kr), r.votingproposals_contains(this.__wbg_ptr, t.__wbg_ptr) !== 0;
        }
        to_option() {
          const t = r.votingproposals_to_option(this.__wbg_ptr);
          return t === 0 ? void 0 : Fr.__wrap(t);
        }
      }
      const cc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((d) => r.__wbg_withdrawals_free(d >>> 0));
      class G_ {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(G_.prototype);
          return e.__wbg_ptr = t, cc.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, cc.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          r.__wbg_withdrawals_free(t);
        }
        to_bytes() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.withdrawals_to_bytes(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = nt(t, e).slice();
            return r.__wbindgen_free(t, e * 1, 1), a;
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_bytes(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = _t(t, r.__wbindgen_malloc), s = B;
            r.withdrawals_from_bytes(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return G_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_hex() {
          let t, e;
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16);
            r.withdrawals_to_hex(_, this.__wbg_ptr);
            var a = o()[_ / 4 + 0], n = o()[_ / 4 + 1];
            return t = a, e = n, H(a, n);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        static from_hex(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.withdrawals_from_hex(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return G_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        to_json() {
          let t, e;
          try {
            const l = r.__wbindgen_add_to_stack_pointer(-16);
            r.withdrawals_to_json(l, this.__wbg_ptr);
            var a = o()[l / 4 + 0], n = o()[l / 4 + 1], _ = o()[l / 4 + 2], c = o()[l / 4 + 3], s = a, p = n;
            if (c) throw s = 0, p = 0, w(_);
            return t = s, e = p, H(s, p);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16), r.__wbindgen_free(t, e, 1);
          }
        }
        to_js_value() {
          try {
            const n = r.__wbindgen_add_to_stack_pointer(-16);
            r.withdrawals_to_js_value(n, this.__wbg_ptr);
            var t = o()[n / 4 + 0], e = o()[n / 4 + 1], a = o()[n / 4 + 2];
            if (a) throw w(e);
            return w(t);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static from_json(t) {
          try {
            const _ = r.__wbindgen_add_to_stack_pointer(-16), c = q(t, r.__wbindgen_malloc, r.__wbindgen_realloc), s = B;
            r.withdrawals_from_json(_, c, s);
            var e = o()[_ / 4 + 0], a = o()[_ / 4 + 1], n = o()[_ / 4 + 2];
            if (n) throw w(a);
            return G_.__wrap(e);
          } finally {
            r.__wbindgen_add_to_stack_pointer(16);
          }
        }
        static new() {
          const t = r.auxiliarydataset_new();
          return G_.__wrap(t);
        }
        len() {
          return r.auxiliarydataset_len(this.__wbg_ptr) >>> 0;
        }
        insert(t, e) {
          U(t, Fe), U(e, it);
          const a = r.withdrawals_insert(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr);
          return a === 0 ? void 0 : it.__wrap(a);
        }
        get(t) {
          U(t, Fe);
          const e = r.withdrawals_get(this.__wbg_ptr, t.__wbg_ptr);
          return e === 0 ? void 0 : it.__wrap(e);
        }
        keys() {
          const t = r.withdrawals_keys(this.__wbg_ptr);
          return j_.__wrap(t);
        }
      }
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((d) => r.__wbg_withdrawalsbuilder_free(d >>> 0));
      function Il(d) {
        return Ot(d);
      }
      function Bl(d) {
        w(d);
      }
      function Rl(d, t) {
        const e = H(d, t);
        return Ot(e);
      }
      function Nl(d, t) {
        const e = It(t), a = typeof e == "string" ? e : void 0;
        var n = Gr(a) ? 0 : q(a, r.__wbindgen_malloc, r.__wbindgen_realloc), _ = B;
        o()[d / 4 + 1] = _, o()[d / 4 + 0] = n;
      }
      function Ll(d, t) {
        const e = new Error(H(d, t));
        return Ot(e);
      }
      function Fl(d) {
        const t = It(d);
        return Ot(t);
      }
      function Ol(d) {
        const t = It(d);
        return typeof t == "object" && t !== null;
      }
      function Ul(d, t) {
        const e = String(It(t)), a = q(e, r.__wbindgen_malloc, r.__wbindgen_realloc), n = B;
        o()[d / 4 + 1] = n, o()[d / 4 + 0] = a;
      }
      function zl(d, t, e) {
        It(d)[w(t)] = w(e);
      }
      function Dl(d) {
        const t = It(d).crypto;
        return Ot(t);
      }
      function Pl(d) {
        const t = It(d).process;
        return Ot(t);
      }
      function Vl(d) {
        const t = It(d).versions;
        return Ot(t);
      }
      function Ml(d) {
        const t = It(d).node;
        return Ot(t);
      }
      function Kl(d) {
        return typeof It(d) == "string";
      }
      function ql() {
        return Qr(function() {
          const d = module.require;
          return Ot(d);
        }, arguments);
      }
      function Hl(d) {
        const t = It(d).msCrypto;
        return Ot(t);
      }
      function Gl() {
        return Qr(function(d, t) {
          It(d).randomFillSync(w(t));
        }, arguments);
      }
      function Wl() {
        return Qr(function(d, t) {
          It(d).getRandomValues(It(t));
        }, arguments);
      }
      function Ql() {
        const d = new Array();
        return Ot(d);
      }
      function $l(d) {
        return typeof It(d) == "function";
      }
      function Yl(d, t) {
        const e = new Function(H(d, t));
        return Ot(e);
      }
      function Xl() {
        return Ot(/* @__PURE__ */ new Map());
      }
      function Jl() {
        return Qr(function(d, t) {
          const e = It(d).call(It(t));
          return Ot(e);
        }, arguments);
      }
      function Zl() {
        const d = new Object();
        return Ot(d);
      }
      function tp() {
        return Qr(function() {
          const d = self.self;
          return Ot(d);
        }, arguments);
      }
      function ep() {
        return Qr(function() {
          const d = window.window;
          return Ot(d);
        }, arguments);
      }
      function rp() {
        return Qr(function() {
          const d = globalThis.globalThis;
          return Ot(d);
        }, arguments);
      }
      function _p() {
        return Qr(function() {
          const d = globalThis.global;
          return Ot(d);
        }, arguments);
      }
      function np(d) {
        return It(d) === void 0;
      }
      function ap(d, t, e) {
        It(d)[t >>> 0] = w(e);
      }
      function op() {
        return Qr(function(d, t, e) {
          const a = It(d).call(It(t), It(e));
          return Ot(a);
        }, arguments);
      }
      function sp(d, t, e) {
        const a = It(d).set(It(t), It(e));
        return Ot(a);
      }
      function ip(d) {
        const t = It(d).buffer;
        return Ot(t);
      }
      function cp(d, t, e) {
        const a = new Uint8Array(It(d), t >>> 0, e >>> 0);
        return Ot(a);
      }
      function dp(d) {
        const t = new Uint8Array(It(d));
        return Ot(t);
      }
      function lp(d, t, e) {
        It(d).set(It(t), e >>> 0);
      }
      function pp(d) {
        const t = new Uint8Array(d >>> 0);
        return Ot(t);
      }
      function up(d, t, e) {
        const a = It(d).subarray(t >>> 0, e >>> 0);
        return Ot(a);
      }
      function fp(d, t) {
        const e = new Function(H(d, t));
        return Ot(e);
      }
      function gp(d, t) {
        const e = It(d).call(It(t));
        return Ot(e);
      }
      function wp(d, t) {
        return It(d) === It(t);
      }
      function hp(d) {
        const t = It(d).self;
        return Ot(t);
      }
      function bp(d, t) {
        const e = require(H(d, t));
        return Ot(e);
      }
      function yp(d) {
        const t = It(d).crypto;
        return Ot(t);
      }
      function vp(d) {
        const t = It(d).getRandomValues;
        return Ot(t);
      }
      function mp(d, t, e) {
        It(d).randomFillSync(nt(t, e));
      }
      function kp(d, t, e) {
        It(d).getRandomValues(nt(t, e));
      }
      function xp(d, t) {
        const e = io(It(t)), a = q(e, r.__wbindgen_malloc, r.__wbindgen_realloc), n = B;
        o()[d / 4 + 1] = n, o()[d / 4 + 0] = a;
      }
      function Ep(d, t) {
        throw new Error(H(d, t));
      }
      function Cp() {
        const d = r.memory;
        return Ot(d);
      }
      URL = globalThis.URL;
      const i = await El({
        "./cardano_serialization_lib_bg.js": {
          __wbindgen_number_new: Il,
          __wbindgen_object_drop_ref: Bl,
          __wbindgen_string_new: Rl,
          __wbindgen_string_get: Nl,
          __wbindgen_error_new: Ll,
          __wbindgen_object_clone_ref: Fl,
          __wbindgen_is_object: Ol,
          __wbg_String_91fba7ded13ba54c: Ul,
          __wbg_set_20cbc34131e76824: zl,
          __wbg_crypto_1d1f22824a6a080c: Dl,
          __wbg_process_4a72847cc503995b: Pl,
          __wbg_versions_f686565e586dd935: Vl,
          __wbg_node_104a2ff8d6ea03a2: Ml,
          __wbindgen_is_string: Kl,
          __wbg_require_cca90b1a94a0255b: ql,
          __wbg_msCrypto_eb05e62b530a1508: Hl,
          __wbg_randomFillSync_5c9c955aa56b6049: Gl,
          __wbg_getRandomValues_3aa56aa6edec874c: Wl,
          __wbg_new_16b304a2cfa7ff4a: Ql,
          __wbindgen_is_function: $l,
          __wbg_newnoargs_e258087cd0daa0ea: Yl,
          __wbg_new_d9bc3a0147634640: Xl,
          __wbg_call_27c0f87801dedf93: Jl,
          __wbg_new_72fb9a18b5ae2624: Zl,
          __wbg_self_ce0dbfc45cf2f5be: tp,
          __wbg_window_c6fb939a7f436783: ep,
          __wbg_globalThis_d1e6af4856ba331b: rp,
          __wbg_global_207b558942527489: _p,
          __wbindgen_is_undefined: np,
          __wbg_set_d4638f722068f043: ap,
          __wbg_call_b3ca7c6051f9bec1: op,
          __wbg_set_8417257aaedc936b: sp,
          __wbg_buffer_12d079cc21e14bdb: ip,
          __wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb: cp,
          __wbg_new_63b92bc8671ed464: dp,
          __wbg_set_a47bac70306a19a7: lp,
          __wbg_newwithlength_e9b4878cebadb3d3: pp,
          __wbg_subarray_a1f73cd4b5b42fe1: up,
          __wbg_new_d87f272aec784ec0: fp,
          __wbg_call_eae29933372a39be: gp,
          __wbindgen_jsval_eq: wp,
          __wbg_self_e0b3266d2d9eba1a: hp,
          __wbg_require_0993fe224bf8e202: bp,
          __wbg_crypto_e95a6e54c5c2e37f: yp,
          __wbg_getRandomValues_dc67302a7bd1aec5: vp,
          __wbg_randomFillSync_dd2297de5917c74e: mp,
          __wbg_getRandomValues_02639197c8166a96: kp,
          __wbindgen_debug_string: xp,
          __wbindgen_throw: Ep,
          __wbindgen_memory: Cp
        }
      }, xl), Sp = i.memory, Tp = i.__wbg_moveinstantaneousrewardscert_free, jp = i.moveinstantaneousrewardscert_to_bytes, Ap = i.moveinstantaneousrewardscert_from_bytes, Ip = i.moveinstantaneousrewardscert_to_hex, Bp = i.moveinstantaneousrewardscert_from_hex, Rp = i.moveinstantaneousrewardscert_to_json, Np = i.moveinstantaneousrewardscert_to_js_value, Lp = i.moveinstantaneousrewardscert_from_json, Fp = i.moveinstantaneousrewardscert_move_instantaneous_reward, Op = i.moveinstantaneousrewardscert_new, Up = i.__wbg_mirtostakecredentials_free, zp = i.mirtostakecredentials_to_bytes, Dp = i.mirtostakecredentials_from_bytes, Pp = i.mirtostakecredentials_to_hex, Vp = i.mirtostakecredentials_from_hex, Mp = i.mirtostakecredentials_to_json, Kp = i.mirtostakecredentials_to_js_value, qp = i.mirtostakecredentials_from_json, Hp = i.mirtostakecredentials_new, Gp = i.mirtostakecredentials_len, Wp = i.mirtostakecredentials_insert, Qp = i.mirtostakecredentials_get, $p = i.mirtostakecredentials_keys, Yp = i.__wbg_moveinstantaneousreward_free, Xp = i.moveinstantaneousreward_to_bytes, Jp = i.moveinstantaneousreward_from_bytes, Zp = i.moveinstantaneousreward_to_hex, tu = i.moveinstantaneousreward_from_hex, eu = i.moveinstantaneousreward_to_json, ru = i.moveinstantaneousreward_to_js_value, _u = i.moveinstantaneousreward_from_json, nu = i.moveinstantaneousreward_new_to_other_pot, au = i.moveinstantaneousreward_new_to_stake_creds, ou = i.moveinstantaneousreward_pot, su = i.moveinstantaneousreward_kind, iu = i.moveinstantaneousreward_as_to_other_pot, cu = i.moveinstantaneousreward_as_to_stake_creds, du = i.poolregistration_to_bytes, lu = i.poolregistration_from_bytes, pu = i.poolregistration_to_hex, uu = i.poolregistration_from_hex, fu = i.poolregistration_to_json, gu = i.poolregistration_to_js_value, wu = i.poolregistration_from_json, hu = i.poolregistration_pool_params, bu = i.poolregistration_new, yu = i.__wbg_relays_free, vu = i.relays_to_bytes, mu = i.relays_from_bytes, ku = i.relays_to_hex, xu = i.relays_from_hex, Eu = i.relays_to_json, Cu = i.relays_to_js_value, Su = i.relays_from_json, Tu = i.relays_new, ju = i.relays_len, Au = i.relays_get, Iu = i.relays_add, Bu = i.__wbg_poolparams_free, Ru = i.poolparams_to_bytes, Nu = i.poolparams_from_bytes, Lu = i.poolparams_to_hex, Fu = i.poolparams_from_hex, Ou = i.poolparams_to_json, Uu = i.poolparams_to_js_value, zu = i.poolparams_from_json, Du = i.poolparams_operator, Pu = i.poolparams_vrf_keyhash, Vu = i.poolparams_pledge, Mu = i.poolparams_cost, Ku = i.poolparams_margin, qu = i.poolparams_reward_account, Hu = i.poolparams_pool_owners, Gu = i.poolparams_relays, Wu = i.poolparams_pool_metadata, Qu = i.poolparams_new, $u = i.votedelegation_to_bytes, Yu = i.votedelegation_from_bytes, Xu = i.votedelegation_to_hex, Ju = i.votedelegation_from_hex, Zu = i.votedelegation_to_json, tf = i.votedelegation_to_js_value, ef = i.votedelegation_from_json, rf = i.votedelegation_new, _f = i.__wbg_stakeandvotedelegation_free, nf = i.stakeandvotedelegation_to_bytes, af = i.stakeandvotedelegation_from_bytes, of = i.stakeandvotedelegation_to_hex, sf = i.stakeandvotedelegation_from_hex, cf = i.stakeandvotedelegation_to_json, df = i.stakeandvotedelegation_to_js_value, lf = i.stakeandvotedelegation_from_json, pf = i.stakeandvotedelegation_pool_keyhash, uf = i.stakeandvotedelegation_drep, ff = i.stakeandvotedelegation_new, gf = i.__wbg_stakeregistrationanddelegation_free, wf = i.stakeregistrationanddelegation_to_bytes, hf = i.stakeregistrationanddelegation_from_bytes, bf = i.stakeregistrationanddelegation_to_hex, yf = i.stakeregistrationanddelegation_from_hex, vf = i.stakeregistrationanddelegation_to_json, mf = i.stakeregistrationanddelegation_to_js_value, kf = i.stakeregistrationanddelegation_from_json, xf = i.stakeregistrationanddelegation_stake_credential, Ef = i.stakeregistrationanddelegation_pool_keyhash, Cf = i.stakeregistrationanddelegation_coin, Sf = i.stakeregistrationanddelegation_new, Tf = i.stakeregistrationanddelegation_has_script_credentials, jf = i.__wbg_stakevoteregistrationanddelegation_free, Af = i.stakevoteregistrationanddelegation_to_bytes, If = i.stakevoteregistrationanddelegation_from_bytes, Bf = i.stakevoteregistrationanddelegation_to_hex, Rf = i.stakevoteregistrationanddelegation_from_hex, Nf = i.stakevoteregistrationanddelegation_to_json, Lf = i.stakevoteregistrationanddelegation_to_js_value, Ff = i.stakevoteregistrationanddelegation_from_json, Of = i.stakevoteregistrationanddelegation_stake_credential, Uf = i.stakevoteregistrationanddelegation_drep, zf = i.stakevoteregistrationanddelegation_new, Df = i.stakevoteregistrationanddelegation_has_script_credentials, Pf = i.voteregistrationanddelegation_to_bytes, Vf = i.voteregistrationanddelegation_from_bytes, Mf = i.voteregistrationanddelegation_to_hex, Kf = i.voteregistrationanddelegation_from_hex, qf = i.voteregistrationanddelegation_to_json, Hf = i.voteregistrationanddelegation_to_js_value, Gf = i.voteregistrationanddelegation_from_json, Wf = i.voteregistrationanddelegation_stake_credential, Qf = i.voteregistrationanddelegation_drep, $f = i.voteregistrationanddelegation_new, Yf = i.voteregistrationanddelegation_has_script_credentials, Xf = i.__wbg_committeehotauth_free, Jf = i.committeehotauth_to_bytes, Zf = i.committeehotauth_from_bytes, tg = i.committeehotauth_to_hex, eg = i.committeehotauth_from_hex, rg = i.committeehotauth_to_json, _g = i.committeehotauth_to_js_value, ng = i.committeehotauth_from_json, ag = i.committeehotauth_committee_cold_credential, og = i.committeehotauth_committee_hot_credential, sg = i.committeehotauth_new, ig = i.committeehotauth_has_script_credentials, cg = i.drep_to_bytes, dg = i.drep_from_bytes, lg = i.drep_to_hex, pg = i.drep_from_hex, ug = i.drep_to_json, fg = i.drep_to_js_value, gg = i.drep_from_json, wg = i.drep_new_key_hash, hg = i.drep_new_script_hash, bg = i.drep_new_always_abstain, yg = i.drep_new_always_no_confidence, vg = i.drep_new_from_credential, mg = i.drep_kind, kg = i.drep_to_key_hash, xg = i.drep_to_script_hash, Eg = i.drep_to_bech32, Cg = i.drep_from_bech32, Sg = i.__wbg_voter_free, Tg = i.voter_to_bytes, jg = i.voter_from_bytes, Ag = i.voter_to_hex, Ig = i.voter_from_hex, Bg = i.voter_to_json, Rg = i.voter_to_js_value, Ng = i.voter_from_json, Lg = i.voter_new_constitutional_committee_hot_credential, Fg = i.voter_new_drep_credential, Og = i.voter_new_stake_pool_key_hash, Ug = i.voter_kind, zg = i.voter_to_constitutional_committee_hot_credential, Dg = i.voter_to_drep_credential, Pg = i.voter_to_stake_pool_key_hash, Vg = i.voter_has_script_credentials, Mg = i.voter_to_key_hash, Kg = i.__wbg_language_free, qg = i.language_to_bytes, Hg = i.language_from_bytes, Gg = i.language_to_hex, Wg = i.language_from_hex, Qg = i.language_to_json, $g = i.language_to_js_value, Yg = i.language_from_json, Xg = i.language_new_plutus_v1, Jg = i.language_new_plutus_v2, Zg = i.language_new_plutus_v3, tw = i.language_kind, ew = i.__wbg_credential_free, rw = i.credential_from_keyhash, _w = i.credential_from_scripthash, nw = i.credential_to_keyhash, aw = i.credential_to_scripthash, ow = i.credential_kind, sw = i.credential_has_script_hash, iw = i.credential_to_bytes, cw = i.credential_from_bytes, dw = i.credential_to_hex, lw = i.credential_from_hex, pw = i.credential_to_json, uw = i.credential_to_js_value, fw = i.credential_from_json, gw = i.__wbg_vkeywitnesses_free, ww = i.vkeywitnesses_to_bytes, hw = i.vkeywitnesses_from_bytes, bw = i.vkeywitnesses_to_hex, yw = i.vkeywitnesses_from_hex, vw = i.vkeywitnesses_to_json, mw = i.vkeywitnesses_to_js_value, kw = i.vkeywitnesses_from_json, xw = i.vkeywitnesses_get, Ew = i.vkeywitnesses_add, Cw = i.__wbg_bootstrapwitnesses_free, Sw = i.bootstrapwitnesses_to_bytes, Tw = i.bootstrapwitnesses_from_bytes, jw = i.bootstrapwitnesses_to_hex, Aw = i.bootstrapwitnesses_from_hex, Iw = i.bootstrapwitnesses_to_json, Bw = i.bootstrapwitnesses_to_js_value, Rw = i.bootstrapwitnesses_from_json, Nw = i.bootstrapwitnesses_new, Lw = i.bootstrapwitnesses_len, Fw = i.bootstrapwitnesses_get, Ow = i.bootstrapwitnesses_add, Uw = i.__wbg_publickey_free, zw = i.publickey_from_hex, Dw = i.publickey_to_hex, Pw = i.publickey_hash, Vw = i.publickey_verify, Mw = i.publickey_from_bytes, Kw = i.publickey_as_bytes, qw = i.publickey_to_bech32, Hw = i.publickey_from_bech32, Gw = i.__wbg_poolregistration_free, Ww = i.__wbg_voteregistrationanddelegation_free, Qw = i.__wbg_votedelegation_free, $w = i.__wbg_drep_free, Yw = i.vkeywitnesses_new, Xw = i.votedelegation_drep, Jw = i.votedelegation_has_script_credentials, Zw = i.votedelegation_stake_credential, th = i.stakevoteregistrationanddelegation_coin, eh = i.stakevoteregistrationanddelegation_pool_keyhash, rh = i.voteregistrationanddelegation_coin, _h = i.stakeandvotedelegation_has_script_credentials, nh = i.stakeandvotedelegation_stake_credential, ah = i.vkeywitnesses_len, oh = i.__wbg_stakeregistration_free, sh = i.stakeregistration_to_bytes, ih = i.stakeregistration_from_bytes, ch = i.stakeregistration_to_hex, dh = i.stakeregistration_from_hex, lh = i.stakeregistration_to_json, ph = i.stakeregistration_to_js_value, uh = i.stakeregistration_from_json, fh = i.stakeregistration_stake_credential, gh = i.stakeregistration_coin, wh = i.stakeregistration_new, hh = i.stakeregistration_new_with_explicit_deposit, bh = i.stakeregistration_has_script_credentials, yh = i.__wbg_redeemertag_free, vh = i.redeemertag_to_bytes, mh = i.redeemertag_from_bytes, kh = i.redeemertag_to_hex, xh = i.redeemertag_from_hex, Eh = i.redeemertag_to_json, Ch = i.redeemertag_to_js_value, Sh = i.redeemertag_from_json, Th = i.redeemertag_new_spend, jh = i.redeemertag_new_mint, Ah = i.redeemertag_new_cert, Ih = i.redeemertag_new_reward, Bh = i.redeemertag_new_vote, Rh = i.redeemertag_new_voting_proposal, Nh = i.redeemertag_kind, Lh = i.__wbg_bip32publickey_free, Fh = i.__wbg_legacydaedalusprivatekey_free, Oh = i.legacydaedalusprivatekey_from_bytes, Uh = i.legacydaedalusprivatekey_as_bytes, zh = i.legacydaedalusprivatekey_chaincode, Dh = i.__wbg_nonce_free, Ph = i.nonce_to_bytes, Vh = i.nonce_from_bytes, Mh = i.nonce_to_hex, Kh = i.nonce_from_hex, qh = i.nonce_to_json, Hh = i.nonce_to_js_value, Gh = i.nonce_from_json, Wh = i.nonce_new_identity, Qh = i.nonce_new_from_hash, $h = i.nonce_get_hash, Yh = i.__wbg_unitinterval_free, Xh = i.unitinterval_to_bytes, Jh = i.unitinterval_from_bytes, Zh = i.unitinterval_to_hex, tb = i.unitinterval_from_hex, eb = i.unitinterval_to_json, rb = i.unitinterval_to_js_value, _b = i.unitinterval_from_json, nb = i.unitinterval_denominator, ab = i.unitinterval_new, ob = i.__wbg_transaction_free, sb = i.transaction_to_bytes, ib = i.transaction_from_bytes, cb = i.transaction_to_hex, db = i.transaction_from_hex, lb = i.transaction_to_json, pb = i.transaction_to_js_value, ub = i.transaction_from_json, fb = i.transaction_body, gb = i.transaction_witness_set, wb = i.transaction_is_valid, hb = i.transaction_auxiliary_data, bb = i.transaction_set_is_valid, yb = i.transaction_new, vb = i.__wbg_transactionoutputs_free, mb = i.transactionoutputs_to_bytes, kb = i.transactionoutputs_from_bytes, xb = i.transactionoutputs_to_hex, Eb = i.transactionoutputs_from_hex, Cb = i.transactionoutputs_to_json, Sb = i.transactionoutputs_to_js_value, Tb = i.transactionoutputs_from_json, jb = i.transactionoutputs_new, Ab = i.transactionoutputs_len, Ib = i.transactionoutputs_get, Bb = i.transactionoutputs_add, Rb = i.__wbg_datacost_free, Nb = i.datacost_new_coins_per_byte, Lb = i.datacost_coins_per_byte, Fb = i.__wbg_transactionoutput_free, Ob = i.transactionoutput_to_bytes, Ub = i.transactionoutput_from_bytes, zb = i.transactionoutput_to_hex, Db = i.transactionoutput_from_hex, Pb = i.transactionoutput_to_json, Vb = i.transactionoutput_to_js_value, Mb = i.transactionoutput_from_json, Kb = i.transactionoutput_address, qb = i.transactionoutput_amount, Hb = i.transactionoutput_data_hash, Gb = i.transactionoutput_plutus_data, Wb = i.transactionoutput_script_ref, Qb = i.transactionoutput_set_script_ref, $b = i.transactionoutput_set_plutus_data, Yb = i.transactionoutput_set_data_hash, Xb = i.transactionoutput_has_plutus_data, Jb = i.transactionoutput_has_data_hash, Zb = i.transactionoutput_has_script_ref, ty = i.transactionoutput_new, ey = i.transactionoutput_serialization_format, ry = i.__wbg_ipv4_free, _y = i.ipv4_to_bytes, ny = i.ipv4_from_bytes, ay = i.ipv4_to_hex, oy = i.ipv4_from_hex, sy = i.ipv4_to_json, iy = i.ipv4_to_js_value, cy = i.ipv4_from_json, dy = i.ipv4_new, ly = i.ipv4_ip, py = i.__wbg_ipv6_free, uy = i.ipv6_to_bytes, fy = i.ipv6_from_bytes, gy = i.ipv6_to_hex, wy = i.ipv6_from_hex, hy = i.ipv6_to_json, by = i.ipv6_to_js_value, yy = i.ipv6_from_json, vy = i.ipv6_new, my = i.ipv6_ip, ky = i.url_to_bytes, xy = i.url_from_bytes, Ey = i.url_to_hex, Cy = i.url_from_hex, Sy = i.url_from_json, Ty = i.url_new, jy = i.dnsrecordaoraaaa_to_bytes, Ay = i.dnsrecordaoraaaa_from_bytes, Iy = i.dnsrecordaoraaaa_to_hex, By = i.dnsrecordaoraaaa_from_hex, Ry = i.dnsrecordaoraaaa_to_json, Ny = i.dnsrecordaoraaaa_to_js_value, Ly = i.dnsrecordaoraaaa_from_json, Fy = i.dnsrecordaoraaaa_new, Oy = i.dnsrecordaoraaaa_record, Uy = i.dnsrecordsrv_to_bytes, zy = i.dnsrecordsrv_from_bytes, Dy = i.dnsrecordsrv_to_hex, Py = i.dnsrecordsrv_from_hex, Vy = i.dnsrecordsrv_from_json, My = i.dnsrecordsrv_new, Ky = i.__wbg_singlehostaddr_free, qy = i.singlehostaddr_to_bytes, Hy = i.singlehostaddr_from_bytes, Gy = i.singlehostaddr_to_hex, Wy = i.singlehostaddr_from_hex, Qy = i.singlehostaddr_to_json, $y = i.singlehostaddr_to_js_value, Yy = i.singlehostaddr_from_json, Xy = i.singlehostaddr_port, Jy = i.singlehostaddr_ipv4, Zy = i.singlehostaddr_ipv6, tv = i.singlehostaddr_new, ev = i.__wbg_singlehostname_free, rv = i.singlehostname_to_bytes, _v = i.singlehostname_from_bytes, nv = i.singlehostname_to_hex, av = i.singlehostname_from_hex, ov = i.singlehostname_to_json, sv = i.singlehostname_to_js_value, iv = i.singlehostname_from_json, cv = i.singlehostname_port, dv = i.singlehostname_new, lv = i.multihostname_to_bytes, pv = i.multihostname_from_bytes, uv = i.multihostname_to_hex, fv = i.multihostname_from_hex, gv = i.multihostname_to_json, wv = i.multihostname_to_js_value, hv = i.multihostname_from_json, bv = i.multihostname_dns_name, yv = i.__wbg_relay_free, vv = i.relay_to_bytes, mv = i.relay_from_bytes, kv = i.relay_to_hex, xv = i.relay_from_hex, Ev = i.relay_to_json, Cv = i.relay_to_js_value, Sv = i.relay_from_json, Tv = i.relay_new_single_host_addr, jv = i.relay_new_single_host_name, Av = i.relay_new_multi_host_name, Iv = i.relay_kind, Bv = i.relay_as_single_host_addr, Rv = i.relay_as_single_host_name, Nv = i.relay_as_multi_host_name, Lv = i.__wbg_poolmetadata_free, Fv = i.poolmetadata_to_bytes, Ov = i.poolmetadata_from_bytes, Uv = i.poolmetadata_to_hex, zv = i.poolmetadata_from_hex, Dv = i.poolmetadata_to_json, Pv = i.poolmetadata_to_js_value, Vv = i.poolmetadata_from_json, Mv = i.poolmetadata_pool_metadata_hash, Kv = i.poolmetadata_new, qv = i.__wbg_rewardaddresses_free, Hv = i.rewardaddresses_to_bytes, Gv = i.rewardaddresses_from_bytes, Wv = i.rewardaddresses_to_hex, Qv = i.rewardaddresses_from_hex, $v = i.rewardaddresses_to_json, Yv = i.rewardaddresses_to_js_value, Xv = i.rewardaddresses_from_json, Jv = i.rewardaddresses_len, Zv = i.rewardaddresses_get, tm = i.rewardaddresses_add, em = i.__wbg_withdrawals_free, rm = i.withdrawals_to_bytes, _m = i.withdrawals_from_bytes, nm = i.withdrawals_to_hex, am = i.withdrawals_from_hex, om = i.withdrawals_to_json, sm = i.withdrawals_to_js_value, im = i.withdrawals_from_json, cm = i.withdrawals_insert, dm = i.withdrawals_get, lm = i.withdrawals_keys, pm = i.__wbg_outputdatum_free, um = i.outputdatum_new_data_hash, fm = i.outputdatum_new_data, gm = i.outputdatum_data_hash, wm = i.outputdatum_data, hm = i.__wbg_update_free, bm = i.update_to_bytes, ym = i.update_from_bytes, vm = i.update_to_hex, mm = i.update_from_hex, km = i.update_to_json, xm = i.update_to_js_value, Em = i.update_from_json, Cm = i.update_proposed_protocol_parameter_updates, Sm = i.update_epoch, Tm = i.update_new, jm = i.__wbg_genesishashes_free, Am = i.genesishashes_to_bytes, Im = i.genesishashes_from_bytes, Bm = i.genesishashes_to_hex, Rm = i.genesishashes_from_hex, Nm = i.genesishashes_to_json, Lm = i.genesishashes_to_js_value, Fm = i.genesishashes_from_json, Om = i.genesishashes_new, Um = i.genesishashes_len, zm = i.genesishashes_get, Dm = i.genesishashes_add, Pm = i.scripthashes_to_bytes, Vm = i.scripthashes_from_bytes, Mm = i.scripthashes_to_hex, Km = i.scripthashes_from_hex, qm = i.scripthashes_to_json, Hm = i.scripthashes_to_js_value, Gm = i.scripthashes_from_json, Wm = i.scripthashes_get, Qm = i.scripthashes_add, $m = i.__wbg_proposedprotocolparameterupdates_free, Ym = i.proposedprotocolparameterupdates_to_bytes, Xm = i.proposedprotocolparameterupdates_from_bytes, Jm = i.proposedprotocolparameterupdates_to_hex, Zm = i.proposedprotocolparameterupdates_from_hex, t1 = i.proposedprotocolparameterupdates_to_json, e1 = i.proposedprotocolparameterupdates_to_js_value, r1 = i.proposedprotocolparameterupdates_from_json, _1 = i.proposedprotocolparameterupdates_insert, n1 = i.proposedprotocolparameterupdates_get, a1 = i.proposedprotocolparameterupdates_keys, o1 = i.__wbg_protocolversion_free, s1 = i.protocolversion_to_bytes, i1 = i.protocolversion_from_bytes, c1 = i.protocolversion_to_hex, d1 = i.protocolversion_from_hex, l1 = i.protocolversion_to_json, p1 = i.protocolversion_to_js_value, u1 = i.protocolversion_from_json, f1 = i.protocolversion_major, g1 = i.protocolversion_minor, w1 = i.protocolversion_new, h1 = i.__wbg_auxiliarydataset_free, b1 = i.auxiliarydataset_new, y1 = i.auxiliarydataset_len, v1 = i.auxiliarydataset_insert, m1 = i.auxiliarydataset_get, k1 = i.auxiliarydataset_indices, x1 = i.__wbg_assetname_free, E1 = i.assetname_to_bytes, C1 = i.assetname_from_bytes, S1 = i.assetname_to_hex, T1 = i.assetname_from_hex, j1 = i.assetname_to_json, A1 = i.assetname_to_js_value, I1 = i.assetname_from_json, B1 = i.assetname_new, R1 = i.assetname_name, N1 = i.__wbg_assetnames_free, L1 = i.assetnames_to_bytes, F1 = i.assetnames_from_bytes, O1 = i.assetnames_to_hex, U1 = i.assetnames_from_hex, z1 = i.assetnames_to_json, D1 = i.assetnames_to_js_value, P1 = i.assetnames_from_json, V1 = i.assetnames_new, M1 = i.assetnames_len, K1 = i.assetnames_get, q1 = i.assetnames_add, H1 = i.__wbg_assets_free, G1 = i.assets_to_bytes, W1 = i.assets_from_bytes, Q1 = i.assets_to_hex, $1 = i.assets_from_hex, Y1 = i.assets_to_json, X1 = i.assets_to_js_value, J1 = i.assets_from_json, Z1 = i.assets_new, t0 = i.assets_len, e0 = i.assets_insert, r0 = i.assets_get, _0 = i.assets_keys, n0 = i.__wbg_multiasset_free, a0 = i.multiasset_to_bytes, o0 = i.multiasset_from_bytes, s0 = i.multiasset_to_hex, i0 = i.multiasset_from_hex, c0 = i.multiasset_to_json, d0 = i.multiasset_to_js_value, l0 = i.multiasset_from_json, p0 = i.multiasset_insert, u0 = i.multiasset_get, f0 = i.multiasset_set_asset, g0 = i.multiasset_get_asset, w0 = i.multiasset_keys, h0 = i.multiasset_sub, b0 = i.__wbg_mintsassets_free, y0 = i.mintsassets_to_json, v0 = i.mintsassets_to_js_value, m0 = i.mintsassets_from_json, k0 = i.mintsassets_add, x0 = i.mintsassets_get, E0 = i.__wbg_mintassets_free, C0 = i.mintassets_new_from_entry, S0 = i.mintassets_insert, T0 = i.mintassets_get, j0 = i.mintassets_keys, A0 = i.__wbg_mint_free, I0 = i.mint_to_bytes, B0 = i.mint_from_bytes, R0 = i.mint_to_hex, N0 = i.mint_from_hex, L0 = i.mint_to_json, F0 = i.mint_to_js_value, O0 = i.mint_from_json, U0 = i.mint_new_from_entry, z0 = i.mint_len, D0 = i.mint_insert, P0 = i.mint_get, V0 = i.mint_keys, M0 = i.mint_as_positive_multiasset, K0 = i.mint_as_negative_multiasset, q0 = i.__wbg_networkid_free, H0 = i.networkid_to_bytes, G0 = i.networkid_from_bytes, W0 = i.networkid_to_hex, Q0 = i.networkid_from_hex, $0 = i.networkid_to_json, Y0 = i.networkid_to_js_value, X0 = i.networkid_from_json, J0 = i.networkid_testnet, Z0 = i.networkid_mainnet, t4 = i.networkid_kind, e4 = i.bip32publickey_from_hex, r4 = i.bip32publickey_to_hex, _4 = i.bip32publickey_chaincode, n4 = i.bip32publickey_to_bech32, a4 = i.bip32publickey_from_bech32, o4 = i.bip32publickey_as_bytes, s4 = i.bip32publickey_from_bytes, i4 = i.bip32publickey_to_raw_key, c4 = i.bip32publickey_derive, d4 = i.__wbg_url_free, l4 = i.__wbg_dnsrecordsrv_free, p4 = i.__wbg_multihostname_free, u4 = i.__wbg_dnsrecordaoraaaa_free, f4 = i.unitinterval_numerator, g4 = i.withdrawals_len, w4 = i.proposedprotocolparameterupdates_len, h4 = i.multiasset_len, b4 = i.mintassets_len, y4 = i.scripthashes_len, v4 = i.mintsassets_len, m4 = i.url_to_json, k4 = i.dnsrecordsrv_to_json, x4 = i.url_url, E4 = i.dnsrecordsrv_record, C4 = i.multiasset_new, S4 = i.mintassets_new, T4 = i.withdrawals_new, j4 = i.proposedprotocolparameterupdates_new, A4 = i.url_to_js_value, I4 = i.dnsrecordsrv_to_js_value, B4 = i.__wbg_scripthashes_free, R4 = i.singlehostname_dns_name, N4 = i.poolmetadata_url, L4 = i.rewardaddresses_new, F4 = i.scripthashes_new, O4 = i.multihostname_new, U4 = i.mintsassets_new, z4 = i.mint_new, D4 = i.__wbg_linearfee_free, P4 = i.linearfee_constant, V4 = i.linearfee_coefficient, M4 = i.linearfee_new, K4 = i.min_fee, q4 = i.calculate_ex_units_ceil_cost, H4 = i.min_script_fee, G4 = i.min_ref_script_fee, W4 = i.__wbg_languages_free, Q4 = i.languages_new, $4 = i.languages_len, Y4 = i.languages_get, X4 = i.languages_add, J4 = i.languages_list, Z4 = i.__wbg_exunitprices_free, tk = i.exunitprices_to_bytes, ek = i.exunitprices_from_bytes, rk = i.exunitprices_to_hex, _k = i.exunitprices_from_hex, nk = i.exunitprices_to_json, ak = i.exunitprices_to_js_value, ok = i.exunitprices_from_json, sk = i.exunitprices_new, ik = i.__wbg_redeemer_free, ck = i.redeemer_to_bytes, dk = i.redeemer_from_bytes, lk = i.redeemer_to_hex, pk = i.redeemer_from_hex, uk = i.redeemer_to_json, fk = i.redeemer_to_js_value, gk = i.redeemer_from_json, wk = i.redeemer_tag, hk = i.redeemer_index, bk = i.redeemer_data, yk = i.redeemer_ex_units, vk = i.redeemer_new, mk = i.__wbg_redeemers_free, kk = i.redeemers_to_bytes, xk = i.redeemers_from_bytes, Ek = i.redeemers_to_hex, Ck = i.redeemers_from_hex, Sk = i.redeemers_to_json, Tk = i.redeemers_to_js_value, jk = i.redeemers_from_json, Ak = i.redeemers_new, Ik = i.redeemers_len, Bk = i.redeemers_get, Rk = i.redeemers_add, Nk = i.redeemers_get_container_type, Lk = i.redeemers_total_ex_units, Fk = i.__wbg_constrplutusdata_free, Ok = i.constrplutusdata_to_bytes, Uk = i.constrplutusdata_from_bytes, zk = i.constrplutusdata_to_hex, Dk = i.constrplutusdata_from_hex, Pk = i.constrplutusdata_alternative, Vk = i.constrplutusdata_data, Mk = i.constrplutusdata_new, Kk = i.__wbg_plutusmapvalues_free, qk = i.plutusmapvalues_new, Hk = i.plutusmapvalues_get, Gk = i.plutusmapvalues_add, Wk = i.__wbg_plutusmap_free, Qk = i.plutusmap_to_bytes, $k = i.plutusmap_from_bytes, Yk = i.plutusmap_to_hex, Xk = i.plutusmap_from_hex, Jk = i.plutusmap_insert, Zk = i.plutusmap_get, t2 = i.plutusmap_keys, e2 = i.__wbg_plutusdata_free, r2 = i.plutusdata_to_bytes, _2 = i.plutusdata_from_bytes, n2 = i.plutusdata_to_hex, a2 = i.plutusdata_from_hex, o2 = i.plutusdata_new_constr_plutus_data, s2 = i.plutusdata_new_empty_constr_plutus_data, i2 = i.plutusdata_new_single_value_constr_plutus_data, c2 = i.plutusdata_new_map, d2 = i.plutusdata_new_list, l2 = i.plutusdata_new_integer, p2 = i.plutusdata_new_bytes, u2 = i.plutusdata_kind, f2 = i.plutusdata_as_constr_plutus_data, g2 = i.plutusdata_as_map, w2 = i.plutusdata_as_list, h2 = i.plutusdata_as_integer, b2 = i.plutusdata_as_bytes, y2 = i.plutusdata_from_address, v2 = i.plutusdata_as_address, m2 = i.__wbg_plutuslist_free, k2 = i.plutuslist_to_bytes, x2 = i.plutuslist_from_bytes, E2 = i.plutuslist_to_hex, C2 = i.plutuslist_from_hex, S2 = i.plutuslist_new, T2 = i.plutuslist_len, j2 = i.plutuslist_get, A2 = i.plutuslist_add, I2 = i.encode_json_str_to_plutus_datum, B2 = i.decode_plutus_datum_to_json_str, R2 = i.__wbg_metadatamap_free, N2 = i.metadatamap_to_bytes, L2 = i.metadatamap_from_bytes, F2 = i.metadatamap_to_hex, O2 = i.metadatamap_from_hex, U2 = i.metadatamap_insert, z2 = i.metadatamap_insert_str, D2 = i.metadatamap_insert_i32, P2 = i.metadatamap_get, V2 = i.metadatamap_get_str, M2 = i.metadatamap_get_i32, K2 = i.metadatamap_has, q2 = i.metadatamap_keys, H2 = i.__wbg_metadatalist_free, G2 = i.metadatalist_to_bytes, W2 = i.metadatalist_from_bytes, Q2 = i.metadatalist_to_hex, $2 = i.metadatalist_from_hex, Y2 = i.metadatalist_new, X2 = i.metadatalist_len, J2 = i.metadatalist_get, Z2 = i.metadatalist_add, t6 = i.__wbg_transactionmetadatum_free, e6 = i.transactionmetadatum_to_bytes, r6 = i.transactionmetadatum_from_bytes, _6 = i.transactionmetadatum_to_hex, n6 = i.transactionmetadatum_from_hex, a6 = i.transactionmetadatum_new_map, o6 = i.transactionmetadatum_new_list, s6 = i.transactionmetadatum_new_int, i6 = i.transactionmetadatum_new_bytes, c6 = i.transactionmetadatum_new_text, d6 = i.transactionmetadatum_kind, l6 = i.transactionmetadatum_as_map, p6 = i.transactionmetadatum_as_list, u6 = i.transactionmetadatum_as_int, f6 = i.transactionmetadatum_as_bytes, g6 = i.transactionmetadatum_as_text, w6 = i.__wbg_transactionmetadatumlabels_free, h6 = i.transactionmetadatumlabels_to_bytes, b6 = i.transactionmetadatumlabels_from_bytes, y6 = i.transactionmetadatumlabels_to_hex, v6 = i.transactionmetadatumlabels_from_hex, m6 = i.transactionmetadatumlabels_len, k6 = i.transactionmetadatumlabels_get, x6 = i.transactionmetadatumlabels_add, E6 = i.__wbg_generaltransactionmetadata_free, C6 = i.generaltransactionmetadata_to_bytes, S6 = i.generaltransactionmetadata_from_bytes, T6 = i.generaltransactionmetadata_to_hex, j6 = i.generaltransactionmetadata_from_hex, A6 = i.generaltransactionmetadata_to_json, I6 = i.generaltransactionmetadata_to_js_value, B6 = i.generaltransactionmetadata_from_json, R6 = i.generaltransactionmetadata_new, N6 = i.generaltransactionmetadata_len, L6 = i.generaltransactionmetadata_insert, F6 = i.generaltransactionmetadata_get, O6 = i.generaltransactionmetadata_keys, U6 = i.__wbg_auxiliarydata_free, z6 = i.auxiliarydata_to_bytes, D6 = i.auxiliarydata_from_bytes, P6 = i.auxiliarydata_to_hex, V6 = i.auxiliarydata_from_hex, M6 = i.auxiliarydata_to_json, K6 = i.auxiliarydata_to_js_value, q6 = i.auxiliarydata_from_json, H6 = i.auxiliarydata_new, G6 = i.auxiliarydata_metadata, W6 = i.auxiliarydata_set_metadata, Q6 = i.auxiliarydata_native_scripts, $6 = i.auxiliarydata_set_native_scripts, Y6 = i.auxiliarydata_plutus_scripts, X6 = i.auxiliarydata_set_plutus_scripts, J6 = i.auxiliarydata_prefer_alonzo_format, Z6 = i.auxiliarydata_set_prefer_alonzo_format, tx = i.encode_arbitrary_bytes_as_metadatum, ex = i.decode_arbitrary_bytes_from_metadatum, rx = i.encode_json_str_to_metadatum, _x = i.decode_metadatum_to_json_str, nx = i.__wbg_poolvotingthresholds_free, ax = i.poolvotingthresholds_to_bytes, ox = i.poolvotingthresholds_from_bytes, sx = i.poolvotingthresholds_to_hex, ix = i.poolvotingthresholds_from_hex, cx = i.poolvotingthresholds_to_json, dx = i.poolvotingthresholds_to_js_value, lx = i.poolvotingthresholds_from_json, px = i.poolvotingthresholds_new, ux = i.__wbg_drepvotingthresholds_free, fx = i.drepvotingthresholds_to_bytes, gx = i.drepvotingthresholds_from_bytes, wx = i.drepvotingthresholds_to_hex, hx = i.drepvotingthresholds_from_hex, bx = i.drepvotingthresholds_to_json, yx = i.drepvotingthresholds_to_js_value, vx = i.drepvotingthresholds_from_json, mx = i.drepvotingthresholds_new, kx = i.drepvotingthresholds_set_motion_no_confidence, xx = i.drepvotingthresholds_set_committee_normal, Ex = i.drepvotingthresholds_set_committee_no_confidence, Cx = i.drepvotingthresholds_set_update_constitution, Sx = i.drepvotingthresholds_set_hard_fork_initiation, Tx = i.drepvotingthresholds_set_pp_network_group, jx = i.drepvotingthresholds_set_pp_economic_group, Ax = i.drepvotingthresholds_set_pp_technical_group, Ix = i.drepvotingthresholds_set_pp_governance_group, Bx = i.drepvotingthresholds_set_treasury_withdrawal, Rx = i.drepvotingthresholds_motion_no_confidence, Nx = i.drepvotingthresholds_committee_normal, Lx = i.drepvotingthresholds_committee_no_confidence, Fx = i.drepvotingthresholds_update_constitution, Ox = i.drepvotingthresholds_hard_fork_initiation, Ux = i.drepvotingthresholds_pp_network_group, zx = i.drepvotingthresholds_pp_economic_group, Dx = i.drepvotingthresholds_pp_technical_group, Px = i.drepvotingthresholds_pp_governance_group, Vx = i.drepvotingthresholds_treasury_withdrawal, Mx = i.__wbg_protocolparamupdate_free, Kx = i.protocolparamupdate_to_bytes, qx = i.protocolparamupdate_from_bytes, Hx = i.protocolparamupdate_to_hex, Gx = i.protocolparamupdate_from_hex, Wx = i.protocolparamupdate_to_json, Qx = i.protocolparamupdate_to_js_value, $x = i.protocolparamupdate_from_json, Yx = i.protocolparamupdate_set_minfee_a, Xx = i.protocolparamupdate_minfee_a, Jx = i.protocolparamupdate_set_minfee_b, Zx = i.protocolparamupdate_minfee_b, t3 = i.protocolparamupdate_set_max_block_body_size, e3 = i.protocolparamupdate_max_block_body_size, r3 = i.protocolparamupdate_set_max_tx_size, _3 = i.protocolparamupdate_max_tx_size, n3 = i.protocolparamupdate_set_max_block_header_size, a3 = i.protocolparamupdate_max_block_header_size, o3 = i.protocolparamupdate_set_key_deposit, s3 = i.protocolparamupdate_key_deposit, i3 = i.protocolparamupdate_set_pool_deposit, c3 = i.protocolparamupdate_pool_deposit, d3 = i.protocolparamupdate_set_max_epoch, l3 = i.protocolparamupdate_max_epoch, p3 = i.protocolparamupdate_set_n_opt, u3 = i.protocolparamupdate_n_opt, f3 = i.protocolparamupdate_set_pool_pledge_influence, g3 = i.protocolparamupdate_pool_pledge_influence, w3 = i.protocolparamupdate_set_expansion_rate, h3 = i.protocolparamupdate_expansion_rate, b3 = i.protocolparamupdate_set_treasury_growth_rate, y3 = i.protocolparamupdate_treasury_growth_rate, v3 = i.protocolparamupdate_d, m3 = i.protocolparamupdate_extra_entropy, k3 = i.protocolparamupdate_set_protocol_version, x3 = i.protocolparamupdate_protocol_version, E3 = i.protocolparamupdate_set_min_pool_cost, C3 = i.protocolparamupdate_min_pool_cost, S3 = i.protocolparamupdate_set_ada_per_utxo_byte, T3 = i.protocolparamupdate_ada_per_utxo_byte, j3 = i.protocolparamupdate_set_cost_models, A3 = i.protocolparamupdate_cost_models, I3 = i.protocolparamupdate_set_execution_costs, B3 = i.protocolparamupdate_execution_costs, R3 = i.protocolparamupdate_set_max_tx_ex_units, N3 = i.protocolparamupdate_max_tx_ex_units, L3 = i.protocolparamupdate_set_max_block_ex_units, F3 = i.protocolparamupdate_max_block_ex_units, O3 = i.protocolparamupdate_set_max_value_size, U3 = i.protocolparamupdate_max_value_size, z3 = i.protocolparamupdate_set_collateral_percentage, D3 = i.protocolparamupdate_collateral_percentage, P3 = i.protocolparamupdate_set_max_collateral_inputs, V3 = i.protocolparamupdate_max_collateral_inputs, M3 = i.protocolparamupdate_set_pool_voting_thresholds, K3 = i.protocolparamupdate_pool_voting_thresholds, q3 = i.protocolparamupdate_set_drep_voting_thresholds, H3 = i.protocolparamupdate_drep_voting_thresholds, G3 = i.protocolparamupdate_set_min_committee_size, W3 = i.protocolparamupdate_min_committee_size, Q3 = i.protocolparamupdate_set_committee_term_limit, $3 = i.protocolparamupdate_committee_term_limit, Y3 = i.protocolparamupdate_set_governance_action_validity_period, X3 = i.protocolparamupdate_governance_action_validity_period, J3 = i.protocolparamupdate_set_governance_action_deposit, Z3 = i.protocolparamupdate_governance_action_deposit, tE = i.protocolparamupdate_set_drep_deposit, eE = i.protocolparamupdate_drep_deposit, rE = i.protocolparamupdate_set_drep_inactivity_period, _E = i.protocolparamupdate_drep_inactivity_period, nE = i.protocolparamupdate_set_ref_script_coins_per_byte, aE = i.protocolparamupdate_ref_script_coins_per_byte, oE = i.protocolparamupdate_new, sE = i.__wbg_bootstrapwitness_free, iE = i.bootstrapwitness_to_bytes, cE = i.bootstrapwitness_from_bytes, dE = i.bootstrapwitness_to_hex, lE = i.bootstrapwitness_from_hex, pE = i.bootstrapwitness_to_json, uE = i.bootstrapwitness_to_js_value, fE = i.bootstrapwitness_from_json, gE = i.bootstrapwitness_vkey, wE = i.bootstrapwitness_signature, hE = i.bootstrapwitness_chain_code, bE = i.bootstrapwitness_attributes, yE = i.bootstrapwitness_new, vE = i.__wbg_ed25519signature_free, mE = i.ed25519signature_to_bytes, kE = i.ed25519signature_to_bech32, xE = i.ed25519signature_to_hex, EE = i.ed25519signature_from_bech32, CE = i.ed25519signature_from_hex, SE = i.ed25519signature_from_bytes, TE = i.__wbg_vkey_free, jE = i.vkey_to_bytes, AE = i.vkey_from_bytes, IE = i.vkey_to_hex, BE = i.vkey_from_hex, RE = i.vkey_to_json, NE = i.vkey_to_js_value, LE = i.vkey_from_json, FE = i.vkey_new, OE = i.vkey_public_key, UE = i.__wbg_operationalcert_free, zE = i.operationalcert_to_bytes, DE = i.operationalcert_from_bytes, PE = i.operationalcert_to_hex, VE = i.operationalcert_from_hex, ME = i.operationalcert_to_json, KE = i.operationalcert_to_js_value, qE = i.operationalcert_from_json, HE = i.operationalcert_hot_vkey, GE = i.operationalcert_sequence_number, WE = i.operationalcert_kes_period, QE = i.operationalcert_sigma, $E = i.operationalcert_new, YE = i.__wbg_fixedversionedblock_free, XE = i.fixedversionedblock_from_bytes, JE = i.fixedversionedblock_from_hex, ZE = i.fixedversionedblock_block, tC = i.fixedversionedblock_era, eC = i.__wbg_versionedblock_free, rC = i.versionedblock_to_bytes, _C = i.versionedblock_from_bytes, nC = i.versionedblock_to_hex, aC = i.versionedblock_from_hex, oC = i.versionedblock_to_json, sC = i.versionedblock_to_js_value, iC = i.versionedblock_from_json, cC = i.versionedblock_new, dC = i.versionedblock_block, lC = i.versionedblock_era, pC = i.poolvotingthresholds_motion_no_confidence, uC = i.poolvotingthresholds_committee_normal, fC = i.exunitprices_mem_price, gC = i.exunitprices_step_price, wC = i.poolvotingthresholds_committee_no_confidence, hC = i.poolvotingthresholds_hard_fork_initiation, bC = i.poolvotingthresholds_security_relevant_threshold, yC = i.plutusmap_len, vC = i.metadatamap_len, mC = i.plutusmapvalues_len, kC = i.plutusdata_to_json, xC = i.plutusdata_from_json, EC = i.plutusmap_new, CC = i.metadatamap_new, SC = i.transactionmetadatumlabels_new, TC = i.__wbg_anchor_free, jC = i.anchor_to_bytes, AC = i.anchor_from_bytes, IC = i.anchor_to_hex, BC = i.anchor_from_hex, RC = i.anchor_to_json, NC = i.anchor_to_js_value, LC = i.anchor_from_json, FC = i.anchor_url, OC = i.anchor_anchor_data_hash, UC = i.anchor_new, zC = i.__wbg_governanceactionid_free, DC = i.governanceactionid_to_bytes, PC = i.governanceactionid_from_bytes, VC = i.governanceactionid_to_hex, MC = i.governanceactionid_from_hex, KC = i.governanceactionid_to_json, qC = i.governanceactionid_to_js_value, HC = i.governanceactionid_from_json, GC = i.governanceactionid_transaction_id, WC = i.governanceactionid_index, QC = i.governanceactionid_new, $C = i.__wbg_parameterchangeaction_free, YC = i.parameterchangeaction_to_bytes, XC = i.parameterchangeaction_from_bytes, JC = i.parameterchangeaction_to_hex, ZC = i.parameterchangeaction_from_hex, t5 = i.parameterchangeaction_to_json, e5 = i.parameterchangeaction_to_js_value, r5 = i.parameterchangeaction_from_json, _5 = i.parameterchangeaction_gov_action_id, n5 = i.parameterchangeaction_protocol_param_updates, a5 = i.parameterchangeaction_policy_hash, o5 = i.parameterchangeaction_new, s5 = i.parameterchangeaction_new_with_action_id, i5 = i.parameterchangeaction_new_with_policy_hash, c5 = i.parameterchangeaction_new_with_policy_hash_and_action_id, d5 = i.__wbg_hardforkinitiationaction_free, l5 = i.hardforkinitiationaction_to_bytes, p5 = i.hardforkinitiationaction_from_bytes, u5 = i.hardforkinitiationaction_to_hex, f5 = i.hardforkinitiationaction_from_hex, g5 = i.hardforkinitiationaction_to_json, w5 = i.hardforkinitiationaction_to_js_value, h5 = i.hardforkinitiationaction_from_json, b5 = i.hardforkinitiationaction_gov_action_id, y5 = i.hardforkinitiationaction_protocol_version, v5 = i.hardforkinitiationaction_new, m5 = i.hardforkinitiationaction_new_with_action_id, k5 = i.__wbg_treasurywithdrawalsaction_free, x5 = i.treasurywithdrawalsaction_to_bytes, E5 = i.treasurywithdrawalsaction_from_bytes, C5 = i.treasurywithdrawalsaction_to_hex, S5 = i.treasurywithdrawalsaction_from_hex, T5 = i.treasurywithdrawalsaction_to_json, j5 = i.treasurywithdrawalsaction_to_js_value, A5 = i.treasurywithdrawalsaction_from_json, I5 = i.treasurywithdrawalsaction_withdrawals, B5 = i.treasurywithdrawalsaction_policy_hash, R5 = i.treasurywithdrawalsaction_new, N5 = i.treasurywithdrawalsaction_new_with_policy_hash, L5 = i.__wbg_updatecommitteeaction_free, F5 = i.updatecommitteeaction_to_bytes, O5 = i.updatecommitteeaction_from_bytes, U5 = i.updatecommitteeaction_to_hex, z5 = i.updatecommitteeaction_from_hex, D5 = i.updatecommitteeaction_to_json, P5 = i.updatecommitteeaction_to_js_value, V5 = i.updatecommitteeaction_from_json, M5 = i.updatecommitteeaction_gov_action_id, K5 = i.updatecommitteeaction_committee, q5 = i.updatecommitteeaction_members_to_remove, H5 = i.updatecommitteeaction_new, G5 = i.updatecommitteeaction_new_with_action_id, W5 = i.__wbg_constitution_free, Q5 = i.constitution_to_bytes, $5 = i.constitution_from_bytes, Y5 = i.constitution_to_hex, X5 = i.constitution_from_hex, J5 = i.constitution_to_json, Z5 = i.constitution_to_js_value, tS = i.constitution_from_json, eS = i.constitution_anchor, rS = i.constitution_script_hash, _S = i.constitution_new, nS = i.constitution_new_with_script_hash, aS = i.__wbg_newconstitutionaction_free, oS = i.newconstitutionaction_to_bytes, sS = i.newconstitutionaction_from_bytes, iS = i.newconstitutionaction_to_hex, cS = i.newconstitutionaction_from_hex, dS = i.newconstitutionaction_to_json, lS = i.newconstitutionaction_to_js_value, pS = i.newconstitutionaction_from_json, uS = i.newconstitutionaction_constitution, fS = i.newconstitutionaction_new, gS = i.newconstitutionaction_new_with_action_id, wS = i.newconstitutionaction_has_script_hash, hS = i.__wbg_votingproposal_free, bS = i.votingproposal_to_bytes, yS = i.votingproposal_from_bytes, vS = i.votingproposal_to_hex, mS = i.votingproposal_from_hex, kS = i.votingproposal_to_json, xS = i.votingproposal_to_js_value, ES = i.votingproposal_from_json, CS = i.votingproposal_governance_action, SS = i.votingproposal_anchor, TS = i.votingproposal_reward_account, jS = i.votingproposal_deposit, AS = i.votingproposal_new, IS = i.transactioninput_to_bytes, BS = i.transactioninput_from_bytes, RS = i.transactioninput_to_hex, NS = i.transactioninput_from_hex, LS = i.transactioninput_to_json, FS = i.transactioninput_to_js_value, OS = i.transactioninput_from_json, US = i.__wbg_block_free, zS = i.block_to_bytes, DS = i.block_from_bytes, PS = i.block_to_hex, VS = i.block_from_hex, MS = i.block_to_json, KS = i.block_to_js_value, qS = i.block_from_json, HS = i.block_header, GS = i.block_transaction_bodies, WS = i.block_transaction_witness_sets, QS = i.block_auxiliary_data_set, $S = i.block_invalid_transactions, YS = i.block_new, XS = i.__wbg_fixedblock_free, JS = i.fixedblock_from_bytes, ZS = i.fixedblock_from_hex, tT = i.fixedblock_header, eT = i.fixedblock_transaction_bodies, rT = i.fixedblock_transaction_witness_sets, _T = i.fixedblock_auxiliary_data_set, nT = i.fixedblock_invalid_transactions, aT = i.fixedblock_block_hash, oT = i.__wbg_header_free, sT = i.header_to_bytes, iT = i.header_from_bytes, cT = i.header_to_hex, dT = i.header_from_hex, lT = i.header_to_json, pT = i.header_to_js_value, uT = i.header_from_json, fT = i.header_header_body, gT = i.header_body_signature, wT = i.header_new, hT = i.__wbg_transactionunspentoutput_free, bT = i.transactionunspentoutput_to_bytes, yT = i.transactionunspentoutput_from_bytes, vT = i.transactionunspentoutput_to_hex, mT = i.transactionunspentoutput_from_hex, kT = i.transactionunspentoutput_to_json, xT = i.transactionunspentoutput_to_js_value, ET = i.transactionunspentoutput_from_json, CT = i.transactionunspentoutput_new, ST = i.transactionunspentoutput_input, TT = i.transactionunspentoutput_output, jT = i.__wbg_transactionunspentoutputs_free, AT = i.transactionunspentoutputs_to_json, IT = i.transactionunspentoutputs_to_js_value, BT = i.transactionunspentoutputs_from_json, RT = i.transactionunspentoutputs_new, NT = i.transactionunspentoutputs_len, LT = i.transactionunspentoutputs_get, FT = i.transactionunspentoutputs_add, OT = i.__wbg_value_free, UT = i.value_to_bytes, zT = i.value_from_bytes, DT = i.value_to_hex, PT = i.value_from_hex, VT = i.value_to_json, MT = i.value_to_js_value, KT = i.value_from_json, qT = i.value_new, HT = i.value_new_from_assets, GT = i.value_new_with_assets, WT = i.value_zero, QT = i.value_is_zero, $T = i.value_coin, YT = i.value_set_coin, XT = i.value_multiasset, JT = i.value_set_multiasset, ZT = i.value_checked_add, tj = i.value_checked_sub, ej = i.value_clamped_sub, rj = i.value_compare, _j = i.make_daedalus_bootstrap_witness, nj = i.make_icarus_bootstrap_witness, aj = i.make_vkey_witness, oj = i.hash_auxiliary_data, sj = i.hash_plutus_data, ij = i.hash_script_data, cj = i.get_implicit_input, dj = i.get_deposit, lj = i.min_ada_for_output, pj = i.encode_json_str_to_native_script, uj = i.has_transaction_set_tag, fj = i.__wbg_transactioninput_free, gj = i.transactioninput_index, wj = i.newconstitutionaction_gov_action_id, hj = i.transactioninput_new, bj = i.transactioninput_transaction_id, yj = i.__wbg_certificatesbuilder_free, vj = i.certificatesbuilder_new, mj = i.certificatesbuilder_add, kj = i.certificatesbuilder_add_with_plutus_witness, xj = i.certificatesbuilder_add_with_native_script, Ej = i.certificatesbuilder_get_plutus_witnesses, Cj = i.certificatesbuilder_get_ref_inputs, Sj = i.certificatesbuilder_get_native_scripts, Tj = i.certificatesbuilder_get_certificates_refund, jj = i.certificatesbuilder_get_certificates_deposit, Aj = i.certificatesbuilder_has_plutus_scripts, Ij = i.certificatesbuilder_build, Bj = i.__wbg_votingbuilder_free, Rj = i.votingbuilder_new, Nj = i.votingbuilder_add, Lj = i.votingbuilder_add_with_plutus_witness, Fj = i.votingbuilder_add_with_native_script, Oj = i.votingbuilder_get_plutus_witnesses, Uj = i.votingbuilder_get_ref_inputs, zj = i.votingbuilder_get_native_scripts, Dj = i.votingbuilder_has_plutus_scripts, Pj = i.votingbuilder_build, Vj = i.__wbg_votingproposalbuilder_free, Mj = i.votingproposalbuilder_add, Kj = i.votingproposalbuilder_add_with_plutus_witness, qj = i.votingproposalbuilder_get_plutus_witnesses, Hj = i.votingproposalbuilder_get_ref_inputs, Gj = i.votingproposalbuilder_has_plutus_scripts, Wj = i.votingproposalbuilder_build, Qj = i.encrypt_with_password, $j = i.decrypt_with_password, Yj = i.__wbg_certificates_free, Xj = i.certificates_to_bytes, Jj = i.certificates_from_bytes, Zj = i.certificates_to_hex, tA = i.certificates_from_hex, eA = i.certificates_to_json, rA = i.certificates_to_js_value, _A = i.certificates_from_json, nA = i.certificates_new, aA = i.certificates_len, oA = i.certificates_get, sA = i.certificates_add, iA = i.__wbg_votingproposals_free, cA = i.votingproposals_to_bytes, dA = i.votingproposals_from_bytes, lA = i.votingproposals_to_hex, pA = i.votingproposals_from_hex, uA = i.votingproposals_to_json, fA = i.votingproposals_to_js_value, gA = i.votingproposals_from_json, wA = i.votingproposals_get, hA = i.votingproposals_add, bA = i.votingproposals_contains, yA = i.votingproposals_to_option, vA = i.__wbg_plutusscript_free, mA = i.plutusscript_to_bytes, kA = i.plutusscript_from_bytes, xA = i.plutusscript_to_hex, EA = i.plutusscript_from_hex, CA = i.plutusscript_new, SA = i.plutusscript_new_v2, TA = i.plutusscript_new_v3, jA = i.plutusscript_new_with_version, AA = i.plutusscript_bytes, IA = i.plutusscript_from_bytes_v2, BA = i.plutusscript_from_bytes_v3, RA = i.plutusscript_from_bytes_with_version, NA = i.plutusscript_from_hex_with_version, LA = i.plutusscript_hash, FA = i.plutusscript_language_version, OA = i.__wbg_transactioninputs_free, UA = i.transactioninputs_to_bytes, zA = i.transactioninputs_from_bytes, DA = i.transactioninputs_to_hex, PA = i.transactioninputs_from_hex, VA = i.transactioninputs_to_json, MA = i.transactioninputs_to_js_value, KA = i.transactioninputs_from_json, qA = i.transactioninputs_new, HA = i.transactioninputs_len, GA = i.transactioninputs_get, WA = i.transactioninputs_add, QA = i.transactioninputs_to_option, $A = i.votingproposals_new, YA = i.votingproposals_len, XA = i.votingproposalbuilder_new, JA = i.__wbg_mintwitness_free, ZA = i.mintwitness_new_native_script, tI = i.mintwitness_new_plutus_script, eI = i.__wbg_mintbuilder_free, rI = i.mintbuilder_new, _I = i.mintbuilder_add_asset, nI = i.mintbuilder_set_asset, aI = i.mintbuilder_build, oI = i.mintbuilder_get_native_scripts, sI = i.mintbuilder_get_plutus_witnesses, iI = i.mintbuilder_get_ref_inputs, cI = i.mintbuilder_get_redeemers, dI = i.mintbuilder_has_plutus_scripts, lI = i.mintbuilder_has_native_scripts, pI = i.__wbg_plutuswitness_free, uI = i.plutuswitness_new, fI = i.plutuswitness_new_with_ref, gI = i.plutuswitness_new_without_datum, wI = i.plutuswitness_new_with_ref_without_datum, hI = i.plutuswitness_script, bI = i.plutuswitness_datum, yI = i.plutuswitness_redeemer, vI = i.__wbg_plutuswitnesses_free, mI = i.plutuswitnesses_len, kI = i.plutuswitnesses_get, xI = i.plutuswitnesses_add, EI = i.__wbg_withdrawalsbuilder_free, CI = i.withdrawalsbuilder_add, SI = i.withdrawalsbuilder_add_with_plutus_witness, TI = i.withdrawalsbuilder_add_with_native_script, jI = i.withdrawalsbuilder_get_plutus_witnesses, AI = i.withdrawalsbuilder_get_ref_inputs, II = i.withdrawalsbuilder_get_native_scripts, BI = i.withdrawalsbuilder_get_total_withdrawals, RI = i.withdrawalsbuilder_has_plutus_scripts, NI = i.withdrawalsbuilder_build, LI = i.__wbg_transactionoutputbuilder_free, FI = i.transactionoutputbuilder_new, OI = i.transactionoutputbuilder_with_address, UI = i.transactionoutputbuilder_with_data_hash, zI = i.transactionoutputbuilder_with_plutus_data, DI = i.transactionoutputbuilder_with_script_ref, PI = i.transactionoutputbuilder_next, VI = i.__wbg_transactionoutputamountbuilder_free, MI = i.transactionoutputamountbuilder_with_value, KI = i.transactionoutputamountbuilder_with_coin, qI = i.transactionoutputamountbuilder_with_coin_and_asset, HI = i.transactionoutputamountbuilder_with_asset_and_min_required_coin_by_utxo_cost, GI = i.transactionoutputamountbuilder_build, WI = i.__wbg_fixedtransaction_free, QI = i.fixedtransaction_to_bytes, $I = i.fixedtransaction_from_bytes, YI = i.fixedtransaction_to_hex, XI = i.fixedtransaction_from_hex, JI = i.fixedtransaction_new, ZI = i.fixedtransaction_new_with_auxiliary, t8 = i.fixedtransaction_new_from_body_bytes, e8 = i.fixedtransaction_body, r8 = i.fixedtransaction_raw_body, _8 = i.fixedtransaction_set_body, n8 = i.fixedtransaction_set_witness_set, a8 = i.fixedtransaction_witness_set, o8 = i.fixedtransaction_raw_witness_set, s8 = i.fixedtransaction_set_is_valid, i8 = i.fixedtransaction_is_valid, c8 = i.fixedtransaction_set_auxiliary_data, d8 = i.fixedtransaction_auxiliary_data, l8 = i.fixedtransaction_raw_auxiliary_data, p8 = i.fixedtransaction_transaction_hash, u8 = i.fixedtransaction_add_vkey_witness, f8 = i.fixedtransaction_add_bootstrap_witness, g8 = i.fixedtransaction_sign_and_add_vkey_signature, w8 = i.fixedtransaction_sign_and_add_icarus_bootstrap_signature, h8 = i.fixedtransaction_sign_and_add_daedalus_bootstrap_signature, b8 = i.__wbg_networkinfo_free, y8 = i.networkinfo_new, v8 = i.networkinfo_network_id, m8 = i.networkinfo_protocol_magic, k8 = i.networkinfo_testnet_preview, x8 = i.networkinfo_testnet_preprod, E8 = i.networkinfo_mainnet, C8 = i.__wbg_malformedaddress_free, S8 = i.malformedaddress_original_bytes, T8 = i.malformedaddress_to_address, j8 = i.malformedaddress_from_address, A8 = i.__wbg_byronaddress_free, I8 = i.byronaddress_to_base58, B8 = i.byronaddress_to_bytes, R8 = i.byronaddress_from_bytes, N8 = i.byronaddress_byron_protocol_magic, L8 = i.byronaddress_byron_address_kind, F8 = i.byronaddress_attributes, O8 = i.byronaddress_network_id, U8 = i.byronaddress_from_base58, z8 = i.byronaddress_icarus_from_key, D8 = i.byronaddress_is_valid, P8 = i.byronaddress_to_address, V8 = i.byronaddress_from_address, M8 = i.__wbg_address_free, K8 = i.address_from_bytes, q8 = i.address_to_json, H8 = i.address_to_js_value, G8 = i.address_from_json, W8 = i.address_kind, Q8 = i.address_payment_cred, $8 = i.address_is_malformed, Y8 = i.address_to_hex, X8 = i.address_from_hex, J8 = i.address_to_bytes, Z8 = i.address_to_bech32, tB = i.address_from_bech32, eB = i.address_network_id, rB = i.__wbg_baseaddress_free, _B = i.baseaddress_new, nB = i.baseaddress_payment_cred, aB = i.baseaddress_stake_cred, oB = i.baseaddress_to_address, sB = i.baseaddress_from_address, iB = i.baseaddress_network_id, cB = i.__wbg_enterpriseaddress_free, dB = i.enterpriseaddress_new, lB = i.enterpriseaddress_to_address, pB = i.enterpriseaddress_from_address, uB = i.enterpriseaddress_network_id, fB = i.rewardaddress_to_address, gB = i.rewardaddress_from_address, wB = i.__wbg_pointer_free, hB = i.pointer_new, bB = i.pointer_new_pointer, yB = i.pointer_slot, vB = i.pointer_tx_index, mB = i.pointer_cert_index, kB = i.pointer_slot_bignum, xB = i.pointer_tx_index_bignum, EB = i.pointer_cert_index_bignum, CB = i.__wbg_pointeraddress_free, SB = i.pointeraddress_new, TB = i.pointeraddress_payment_cred, jB = i.pointeraddress_stake_pointer, AB = i.pointeraddress_to_address, IB = i.pointeraddress_from_address, BB = i.pointeraddress_network_id, RB = i.__wbg_transactionwitnesssets_free, NB = i.transactionwitnesssets_to_bytes, LB = i.transactionwitnesssets_from_bytes, FB = i.transactionwitnesssets_to_hex, OB = i.transactionwitnesssets_from_hex, UB = i.transactionwitnesssets_to_json, zB = i.transactionwitnesssets_to_js_value, DB = i.transactionwitnesssets_from_json, PB = i.transactionwitnesssets_len, VB = i.transactionwitnesssets_get, MB = i.transactionwitnesssets_add, KB = i.__wbg_fixedtxwitnessesset_free, qB = i.fixedtxwitnessesset_tx_witnesses_set, HB = i.fixedtxwitnessesset_add_vkey_witness, GB = i.fixedtxwitnessesset_add_bootstrap_witness, WB = i.fixedtxwitnessesset_to_bytes, QB = i.fixedtxwitnessesset_from_bytes, $B = i.__wbg_privatekey_free, YB = i.__wbg_nativescripts_free, XB = i.nativescripts_new, JB = i.nativescripts_len, ZB = i.nativescripts_get, tR = i.nativescripts_add, eR = i.nativescripts_to_bytes, rR = i.nativescripts_from_bytes, _R = i.nativescripts_to_hex, nR = i.nativescripts_from_hex, aR = i.nativescripts_to_json, oR = i.nativescripts_to_js_value, sR = i.nativescripts_from_json, iR = i.__wbg_bigint_free, cR = i.bigint_to_bytes, dR = i.bigint_from_bytes, lR = i.bigint_to_hex, pR = i.bigint_from_hex, uR = i.bigint_to_json, fR = i.bigint_to_js_value, gR = i.bigint_from_json, wR = i.bigint_is_zero, hR = i.bigint_as_u64, bR = i.bigint_as_int, yR = i.bigint_from_str, vR = i.bigint_to_str, mR = i.bigint_add, kR = i.bigint_sub, xR = i.bigint_mul, ER = i.bigint_pow, CR = i.bigint_one, SR = i.bigint_zero, TR = i.bigint_abs, jR = i.bigint_increment, AR = i.bigint_div_ceil, IR = i.bigint_div_floor, BR = i.__wbg_fixedtransactionbody_free, RR = i.fixedtransactionbody_from_bytes, NR = i.fixedtransactionbody_from_hex, LR = i.fixedtransactionbody_tx_hash, FR = i.fixedtransactionbody_original_bytes, OR = i.__wbg_transactionbodies_free, UR = i.transactionbodies_to_bytes, zR = i.transactionbodies_from_bytes, DR = i.transactionbodies_to_hex, PR = i.transactionbodies_from_hex, VR = i.transactionbodies_to_json, MR = i.transactionbodies_to_js_value, KR = i.transactionbodies_from_json, qR = i.transactionbodies_len, HR = i.transactionbodies_get, GR = i.transactionbodies_add, WR = i.__wbg_fixedtransactionbodies_free, QR = i.fixedtransactionbodies_from_bytes, $R = i.fixedtransactionbodies_from_hex, YR = i.fixedtransactionbodies_new, XR = i.fixedtransactionbodies_len, JR = i.fixedtransactionbodies_get, ZR = i.fixedtransactionbodies_add, t9 = i.privatekey_from_hex, e9 = i.privatekey_to_hex, r9 = i.privatekey_sign, _9 = i.privatekey_from_normal_bytes, n9 = i.privatekey_from_extended_bytes, a9 = i.privatekey_as_bytes, o9 = i.privatekey_to_bech32, s9 = i.privatekey_from_bech32, i9 = i.privatekey_generate_ed25519extended, c9 = i.privatekey_generate_ed25519, d9 = i.privatekey_to_public, l9 = i.__wbg_rewardaddress_free, p9 = i.enterpriseaddress_payment_cred, u9 = i.rewardaddress_payment_cred, f9 = i.fixedtransactionbody_transaction_body, g9 = i.rewardaddress_new, w9 = i.withdrawalsbuilder_new, h9 = i.rewardaddress_network_id, b9 = i.transactionwitnesssets_new, y9 = i.transactionbodies_new, v9 = i.plutuswitnesses_new, m9 = i.__wbg_poolretirement_free, k9 = i.poolretirement_to_bytes, x9 = i.poolretirement_from_bytes, E9 = i.poolretirement_to_hex, C9 = i.poolretirement_from_hex, S9 = i.poolretirement_to_json, T9 = i.poolretirement_to_js_value, j9 = i.poolretirement_from_json, A9 = i.poolretirement_pool_keyhash, I9 = i.poolretirement_epoch, B9 = i.poolretirement_new, R9 = i.__wbg_stakedelegation_free, N9 = i.stakedelegation_to_bytes, L9 = i.stakedelegation_from_bytes, F9 = i.stakedelegation_to_hex, O9 = i.stakedelegation_from_hex, U9 = i.stakedelegation_to_json, z9 = i.stakedelegation_to_js_value, D9 = i.stakedelegation_from_json, P9 = i.stakedelegation_stake_credential, V9 = i.stakedelegation_pool_keyhash, M9 = i.stakedelegation_new, K9 = i.stakedelegation_has_script_credentials, q9 = i.__wbg_committeecoldresign_free, H9 = i.committeecoldresign_to_bytes, G9 = i.committeecoldresign_from_bytes, W9 = i.committeecoldresign_to_hex, Q9 = i.committeecoldresign_from_hex, $9 = i.committeecoldresign_to_json, Y9 = i.committeecoldresign_to_js_value, X9 = i.committeecoldresign_from_json, J9 = i.committeecoldresign_committee_cold_credential, Z9 = i.committeecoldresign_anchor, tN = i.committeecoldresign_new, eN = i.committeecoldresign_new_with_anchor, rN = i.committeecoldresign_has_script_credentials, _N = i.__wbg_drepregistration_free, nN = i.drepregistration_to_bytes, aN = i.drepregistration_from_bytes, oN = i.drepregistration_to_hex, sN = i.drepregistration_from_hex, iN = i.drepregistration_to_json, cN = i.drepregistration_to_js_value, dN = i.drepregistration_from_json, lN = i.drepregistration_voting_credential, pN = i.drepregistration_coin, uN = i.drepregistration_anchor, fN = i.drepregistration_new, gN = i.drepregistration_new_with_anchor, wN = i.drepregistration_has_script_credentials, hN = i.__wbg_votingprocedure_free, bN = i.votingprocedure_to_bytes, yN = i.votingprocedure_from_bytes, vN = i.votingprocedure_to_hex, mN = i.votingprocedure_from_hex, kN = i.votingprocedure_to_json, xN = i.votingprocedure_to_js_value, EN = i.votingprocedure_from_json, CN = i.votingprocedure_new, SN = i.votingprocedure_new_with_anchor, TN = i.votingprocedure_vote_kind, jN = i.__wbg_governanceactionids_free, AN = i.governanceactionids_to_json, IN = i.governanceactionids_to_js_value, BN = i.governanceactionids_from_json, RN = i.governanceactionids_new, NN = i.governanceactionids_add, LN = i.governanceactionids_get, FN = i.governanceactionids_len, ON = i.__wbg_infoaction_free, UN = i.infoaction_new, zN = i.__wbg_vkeywitness_free, DN = i.vkeywitness_to_bytes, PN = i.vkeywitness_from_bytes, VN = i.vkeywitness_to_hex, MN = i.vkeywitness_from_hex, KN = i.vkeywitness_to_json, qN = i.vkeywitness_to_js_value, HN = i.vkeywitness_from_json, GN = i.vkeywitness_new, WN = i.vkeywitness_vkey, QN = i.vkeywitness_signature, $N = i.__wbg_bip32privatekey_free, YN = i.bip32privatekey_derive, XN = i.bip32privatekey_from_128_xprv, JN = i.bip32privatekey_to_128_xprv, ZN = i.bip32privatekey_generate_ed25519_bip32, t7 = i.bip32privatekey_to_raw_key, e7 = i.bip32privatekey_to_public, r7 = i.bip32privatekey_from_bytes, _7 = i.bip32privatekey_as_bytes, n7 = i.bip32privatekey_from_bech32, a7 = i.bip32privatekey_to_bech32, o7 = i.bip32privatekey_from_bip39_entropy, s7 = i.bip32privatekey_chaincode, i7 = i.bip32privatekey_to_hex, c7 = i.bip32privatekey_from_hex, d7 = i.vkeys_get, l7 = i.vkeys_add, p7 = i.__wbg_publickeys_free, u7 = i.publickeys_new, f7 = i.publickeys_size, g7 = i.publickeys_get, w7 = i.publickeys_add, h7 = i.__wbg_kessignature_free, b7 = i.kessignature_to_bytes, y7 = i.kessignature_from_bytes, v7 = i.__wbg_nativescript_free, m7 = i.nativescript_to_bytes, k7 = i.nativescript_from_bytes, x7 = i.nativescript_to_hex, E7 = i.nativescript_from_hex, C7 = i.nativescript_to_json, S7 = i.nativescript_to_js_value, T7 = i.nativescript_from_json, j7 = i.nativescript_hash, A7 = i.nativescript_new_script_pubkey, I7 = i.nativescript_new_script_all, B7 = i.nativescript_new_script_any, R7 = i.nativescript_new_script_n_of_k, N7 = i.nativescript_new_timelock_start, L7 = i.nativescript_new_timelock_expiry, F7 = i.nativescript_kind, O7 = i.nativescript_as_script_pubkey, U7 = i.nativescript_as_script_all, z7 = i.nativescript_as_script_any, D7 = i.nativescript_as_script_n_of_k, P7 = i.nativescript_as_timelock_start, V7 = i.nativescript_as_timelock_expiry, M7 = i.nativescript_get_required_signers, K7 = i.__wbg_scriptpubkey_free, q7 = i.scriptpubkey_to_bytes, H7 = i.scriptpubkey_from_bytes, G7 = i.scriptpubkey_to_hex, W7 = i.scriptpubkey_from_hex, Q7 = i.scriptpubkey_to_json, $7 = i.scriptpubkey_to_js_value, Y7 = i.scriptpubkey_from_json, X7 = i.scriptpubkey_addr_keyhash, J7 = i.scriptpubkey_new, Z7 = i.__wbg_scriptall_free, tL = i.scriptall_to_bytes, eL = i.scriptall_from_bytes, rL = i.scriptall_to_hex, _L = i.scriptall_from_hex, nL = i.scriptall_to_json, aL = i.scriptall_to_js_value, oL = i.scriptall_from_json, sL = i.scriptall_native_scripts, iL = i.scriptall_new, cL = i.scriptany_to_bytes, dL = i.scriptany_from_bytes, lL = i.scriptany_to_hex, pL = i.scriptany_from_hex, uL = i.scriptany_to_json, fL = i.scriptany_to_js_value, gL = i.scriptany_from_json, wL = i.__wbg_scriptnofk_free, hL = i.scriptnofk_to_bytes, bL = i.scriptnofk_from_bytes, yL = i.scriptnofk_to_hex, vL = i.scriptnofk_from_hex, mL = i.scriptnofk_to_json, kL = i.scriptnofk_to_js_value, xL = i.scriptnofk_from_json, EL = i.scriptnofk_n, CL = i.scriptnofk_new, SL = i.timelockstart_to_bytes, TL = i.timelockstart_from_bytes, jL = i.timelockstart_to_hex, AL = i.timelockstart_from_hex, IL = i.timelockstart_to_json, BL = i.timelockstart_to_js_value, RL = i.timelockstart_from_json, NL = i.__wbg_timelockexpiry_free, LL = i.timelockexpiry_to_bytes, FL = i.timelockexpiry_from_bytes, OL = i.timelockexpiry_to_hex, UL = i.timelockexpiry_from_hex, zL = i.timelockexpiry_to_json, DL = i.timelockexpiry_to_js_value, PL = i.timelockexpiry_from_json, VL = i.timelockexpiry_slot, ML = i.timelockexpiry_slot_bignum, KL = i.timelockexpiry_new, qL = i.timelockexpiry_new_timelockexpiry, HL = i.__wbg_headerbody_free, GL = i.headerbody_to_bytes, WL = i.headerbody_from_bytes, QL = i.headerbody_to_hex, $L = i.headerbody_from_hex, YL = i.headerbody_to_json, XL = i.headerbody_to_js_value, JL = i.headerbody_from_json, ZL = i.headerbody_block_number, tF = i.headerbody_slot, eF = i.headerbody_slot_bignum, rF = i.headerbody_prev_hash, _F = i.headerbody_issuer_vkey, nF = i.headerbody_vrf_vkey, aF = i.headerbody_has_nonce_and_leader_vrf, oF = i.headerbody_nonce_vrf_or_nothing, sF = i.headerbody_leader_vrf_or_nothing, iF = i.headerbody_has_vrf_result, cF = i.headerbody_vrf_result_or_nothing, dF = i.headerbody_block_body_size, lF = i.headerbody_block_body_hash, pF = i.headerbody_operational_cert, uF = i.headerbody_protocol_version, fF = i.headerbody_new, gF = i.headerbody_new_headerbody, wF = i.votingprocedure_anchor, hF = i.__wbg_scriptany_free, bF = i.timelockstart_slot_bignum, yF = i.timelockstart_slot, vF = i.vkeys_len, mF = i.scriptany_native_scripts, kF = i.scriptnofk_native_scripts, xF = i.scriptany_new, EF = i.__wbg_vkeys_free, CF = i.vkeys_new, SF = i.__wbg_timelockstart_free, TF = i.timelockstart_new_timelockstart, jF = i.timelockstart_new, AF = i.__wbg_plutusscriptsource_free, IF = i.plutusscriptsource_new, BF = i.plutusscriptsource_new_ref_input, RF = i.plutusscriptsource_set_required_signers, NF = i.plutusscriptsource_get_ref_script_size, LF = i.__wbg_nativescriptsource_free, FF = i.nativescriptsource_new, OF = i.nativescriptsource_new_ref_input, UF = i.nativescriptsource_set_required_signers, zF = i.nativescriptsource_get_ref_script_size, DF = i.__wbg_transactionbatchlist_free, PF = i.transactionbatchlist_len, VF = i.transactionbatchlist_get, MF = i.__wbg_transactionbatch_free, KF = i.transactionbatch_len, qF = i.transactionbatch_get, HF = i.create_send_all, GF = i.__wbg_txinputsbuilder_free, WF = i.txinputsbuilder_new, QF = i.txinputsbuilder_add_regular_utxo, $F = i.txinputsbuilder_add_plutus_script_utxo, YF = i.txinputsbuilder_add_native_script_utxo, XF = i.txinputsbuilder_add_key_input, JF = i.txinputsbuilder_add_native_script_input, ZF = i.txinputsbuilder_add_plutus_script_input, tO = i.txinputsbuilder_add_bootstrap_input, eO = i.txinputsbuilder_add_regular_input, rO = i.txinputsbuilder_get_ref_inputs, _O = i.txinputsbuilder_get_native_input_scripts, nO = i.txinputsbuilder_get_plutus_input_scripts, aO = i.txinputsbuilder_len, oO = i.txinputsbuilder_add_required_signer, sO = i.txinputsbuilder_add_required_signers, iO = i.txinputsbuilder_total_value, cO = i.txinputsbuilder_inputs, dO = i.txinputsbuilder_inputs_option, lO = i.__wbg_certificate_free, pO = i.certificate_to_bytes, uO = i.certificate_from_bytes, fO = i.certificate_to_hex, gO = i.certificate_from_hex, wO = i.certificate_to_json, hO = i.certificate_to_js_value, bO = i.certificate_from_json, yO = i.certificate_new_stake_registration, vO = i.certificate_new_reg_cert, mO = i.certificate_new_stake_deregistration, kO = i.certificate_new_unreg_cert, xO = i.certificate_new_stake_delegation, EO = i.certificate_new_pool_registration, CO = i.certificate_new_pool_retirement, SO = i.certificate_new_genesis_key_delegation, TO = i.certificate_new_move_instantaneous_rewards_cert, jO = i.certificate_new_committee_hot_auth, AO = i.certificate_new_committee_cold_resign, IO = i.certificate_new_drep_deregistration, BO = i.certificate_new_drep_registration, RO = i.certificate_new_drep_update, NO = i.certificate_new_stake_and_vote_delegation, LO = i.certificate_new_stake_registration_and_delegation, FO = i.certificate_new_stake_vote_registration_and_delegation, OO = i.certificate_new_vote_delegation, UO = i.certificate_new_vote_registration_and_delegation, zO = i.certificate_kind, DO = i.certificate_as_stake_registration, PO = i.certificate_as_reg_cert, VO = i.certificate_as_stake_deregistration, MO = i.certificate_as_unreg_cert, KO = i.certificate_as_stake_delegation, qO = i.certificate_as_pool_registration, HO = i.certificate_as_pool_retirement, GO = i.certificate_as_genesis_key_delegation, WO = i.certificate_as_move_instantaneous_rewards_cert, QO = i.certificate_as_committee_hot_auth, $O = i.certificate_as_committee_cold_resign, YO = i.certificate_as_drep_deregistration, XO = i.certificate_as_drep_registration, JO = i.certificate_as_drep_update, ZO = i.certificate_as_stake_and_vote_delegation, tU = i.certificate_as_stake_registration_and_delegation, eU = i.certificate_as_stake_vote_registration_and_delegation, rU = i.certificate_as_vote_delegation, _U = i.certificate_as_vote_registration_and_delegation, nU = i.certificate_has_required_script_witness, aU = i.__wbg_genesiskeydelegation_free, oU = i.genesiskeydelegation_to_bytes, sU = i.genesiskeydelegation_from_bytes, iU = i.genesiskeydelegation_to_hex, cU = i.genesiskeydelegation_from_hex, dU = i.genesiskeydelegation_to_json, lU = i.genesiskeydelegation_to_js_value, pU = i.genesiskeydelegation_from_json, uU = i.genesiskeydelegation_genesishash, fU = i.genesiskeydelegation_genesis_delegate_hash, gU = i.genesiskeydelegation_vrf_keyhash, wU = i.genesiskeydelegation_new, hU = i.__wbg_stakederegistration_free, bU = i.stakederegistration_to_bytes, yU = i.stakederegistration_from_bytes, vU = i.stakederegistration_to_hex, mU = i.stakederegistration_from_hex, kU = i.stakederegistration_to_json, xU = i.stakederegistration_to_js_value, EU = i.stakederegistration_from_json, CU = i.stakederegistration_stake_credential, SU = i.stakederegistration_coin, TU = i.stakederegistration_new, jU = i.stakederegistration_new_with_explicit_refund, AU = i.stakederegistration_has_script_credentials, IU = i.__wbg_voters_free, BU = i.voters_to_json, RU = i.voters_to_js_value, NU = i.voters_from_json, LU = i.voters_new, FU = i.voters_add, OU = i.voters_get, UU = i.voters_len, zU = i.__wbg_plutusscripts_free, DU = i.plutusscripts_to_bytes, PU = i.plutusscripts_from_bytes, VU = i.plutusscripts_to_hex, MU = i.plutusscripts_from_hex, KU = i.plutusscripts_to_json, qU = i.plutusscripts_to_js_value, HU = i.plutusscripts_from_json, GU = i.plutusscripts_new, WU = i.plutusscripts_len, QU = i.plutusscripts_get, $U = i.plutusscripts_add, YU = i.__wbg_costmdls_free, XU = i.costmdls_to_bytes, JU = i.costmdls_from_bytes, ZU = i.costmdls_to_hex, tz = i.costmdls_from_hex, ez = i.costmdls_to_json, rz = i.costmdls_to_js_value, _z = i.costmdls_from_json, nz = i.costmdls_new, az = i.costmdls_len, oz = i.costmdls_insert, sz = i.costmdls_get, iz = i.costmdls_keys, cz = i.costmdls_retain_language_versions, dz = i.__wbg_ed25519keyhashes_free, lz = i.ed25519keyhashes_to_bytes, pz = i.ed25519keyhashes_from_bytes, uz = i.ed25519keyhashes_to_hex, fz = i.ed25519keyhashes_from_hex, gz = i.ed25519keyhashes_to_json, wz = i.ed25519keyhashes_to_js_value, hz = i.ed25519keyhashes_from_json, bz = i.ed25519keyhashes_new, yz = i.ed25519keyhashes_len, vz = i.ed25519keyhashes_get, mz = i.ed25519keyhashes_add, kz = i.ed25519keyhashes_contains, xz = i.ed25519keyhashes_to_option, Ez = i.__wbg_ed25519keyhash_free, Cz = i.ed25519keyhash_from_bytes, Sz = i.ed25519keyhash_to_bytes, Tz = i.ed25519keyhash_to_bech32, jz = i.ed25519keyhash_from_bech32, Az = i.ed25519keyhash_to_hex, Iz = i.ed25519keyhash_from_hex, Bz = i.scripthash_from_bytes, Rz = i.scripthash_from_bech32, Nz = i.scripthash_from_hex, Lz = i.__wbg_anchordatahash_free, Fz = i.anchordatahash_from_bytes, Oz = i.anchordatahash_to_bytes, Uz = i.anchordatahash_to_bech32, zz = i.anchordatahash_from_bech32, Dz = i.anchordatahash_to_hex, Pz = i.anchordatahash_from_hex, Vz = i.transactionhash_from_bytes, Mz = i.transactionhash_from_bech32, Kz = i.transactionhash_from_hex, qz = i.genesisdelegatehash_from_bytes, Hz = i.genesisdelegatehash_from_bech32, Gz = i.genesisdelegatehash_from_hex, Wz = i.genesishash_from_bytes, Qz = i.genesishash_from_bech32, $z = i.genesishash_from_hex, Yz = i.auxiliarydatahash_from_bytes, Xz = i.auxiliarydatahash_from_bech32, Jz = i.auxiliarydatahash_from_hex, Zz = i.poolmetadatahash_from_bytes, tD = i.poolmetadatahash_from_bech32, eD = i.poolmetadatahash_from_hex, rD = i.vrfkeyhash_from_bytes, _D = i.vrfkeyhash_from_bech32, nD = i.vrfkeyhash_from_hex, aD = i.blockhash_from_bytes, oD = i.blockhash_from_bech32, sD = i.blockhash_from_hex, iD = i.datahash_from_bytes, cD = i.datahash_from_bech32, dD = i.datahash_from_hex, lD = i.scriptdatahash_from_bytes, pD = i.scriptdatahash_from_bech32, uD = i.scriptdatahash_from_hex, fD = i.vrfvkey_from_bytes, gD = i.vrfvkey_from_bech32, wD = i.vrfvkey_from_hex, hD = i.kesvkey_from_bytes, bD = i.kesvkey_from_bech32, yD = i.kesvkey_from_hex, vD = i.__wbg_scripthash_free, mD = i.__wbg_transactionhash_free, kD = i.__wbg_genesisdelegatehash_free, xD = i.__wbg_genesishash_free, ED = i.__wbg_auxiliarydatahash_free, CD = i.__wbg_poolmetadatahash_free, SD = i.__wbg_vrfkeyhash_free, TD = i.__wbg_blockhash_free, jD = i.__wbg_datahash_free, AD = i.__wbg_scriptdatahash_free, ID = i.__wbg_vrfvkey_free, BD = i.__wbg_kesvkey_free, RD = i.scripthash_to_hex, ND = i.transactionhash_to_hex, LD = i.genesisdelegatehash_to_hex, FD = i.genesishash_to_hex, OD = i.auxiliarydatahash_to_hex, UD = i.poolmetadatahash_to_hex, zD = i.vrfkeyhash_to_hex, DD = i.blockhash_to_hex, PD = i.datahash_to_hex, VD = i.scriptdatahash_to_hex, MD = i.vrfvkey_to_hex, KD = i.kesvkey_to_hex, qD = i.scripthash_to_bytes, HD = i.vrfkeyhash_to_bytes, GD = i.genesisdelegatehash_to_bytes, WD = i.genesishash_to_bytes, QD = i.transactionhash_to_bytes, $D = i.poolmetadatahash_to_bytes, YD = i.auxiliarydatahash_to_bytes, XD = i.blockhash_to_bytes, JD = i.datahash_to_bytes, ZD = i.scriptdatahash_to_bytes, tP = i.vrfvkey_to_bytes, eP = i.kesvkey_to_bytes, rP = i.scripthash_to_bech32, _P = i.vrfkeyhash_to_bech32, nP = i.genesisdelegatehash_to_bech32, aP = i.genesishash_to_bech32, oP = i.transactionhash_to_bech32, sP = i.poolmetadatahash_to_bech32, iP = i.auxiliarydatahash_to_bech32, cP = i.blockhash_to_bech32, dP = i.datahash_to_bech32, lP = i.scriptdatahash_to_bech32, pP = i.vrfvkey_to_bech32, uP = i.kesvkey_to_bech32, fP = i.__wbg_transactionbuilderconfig_free, gP = i.__wbg_transactionbuilderconfigbuilder_free, wP = i.transactionbuilderconfigbuilder_new, hP = i.transactionbuilderconfigbuilder_fee_algo, bP = i.transactionbuilderconfigbuilder_coins_per_utxo_byte, yP = i.transactionbuilderconfigbuilder_ex_unit_prices, vP = i.transactionbuilderconfigbuilder_pool_deposit, mP = i.transactionbuilderconfigbuilder_key_deposit, kP = i.transactionbuilderconfigbuilder_max_value_size, xP = i.transactionbuilderconfigbuilder_max_tx_size, EP = i.transactionbuilderconfigbuilder_ref_script_coins_per_byte, CP = i.transactionbuilderconfigbuilder_prefer_pure_change, SP = i.transactionbuilderconfigbuilder_deduplicate_explicit_ref_inputs_with_regular_inputs, TP = i.transactionbuilderconfigbuilder_do_not_burn_extra_change, jP = i.transactionbuilderconfigbuilder_build, AP = i.__wbg_changeconfig_free, IP = i.changeconfig_new, BP = i.changeconfig_change_address, RP = i.changeconfig_change_plutus_data, NP = i.changeconfig_change_script_ref, LP = i.__wbg_transactionbuilder_free, FP = i.transactionbuilder_add_inputs_from, OP = i.transactionbuilder_set_inputs, UP = i.transactionbuilder_set_collateral, zP = i.transactionbuilder_set_collateral_return, DP = i.transactionbuilder_remove_collateral_return, PP = i.transactionbuilder_set_collateral_return_and_total, VP = i.transactionbuilder_set_total_collateral, MP = i.transactionbuilder_remove_total_collateral, KP = i.transactionbuilder_set_total_collateral_and_return, qP = i.transactionbuilder_add_reference_input, HP = i.transactionbuilder_add_script_reference_input, GP = i.transactionbuilder_add_key_input, WP = i.transactionbuilder_add_native_script_input, QP = i.transactionbuilder_add_plutus_script_input, $P = i.transactionbuilder_add_bootstrap_input, YP = i.transactionbuilder_add_regular_input, XP = i.transactionbuilder_add_inputs_from_and_change, JP = i.transactionbuilder_add_inputs_from_and_change_with_collateral_return, ZP = i.transactionbuilder_get_native_input_scripts, tV = i.transactionbuilder_get_plutus_input_scripts, eV = i.transactionbuilder_fee_for_input, rV = i.transactionbuilder_add_output, _V = i.transactionbuilder_fee_for_output, nV = i.transactionbuilder_set_fee, aV = i.transactionbuilder_set_min_fee, oV = i.transactionbuilder_set_ttl, sV = i.transactionbuilder_set_ttl_bignum, iV = i.transactionbuilder_remove_ttl, cV = i.transactionbuilder_set_validity_start_interval, dV = i.transactionbuilder_set_validity_start_interval_bignum, lV = i.transactionbuilder_remove_validity_start_interval, pV = i.transactionbuilder_set_certs, uV = i.transactionbuilder_remove_certs, fV = i.transactionbuilder_set_certs_builder, gV = i.transactionbuilder_set_withdrawals, wV = i.transactionbuilder_set_withdrawals_builder, hV = i.transactionbuilder_set_voting_builder, bV = i.transactionbuilder_set_voting_proposal_builder, yV = i.transactionbuilder_remove_withdrawals, vV = i.transactionbuilder_get_auxiliary_data, mV = i.transactionbuilder_set_auxiliary_data, kV = i.transactionbuilder_remove_auxiliary_data, xV = i.transactionbuilder_set_metadata, EV = i.transactionbuilder_add_metadatum, CV = i.transactionbuilder_add_json_metadatum, SV = i.transactionbuilder_add_json_metadatum_with_schema, TV = i.transactionbuilder_set_mint_builder, jV = i.transactionbuilder_remove_mint_builder, AV = i.transactionbuilder_get_mint_builder, IV = i.transactionbuilder_set_mint, BV = i.transactionbuilder_get_mint, RV = i.transactionbuilder_get_mint_scripts, NV = i.transactionbuilder_set_mint_asset, LV = i.transactionbuilder_add_mint_asset, FV = i.transactionbuilder_add_mint_asset_and_output, OV = i.transactionbuilder_add_mint_asset_and_output_min_required_coin, UV = i.transactionbuilder_add_extra_witness_datum, zV = i.transactionbuilder_get_extra_witness_datums, DV = i.transactionbuilder_set_donation, PV = i.transactionbuilder_get_donation, VV = i.transactionbuilder_set_current_treasury_value, MV = i.transactionbuilder_get_current_treasury_value, KV = i.transactionbuilder_new, qV = i.transactionbuilder_get_reference_inputs, HV = i.transactionbuilder_get_explicit_input, GV = i.transactionbuilder_get_implicit_input, WV = i.transactionbuilder_get_total_input, QV = i.transactionbuilder_get_total_output, $V = i.transactionbuilder_get_explicit_output, YV = i.transactionbuilder_get_deposit, XV = i.transactionbuilder_get_fee_if_set, JV = i.transactionbuilder_add_change_if_needed, ZV = i.transactionbuilder_add_change_if_needed_with_datum, tM = i.transactionbuilder_calc_script_data_hash, eM = i.transactionbuilder_set_script_data_hash, rM = i.transactionbuilder_remove_script_data_hash, _M = i.transactionbuilder_add_required_signer, nM = i.transactionbuilder_full_size, aM = i.transactionbuilder_output_sizes, oM = i.transactionbuilder_build, sM = i.transactionbuilder_build_tx, iM = i.transactionbuilder_build_tx_unsafe, cM = i.transactionbuilder_min_fee, dM = i.__wbg_votingprocedures_free, lM = i.votingprocedures_to_bytes, pM = i.votingprocedures_from_bytes, uM = i.votingprocedures_to_hex, fM = i.votingprocedures_from_hex, gM = i.votingprocedures_to_json, wM = i.votingprocedures_to_js_value, hM = i.votingprocedures_from_json, bM = i.votingprocedures_insert, yM = i.votingprocedures_get, vM = i.votingprocedures_get_voters, mM = i.votingprocedures_get_governance_action_ids_by_voter, kM = i.__wbg_treasurywithdrawals_free, xM = i.treasurywithdrawals_to_json, EM = i.treasurywithdrawals_to_js_value, CM = i.treasurywithdrawals_from_json, SM = i.treasurywithdrawals_new, TM = i.treasurywithdrawals_get, jM = i.treasurywithdrawals_insert, AM = i.treasurywithdrawals_keys, IM = i.treasurywithdrawals_len, BM = i.__wbg_committee_free, RM = i.committee_to_bytes, NM = i.committee_from_bytes, LM = i.committee_to_hex, FM = i.committee_from_hex, OM = i.committee_to_json, UM = i.committee_to_js_value, zM = i.committee_from_json, DM = i.committee_new, PM = i.committee_members_keys, VM = i.committee_quorum_threshold, MM = i.committee_add_member, KM = i.committee_get_member_epoch, qM = i.__wbg_costmodel_free, HM = i.costmodel_to_bytes, GM = i.costmodel_from_bytes, WM = i.costmodel_to_hex, QM = i.costmodel_from_hex, $M = i.costmodel_to_json, YM = i.costmodel_to_js_value, XM = i.costmodel_from_json, JM = i.costmodel_new, ZM = i.costmodel_set, tK = i.costmodel_get, eK = i.costmodel_len, rK = i.__wbg_exunits_free, _K = i.exunits_to_bytes, nK = i.exunits_from_bytes, aK = i.exunits_to_hex, oK = i.exunits_from_hex, sK = i.exunits_to_json, iK = i.exunits_to_js_value, cK = i.exunits_from_json, dK = i.exunits_mem, lK = i.exunits_steps, pK = i.exunits_new, uK = i.__wbg_transactionbody_free, fK = i.transactionbody_to_bytes, gK = i.transactionbody_from_bytes, wK = i.transactionbody_to_hex, hK = i.transactionbody_from_hex, bK = i.transactionbody_to_json, yK = i.transactionbody_to_js_value, vK = i.transactionbody_from_json, mK = i.transactionbody_inputs, kK = i.transactionbody_outputs, xK = i.transactionbody_fee, EK = i.transactionbody_ttl, CK = i.transactionbody_ttl_bignum, SK = i.transactionbody_set_ttl, TK = i.transactionbody_remove_ttl, jK = i.transactionbody_set_certs, AK = i.transactionbody_certs, IK = i.transactionbody_set_withdrawals, BK = i.transactionbody_withdrawals, RK = i.transactionbody_set_update, NK = i.transactionbody_update, LK = i.transactionbody_set_auxiliary_data_hash, FK = i.transactionbody_auxiliary_data_hash, OK = i.transactionbody_set_validity_start_interval, UK = i.transactionbody_set_validity_start_interval_bignum, zK = i.transactionbody_validity_start_interval_bignum, DK = i.transactionbody_validity_start_interval, PK = i.transactionbody_set_mint, VK = i.transactionbody_mint, MK = i.transactionbody_set_reference_inputs, KK = i.transactionbody_reference_inputs, qK = i.transactionbody_set_script_data_hash, HK = i.transactionbody_script_data_hash, GK = i.transactionbody_set_collateral, WK = i.transactionbody_collateral, QK = i.transactionbody_set_required_signers, $K = i.transactionbody_required_signers, YK = i.transactionbody_set_network_id, XK = i.transactionbody_network_id, JK = i.transactionbody_set_collateral_return, ZK = i.transactionbody_collateral_return, tq = i.transactionbody_set_total_collateral, eq = i.transactionbody_total_collateral, rq = i.transactionbody_set_voting_procedures, _q = i.transactionbody_voting_procedures, nq = i.transactionbody_set_voting_proposals, aq = i.transactionbody_voting_proposals, oq = i.transactionbody_set_donation, sq = i.transactionbody_donation, iq = i.transactionbody_set_current_treasury_value, cq = i.transactionbody_current_treasury_value, dq = i.transactionbody_new, lq = i.transactionbody_new_tx_body, pq = i.__wbg_transactionwitnessset_free, uq = i.transactionwitnessset_to_bytes, fq = i.transactionwitnessset_from_bytes, gq = i.transactionwitnessset_to_hex, wq = i.transactionwitnessset_from_hex, hq = i.transactionwitnessset_to_json, bq = i.transactionwitnessset_to_js_value, yq = i.transactionwitnessset_from_json, vq = i.transactionwitnessset_set_vkeys, mq = i.transactionwitnessset_vkeys, kq = i.transactionwitnessset_set_native_scripts, xq = i.transactionwitnessset_native_scripts, Eq = i.transactionwitnessset_set_bootstraps, Cq = i.transactionwitnessset_bootstraps, Sq = i.transactionwitnessset_set_plutus_scripts, Tq = i.transactionwitnessset_plutus_scripts, jq = i.transactionwitnessset_set_plutus_data, Aq = i.transactionwitnessset_plutus_data, Iq = i.transactionwitnessset_set_redeemers, Bq = i.transactionwitnessset_redeemers, Rq = i.transactionwitnessset_new, Nq = i.__wbg_vrfcert_free, Lq = i.vrfcert_to_bytes, Fq = i.vrfcert_from_bytes, Oq = i.vrfcert_to_hex, Uq = i.vrfcert_from_hex, zq = i.vrfcert_to_json, Dq = i.vrfcert_to_js_value, Pq = i.vrfcert_from_json, Vq = i.vrfcert_output, Mq = i.vrfcert_proof, Kq = i.vrfcert_new, qq = i.votingprocedures_new, Hq = i.__wbg_datumsource_free, Gq = i.datumsource_new, Wq = i.datumsource_new_ref_input, Qq = i.__wbg_drepderegistration_free, $q = i.drepderegistration_to_bytes, Yq = i.drepderegistration_from_bytes, Xq = i.drepderegistration_to_hex, Jq = i.drepderegistration_from_hex, Zq = i.drepderegistration_to_json, tH = i.drepderegistration_to_js_value, eH = i.drepderegistration_from_json, rH = i.drepderegistration_voting_credential, _H = i.drepderegistration_coin, nH = i.drepderegistration_new, aH = i.drepderegistration_has_script_credentials, oH = i.__wbg_drepupdate_free, sH = i.drepupdate_to_bytes, iH = i.drepupdate_from_bytes, cH = i.drepupdate_to_hex, dH = i.drepupdate_from_hex, lH = i.drepupdate_to_json, pH = i.drepupdate_to_js_value, uH = i.drepupdate_from_json, fH = i.drepupdate_voting_credential, gH = i.drepupdate_anchor, wH = i.drepupdate_new, hH = i.drepupdate_new_with_anchor, bH = i.drepupdate_has_script_credentials, yH = i.__wbg_noconfidenceaction_free, vH = i.noconfidenceaction_to_bytes, mH = i.noconfidenceaction_from_bytes, kH = i.noconfidenceaction_to_hex, xH = i.noconfidenceaction_from_hex, EH = i.noconfidenceaction_to_json, CH = i.noconfidenceaction_to_js_value, SH = i.noconfidenceaction_from_json, TH = i.noconfidenceaction_gov_action_id, jH = i.noconfidenceaction_new, AH = i.noconfidenceaction_new_with_action_id, IH = i.__wbg_governanceaction_free, BH = i.governanceaction_to_bytes, RH = i.governanceaction_from_bytes, NH = i.governanceaction_to_hex, LH = i.governanceaction_from_hex, FH = i.governanceaction_to_json, OH = i.governanceaction_to_js_value, UH = i.governanceaction_from_json, zH = i.governanceaction_new_parameter_change_action, DH = i.governanceaction_new_hard_fork_initiation_action, PH = i.governanceaction_new_treasury_withdrawals_action, VH = i.governanceaction_new_no_confidence_action, MH = i.governanceaction_new_new_committee_action, KH = i.governanceaction_new_new_constitution_action, qH = i.governanceaction_new_info_action, HH = i.governanceaction_kind, GH = i.governanceaction_as_parameter_change_action, WH = i.governanceaction_as_hard_fork_initiation_action, QH = i.governanceaction_as_treasury_withdrawals_action, $H = i.governanceaction_as_no_confidence_action, YH = i.governanceaction_as_new_committee_action, XH = i.governanceaction_as_new_constitution_action, JH = i.governanceaction_as_info_action, ZH = i.__wbg_strings_free, tG = i.strings_new, eG = i.strings_len, rG = i.strings_get, _G = i.strings_add, nG = i.__wbg_credentials_free, aG = i.credentials_to_bytes, oG = i.credentials_from_bytes, sG = i.credentials_to_hex, iG = i.credentials_from_hex, cG = i.credentials_to_json, dG = i.credentials_to_js_value, lG = i.credentials_from_json, pG = i.credentials_new, uG = i.credentials_len, fG = i.credentials_get, gG = i.credentials_add, wG = i.__wbg_int_free, hG = i.int_to_bytes, bG = i.int_from_bytes, yG = i.int_to_hex, vG = i.int_from_hex, mG = i.int_to_json, kG = i.int_to_js_value, xG = i.int_from_json, EG = i.int_new, CG = i.int_new_negative, SG = i.int_new_i32, TG = i.int_is_positive, jG = i.int_as_positive, AG = i.int_as_negative, IG = i.int_as_i32, BG = i.int_as_i32_or_nothing, RG = i.int_as_i32_or_fail, NG = i.int_to_str, LG = i.int_from_str, FG = i.__wbg_bignum_free, OG = i.bignum_to_bytes, UG = i.bignum_from_bytes, zG = i.bignum_to_hex, DG = i.bignum_from_hex, PG = i.bignum_to_json, VG = i.bignum_to_js_value, MG = i.bignum_from_json, KG = i.bignum_from_str, qG = i.bignum_to_str, HG = i.bignum_zero, GG = i.bignum_one, WG = i.bignum_is_zero, QG = i.bignum_div_floor, $G = i.bignum_checked_mul, YG = i.bignum_checked_add, XG = i.bignum_checked_sub, JG = i.bignum_clamped_sub, ZG = i.bignum_compare, tW = i.bignum_less_than, eW = i.bignum_max_value, rW = i.bignum_max, _W = i.__wbg_scriptref_free, nW = i.scriptref_to_bytes, aW = i.scriptref_from_bytes, oW = i.scriptref_to_hex, sW = i.scriptref_from_hex, iW = i.scriptref_to_json, cW = i.scriptref_to_js_value, dW = i.scriptref_from_json, lW = i.scriptref_new_native_script, pW = i.scriptref_new_plutus_script, uW = i.scriptref_is_native_script, fW = i.scriptref_is_plutus_script, gW = i.scriptref_native_script, wW = i.scriptref_plutus_script, hW = i.scriptref_to_unwrapped_bytes, bW = i.__wbindgen_malloc, yW = i.__wbindgen_realloc, vW = i.__wbindgen_add_to_stack_pointer, mW = i.__wbindgen_free, kW = i.__wbindgen_exn_store, xW = Object.freeze(Object.defineProperty({
        __proto__: null,
        __wbg_address_free: M8,
        __wbg_anchor_free: TC,
        __wbg_anchordatahash_free: Lz,
        __wbg_assetname_free: x1,
        __wbg_assetnames_free: N1,
        __wbg_assets_free: H1,
        __wbg_auxiliarydata_free: U6,
        __wbg_auxiliarydatahash_free: ED,
        __wbg_auxiliarydataset_free: h1,
        __wbg_baseaddress_free: rB,
        __wbg_bigint_free: iR,
        __wbg_bignum_free: FG,
        __wbg_bip32privatekey_free: $N,
        __wbg_bip32publickey_free: Lh,
        __wbg_block_free: US,
        __wbg_blockhash_free: TD,
        __wbg_bootstrapwitness_free: sE,
        __wbg_bootstrapwitnesses_free: Cw,
        __wbg_byronaddress_free: A8,
        __wbg_certificate_free: lO,
        __wbg_certificates_free: Yj,
        __wbg_certificatesbuilder_free: yj,
        __wbg_changeconfig_free: AP,
        __wbg_committee_free: BM,
        __wbg_committeecoldresign_free: q9,
        __wbg_committeehotauth_free: Xf,
        __wbg_constitution_free: W5,
        __wbg_constrplutusdata_free: Fk,
        __wbg_costmdls_free: YU,
        __wbg_costmodel_free: qM,
        __wbg_credential_free: ew,
        __wbg_credentials_free: nG,
        __wbg_datacost_free: Rb,
        __wbg_datahash_free: jD,
        __wbg_datumsource_free: Hq,
        __wbg_dnsrecordaoraaaa_free: u4,
        __wbg_dnsrecordsrv_free: l4,
        __wbg_drep_free: $w,
        __wbg_drepderegistration_free: Qq,
        __wbg_drepregistration_free: _N,
        __wbg_drepupdate_free: oH,
        __wbg_drepvotingthresholds_free: ux,
        __wbg_ed25519keyhash_free: Ez,
        __wbg_ed25519keyhashes_free: dz,
        __wbg_ed25519signature_free: vE,
        __wbg_enterpriseaddress_free: cB,
        __wbg_exunitprices_free: Z4,
        __wbg_exunits_free: rK,
        __wbg_fixedblock_free: XS,
        __wbg_fixedtransaction_free: WI,
        __wbg_fixedtransactionbodies_free: WR,
        __wbg_fixedtransactionbody_free: BR,
        __wbg_fixedtxwitnessesset_free: KB,
        __wbg_fixedversionedblock_free: YE,
        __wbg_generaltransactionmetadata_free: E6,
        __wbg_genesisdelegatehash_free: kD,
        __wbg_genesishash_free: xD,
        __wbg_genesishashes_free: jm,
        __wbg_genesiskeydelegation_free: aU,
        __wbg_governanceaction_free: IH,
        __wbg_governanceactionid_free: zC,
        __wbg_governanceactionids_free: jN,
        __wbg_hardforkinitiationaction_free: d5,
        __wbg_header_free: oT,
        __wbg_headerbody_free: HL,
        __wbg_infoaction_free: ON,
        __wbg_int_free: wG,
        __wbg_ipv4_free: ry,
        __wbg_ipv6_free: py,
        __wbg_kessignature_free: h7,
        __wbg_kesvkey_free: BD,
        __wbg_language_free: Kg,
        __wbg_languages_free: W4,
        __wbg_legacydaedalusprivatekey_free: Fh,
        __wbg_linearfee_free: D4,
        __wbg_malformedaddress_free: C8,
        __wbg_metadatalist_free: H2,
        __wbg_metadatamap_free: R2,
        __wbg_mint_free: A0,
        __wbg_mintassets_free: E0,
        __wbg_mintbuilder_free: eI,
        __wbg_mintsassets_free: b0,
        __wbg_mintwitness_free: JA,
        __wbg_mirtostakecredentials_free: Up,
        __wbg_moveinstantaneousreward_free: Yp,
        __wbg_moveinstantaneousrewardscert_free: Tp,
        __wbg_multiasset_free: n0,
        __wbg_multihostname_free: p4,
        __wbg_nativescript_free: v7,
        __wbg_nativescripts_free: YB,
        __wbg_nativescriptsource_free: LF,
        __wbg_networkid_free: q0,
        __wbg_networkinfo_free: b8,
        __wbg_newconstitutionaction_free: aS,
        __wbg_noconfidenceaction_free: yH,
        __wbg_nonce_free: Dh,
        __wbg_operationalcert_free: UE,
        __wbg_outputdatum_free: pm,
        __wbg_parameterchangeaction_free: $C,
        __wbg_plutusdata_free: e2,
        __wbg_plutuslist_free: m2,
        __wbg_plutusmap_free: Wk,
        __wbg_plutusmapvalues_free: Kk,
        __wbg_plutusscript_free: vA,
        __wbg_plutusscripts_free: zU,
        __wbg_plutusscriptsource_free: AF,
        __wbg_plutuswitness_free: pI,
        __wbg_plutuswitnesses_free: vI,
        __wbg_pointer_free: wB,
        __wbg_pointeraddress_free: CB,
        __wbg_poolmetadata_free: Lv,
        __wbg_poolmetadatahash_free: CD,
        __wbg_poolparams_free: Bu,
        __wbg_poolregistration_free: Gw,
        __wbg_poolretirement_free: m9,
        __wbg_poolvotingthresholds_free: nx,
        __wbg_privatekey_free: $B,
        __wbg_proposedprotocolparameterupdates_free: $m,
        __wbg_protocolparamupdate_free: Mx,
        __wbg_protocolversion_free: o1,
        __wbg_publickey_free: Uw,
        __wbg_publickeys_free: p7,
        __wbg_redeemer_free: ik,
        __wbg_redeemers_free: mk,
        __wbg_redeemertag_free: yh,
        __wbg_relay_free: yv,
        __wbg_relays_free: yu,
        __wbg_rewardaddress_free: l9,
        __wbg_rewardaddresses_free: qv,
        __wbg_scriptall_free: Z7,
        __wbg_scriptany_free: hF,
        __wbg_scriptdatahash_free: AD,
        __wbg_scripthash_free: vD,
        __wbg_scripthashes_free: B4,
        __wbg_scriptnofk_free: wL,
        __wbg_scriptpubkey_free: K7,
        __wbg_scriptref_free: _W,
        __wbg_singlehostaddr_free: Ky,
        __wbg_singlehostname_free: ev,
        __wbg_stakeandvotedelegation_free: _f,
        __wbg_stakedelegation_free: R9,
        __wbg_stakederegistration_free: hU,
        __wbg_stakeregistration_free: oh,
        __wbg_stakeregistrationanddelegation_free: gf,
        __wbg_stakevoteregistrationanddelegation_free: jf,
        __wbg_strings_free: ZH,
        __wbg_timelockexpiry_free: NL,
        __wbg_timelockstart_free: SF,
        __wbg_transaction_free: ob,
        __wbg_transactionbatch_free: MF,
        __wbg_transactionbatchlist_free: DF,
        __wbg_transactionbodies_free: OR,
        __wbg_transactionbody_free: uK,
        __wbg_transactionbuilder_free: LP,
        __wbg_transactionbuilderconfig_free: fP,
        __wbg_transactionbuilderconfigbuilder_free: gP,
        __wbg_transactionhash_free: mD,
        __wbg_transactioninput_free: fj,
        __wbg_transactioninputs_free: OA,
        __wbg_transactionmetadatum_free: t6,
        __wbg_transactionmetadatumlabels_free: w6,
        __wbg_transactionoutput_free: Fb,
        __wbg_transactionoutputamountbuilder_free: VI,
        __wbg_transactionoutputbuilder_free: LI,
        __wbg_transactionoutputs_free: vb,
        __wbg_transactionunspentoutput_free: hT,
        __wbg_transactionunspentoutputs_free: jT,
        __wbg_transactionwitnessset_free: pq,
        __wbg_transactionwitnesssets_free: RB,
        __wbg_treasurywithdrawals_free: kM,
        __wbg_treasurywithdrawalsaction_free: k5,
        __wbg_txinputsbuilder_free: GF,
        __wbg_unitinterval_free: Yh,
        __wbg_update_free: hm,
        __wbg_updatecommitteeaction_free: L5,
        __wbg_url_free: d4,
        __wbg_value_free: OT,
        __wbg_versionedblock_free: eC,
        __wbg_vkey_free: TE,
        __wbg_vkeys_free: EF,
        __wbg_vkeywitness_free: zN,
        __wbg_vkeywitnesses_free: gw,
        __wbg_votedelegation_free: Qw,
        __wbg_voter_free: Sg,
        __wbg_voteregistrationanddelegation_free: Ww,
        __wbg_voters_free: IU,
        __wbg_votingbuilder_free: Bj,
        __wbg_votingprocedure_free: hN,
        __wbg_votingprocedures_free: dM,
        __wbg_votingproposal_free: hS,
        __wbg_votingproposalbuilder_free: Vj,
        __wbg_votingproposals_free: iA,
        __wbg_vrfcert_free: Nq,
        __wbg_vrfkeyhash_free: SD,
        __wbg_vrfvkey_free: ID,
        __wbg_withdrawals_free: em,
        __wbg_withdrawalsbuilder_free: EI,
        __wbindgen_add_to_stack_pointer: vW,
        __wbindgen_exn_store: kW,
        __wbindgen_free: mW,
        __wbindgen_malloc: bW,
        __wbindgen_realloc: yW,
        address_from_bech32: tB,
        address_from_bytes: K8,
        address_from_hex: X8,
        address_from_json: G8,
        address_is_malformed: $8,
        address_kind: W8,
        address_network_id: eB,
        address_payment_cred: Q8,
        address_to_bech32: Z8,
        address_to_bytes: J8,
        address_to_hex: Y8,
        address_to_js_value: H8,
        address_to_json: q8,
        anchor_anchor_data_hash: OC,
        anchor_from_bytes: AC,
        anchor_from_hex: BC,
        anchor_from_json: LC,
        anchor_new: UC,
        anchor_to_bytes: jC,
        anchor_to_hex: IC,
        anchor_to_js_value: NC,
        anchor_to_json: RC,
        anchor_url: FC,
        anchordatahash_from_bech32: zz,
        anchordatahash_from_bytes: Fz,
        anchordatahash_from_hex: Pz,
        anchordatahash_to_bech32: Uz,
        anchordatahash_to_bytes: Oz,
        anchordatahash_to_hex: Dz,
        assetname_from_bytes: C1,
        assetname_from_hex: T1,
        assetname_from_json: I1,
        assetname_name: R1,
        assetname_new: B1,
        assetname_to_bytes: E1,
        assetname_to_hex: S1,
        assetname_to_js_value: A1,
        assetname_to_json: j1,
        assetnames_add: q1,
        assetnames_from_bytes: F1,
        assetnames_from_hex: U1,
        assetnames_from_json: P1,
        assetnames_get: K1,
        assetnames_len: M1,
        assetnames_new: V1,
        assetnames_to_bytes: L1,
        assetnames_to_hex: O1,
        assetnames_to_js_value: D1,
        assetnames_to_json: z1,
        assets_from_bytes: W1,
        assets_from_hex: $1,
        assets_from_json: J1,
        assets_get: r0,
        assets_insert: e0,
        assets_keys: _0,
        assets_len: t0,
        assets_new: Z1,
        assets_to_bytes: G1,
        assets_to_hex: Q1,
        assets_to_js_value: X1,
        assets_to_json: Y1,
        auxiliarydata_from_bytes: D6,
        auxiliarydata_from_hex: V6,
        auxiliarydata_from_json: q6,
        auxiliarydata_metadata: G6,
        auxiliarydata_native_scripts: Q6,
        auxiliarydata_new: H6,
        auxiliarydata_plutus_scripts: Y6,
        auxiliarydata_prefer_alonzo_format: J6,
        auxiliarydata_set_metadata: W6,
        auxiliarydata_set_native_scripts: $6,
        auxiliarydata_set_plutus_scripts: X6,
        auxiliarydata_set_prefer_alonzo_format: Z6,
        auxiliarydata_to_bytes: z6,
        auxiliarydata_to_hex: P6,
        auxiliarydata_to_js_value: K6,
        auxiliarydata_to_json: M6,
        auxiliarydatahash_from_bech32: Xz,
        auxiliarydatahash_from_bytes: Yz,
        auxiliarydatahash_from_hex: Jz,
        auxiliarydatahash_to_bech32: iP,
        auxiliarydatahash_to_bytes: YD,
        auxiliarydatahash_to_hex: OD,
        auxiliarydataset_get: m1,
        auxiliarydataset_indices: k1,
        auxiliarydataset_insert: v1,
        auxiliarydataset_len: y1,
        auxiliarydataset_new: b1,
        baseaddress_from_address: sB,
        baseaddress_network_id: iB,
        baseaddress_new: _B,
        baseaddress_payment_cred: nB,
        baseaddress_stake_cred: aB,
        baseaddress_to_address: oB,
        bigint_abs: TR,
        bigint_add: mR,
        bigint_as_int: bR,
        bigint_as_u64: hR,
        bigint_div_ceil: AR,
        bigint_div_floor: IR,
        bigint_from_bytes: dR,
        bigint_from_hex: pR,
        bigint_from_json: gR,
        bigint_from_str: yR,
        bigint_increment: jR,
        bigint_is_zero: wR,
        bigint_mul: xR,
        bigint_one: CR,
        bigint_pow: ER,
        bigint_sub: kR,
        bigint_to_bytes: cR,
        bigint_to_hex: lR,
        bigint_to_js_value: fR,
        bigint_to_json: uR,
        bigint_to_str: vR,
        bigint_zero: SR,
        bignum_checked_add: YG,
        bignum_checked_mul: $G,
        bignum_checked_sub: XG,
        bignum_clamped_sub: JG,
        bignum_compare: ZG,
        bignum_div_floor: QG,
        bignum_from_bytes: UG,
        bignum_from_hex: DG,
        bignum_from_json: MG,
        bignum_from_str: KG,
        bignum_is_zero: WG,
        bignum_less_than: tW,
        bignum_max: rW,
        bignum_max_value: eW,
        bignum_one: GG,
        bignum_to_bytes: OG,
        bignum_to_hex: zG,
        bignum_to_js_value: VG,
        bignum_to_json: PG,
        bignum_to_str: qG,
        bignum_zero: HG,
        bip32privatekey_as_bytes: _7,
        bip32privatekey_chaincode: s7,
        bip32privatekey_derive: YN,
        bip32privatekey_from_128_xprv: XN,
        bip32privatekey_from_bech32: n7,
        bip32privatekey_from_bip39_entropy: o7,
        bip32privatekey_from_bytes: r7,
        bip32privatekey_from_hex: c7,
        bip32privatekey_generate_ed25519_bip32: ZN,
        bip32privatekey_to_128_xprv: JN,
        bip32privatekey_to_bech32: a7,
        bip32privatekey_to_hex: i7,
        bip32privatekey_to_public: e7,
        bip32privatekey_to_raw_key: t7,
        bip32publickey_as_bytes: o4,
        bip32publickey_chaincode: _4,
        bip32publickey_derive: c4,
        bip32publickey_from_bech32: a4,
        bip32publickey_from_bytes: s4,
        bip32publickey_from_hex: e4,
        bip32publickey_to_bech32: n4,
        bip32publickey_to_hex: r4,
        bip32publickey_to_raw_key: i4,
        block_auxiliary_data_set: QS,
        block_from_bytes: DS,
        block_from_hex: VS,
        block_from_json: qS,
        block_header: HS,
        block_invalid_transactions: $S,
        block_new: YS,
        block_to_bytes: zS,
        block_to_hex: PS,
        block_to_js_value: KS,
        block_to_json: MS,
        block_transaction_bodies: GS,
        block_transaction_witness_sets: WS,
        blockhash_from_bech32: oD,
        blockhash_from_bytes: aD,
        blockhash_from_hex: sD,
        blockhash_to_bech32: cP,
        blockhash_to_bytes: XD,
        blockhash_to_hex: DD,
        bootstrapwitness_attributes: bE,
        bootstrapwitness_chain_code: hE,
        bootstrapwitness_from_bytes: cE,
        bootstrapwitness_from_hex: lE,
        bootstrapwitness_from_json: fE,
        bootstrapwitness_new: yE,
        bootstrapwitness_signature: wE,
        bootstrapwitness_to_bytes: iE,
        bootstrapwitness_to_hex: dE,
        bootstrapwitness_to_js_value: uE,
        bootstrapwitness_to_json: pE,
        bootstrapwitness_vkey: gE,
        bootstrapwitnesses_add: Ow,
        bootstrapwitnesses_from_bytes: Tw,
        bootstrapwitnesses_from_hex: Aw,
        bootstrapwitnesses_from_json: Rw,
        bootstrapwitnesses_get: Fw,
        bootstrapwitnesses_len: Lw,
        bootstrapwitnesses_new: Nw,
        bootstrapwitnesses_to_bytes: Sw,
        bootstrapwitnesses_to_hex: jw,
        bootstrapwitnesses_to_js_value: Bw,
        bootstrapwitnesses_to_json: Iw,
        byronaddress_attributes: F8,
        byronaddress_byron_address_kind: L8,
        byronaddress_byron_protocol_magic: N8,
        byronaddress_from_address: V8,
        byronaddress_from_base58: U8,
        byronaddress_from_bytes: R8,
        byronaddress_icarus_from_key: z8,
        byronaddress_is_valid: D8,
        byronaddress_network_id: O8,
        byronaddress_to_address: P8,
        byronaddress_to_base58: I8,
        byronaddress_to_bytes: B8,
        calculate_ex_units_ceil_cost: q4,
        certificate_as_committee_cold_resign: $O,
        certificate_as_committee_hot_auth: QO,
        certificate_as_drep_deregistration: YO,
        certificate_as_drep_registration: XO,
        certificate_as_drep_update: JO,
        certificate_as_genesis_key_delegation: GO,
        certificate_as_move_instantaneous_rewards_cert: WO,
        certificate_as_pool_registration: qO,
        certificate_as_pool_retirement: HO,
        certificate_as_reg_cert: PO,
        certificate_as_stake_and_vote_delegation: ZO,
        certificate_as_stake_delegation: KO,
        certificate_as_stake_deregistration: VO,
        certificate_as_stake_registration: DO,
        certificate_as_stake_registration_and_delegation: tU,
        certificate_as_stake_vote_registration_and_delegation: eU,
        certificate_as_unreg_cert: MO,
        certificate_as_vote_delegation: rU,
        certificate_as_vote_registration_and_delegation: _U,
        certificate_from_bytes: uO,
        certificate_from_hex: gO,
        certificate_from_json: bO,
        certificate_has_required_script_witness: nU,
        certificate_kind: zO,
        certificate_new_committee_cold_resign: AO,
        certificate_new_committee_hot_auth: jO,
        certificate_new_drep_deregistration: IO,
        certificate_new_drep_registration: BO,
        certificate_new_drep_update: RO,
        certificate_new_genesis_key_delegation: SO,
        certificate_new_move_instantaneous_rewards_cert: TO,
        certificate_new_pool_registration: EO,
        certificate_new_pool_retirement: CO,
        certificate_new_reg_cert: vO,
        certificate_new_stake_and_vote_delegation: NO,
        certificate_new_stake_delegation: xO,
        certificate_new_stake_deregistration: mO,
        certificate_new_stake_registration: yO,
        certificate_new_stake_registration_and_delegation: LO,
        certificate_new_stake_vote_registration_and_delegation: FO,
        certificate_new_unreg_cert: kO,
        certificate_new_vote_delegation: OO,
        certificate_new_vote_registration_and_delegation: UO,
        certificate_to_bytes: pO,
        certificate_to_hex: fO,
        certificate_to_js_value: hO,
        certificate_to_json: wO,
        certificates_add: sA,
        certificates_from_bytes: Jj,
        certificates_from_hex: tA,
        certificates_from_json: _A,
        certificates_get: oA,
        certificates_len: aA,
        certificates_new: nA,
        certificates_to_bytes: Xj,
        certificates_to_hex: Zj,
        certificates_to_js_value: rA,
        certificates_to_json: eA,
        certificatesbuilder_add: mj,
        certificatesbuilder_add_with_native_script: xj,
        certificatesbuilder_add_with_plutus_witness: kj,
        certificatesbuilder_build: Ij,
        certificatesbuilder_get_certificates_deposit: jj,
        certificatesbuilder_get_certificates_refund: Tj,
        certificatesbuilder_get_native_scripts: Sj,
        certificatesbuilder_get_plutus_witnesses: Ej,
        certificatesbuilder_get_ref_inputs: Cj,
        certificatesbuilder_has_plutus_scripts: Aj,
        certificatesbuilder_new: vj,
        changeconfig_change_address: BP,
        changeconfig_change_plutus_data: RP,
        changeconfig_change_script_ref: NP,
        changeconfig_new: IP,
        committee_add_member: MM,
        committee_from_bytes: NM,
        committee_from_hex: FM,
        committee_from_json: zM,
        committee_get_member_epoch: KM,
        committee_members_keys: PM,
        committee_new: DM,
        committee_quorum_threshold: VM,
        committee_to_bytes: RM,
        committee_to_hex: LM,
        committee_to_js_value: UM,
        committee_to_json: OM,
        committeecoldresign_anchor: Z9,
        committeecoldresign_committee_cold_credential: J9,
        committeecoldresign_from_bytes: G9,
        committeecoldresign_from_hex: Q9,
        committeecoldresign_from_json: X9,
        committeecoldresign_has_script_credentials: rN,
        committeecoldresign_new: tN,
        committeecoldresign_new_with_anchor: eN,
        committeecoldresign_to_bytes: H9,
        committeecoldresign_to_hex: W9,
        committeecoldresign_to_js_value: Y9,
        committeecoldresign_to_json: $9,
        committeehotauth_committee_cold_credential: ag,
        committeehotauth_committee_hot_credential: og,
        committeehotauth_from_bytes: Zf,
        committeehotauth_from_hex: eg,
        committeehotauth_from_json: ng,
        committeehotauth_has_script_credentials: ig,
        committeehotauth_new: sg,
        committeehotauth_to_bytes: Jf,
        committeehotauth_to_hex: tg,
        committeehotauth_to_js_value: _g,
        committeehotauth_to_json: rg,
        constitution_anchor: eS,
        constitution_from_bytes: $5,
        constitution_from_hex: X5,
        constitution_from_json: tS,
        constitution_new: _S,
        constitution_new_with_script_hash: nS,
        constitution_script_hash: rS,
        constitution_to_bytes: Q5,
        constitution_to_hex: Y5,
        constitution_to_js_value: Z5,
        constitution_to_json: J5,
        constrplutusdata_alternative: Pk,
        constrplutusdata_data: Vk,
        constrplutusdata_from_bytes: Uk,
        constrplutusdata_from_hex: Dk,
        constrplutusdata_new: Mk,
        constrplutusdata_to_bytes: Ok,
        constrplutusdata_to_hex: zk,
        costmdls_from_bytes: JU,
        costmdls_from_hex: tz,
        costmdls_from_json: _z,
        costmdls_get: sz,
        costmdls_insert: oz,
        costmdls_keys: iz,
        costmdls_len: az,
        costmdls_new: nz,
        costmdls_retain_language_versions: cz,
        costmdls_to_bytes: XU,
        costmdls_to_hex: ZU,
        costmdls_to_js_value: rz,
        costmdls_to_json: ez,
        costmodel_from_bytes: GM,
        costmodel_from_hex: QM,
        costmodel_from_json: XM,
        costmodel_get: tK,
        costmodel_len: eK,
        costmodel_new: JM,
        costmodel_set: ZM,
        costmodel_to_bytes: HM,
        costmodel_to_hex: WM,
        costmodel_to_js_value: YM,
        costmodel_to_json: $M,
        create_send_all: HF,
        credential_from_bytes: cw,
        credential_from_hex: lw,
        credential_from_json: fw,
        credential_from_keyhash: rw,
        credential_from_scripthash: _w,
        credential_has_script_hash: sw,
        credential_kind: ow,
        credential_to_bytes: iw,
        credential_to_hex: dw,
        credential_to_js_value: uw,
        credential_to_json: pw,
        credential_to_keyhash: nw,
        credential_to_scripthash: aw,
        credentials_add: gG,
        credentials_from_bytes: oG,
        credentials_from_hex: iG,
        credentials_from_json: lG,
        credentials_get: fG,
        credentials_len: uG,
        credentials_new: pG,
        credentials_to_bytes: aG,
        credentials_to_hex: sG,
        credentials_to_js_value: dG,
        credentials_to_json: cG,
        datacost_coins_per_byte: Lb,
        datacost_new_coins_per_byte: Nb,
        datahash_from_bech32: cD,
        datahash_from_bytes: iD,
        datahash_from_hex: dD,
        datahash_to_bech32: dP,
        datahash_to_bytes: JD,
        datahash_to_hex: PD,
        datumsource_new: Gq,
        datumsource_new_ref_input: Wq,
        decode_arbitrary_bytes_from_metadatum: ex,
        decode_metadatum_to_json_str: _x,
        decode_plutus_datum_to_json_str: B2,
        decrypt_with_password: $j,
        dnsrecordaoraaaa_from_bytes: Ay,
        dnsrecordaoraaaa_from_hex: By,
        dnsrecordaoraaaa_from_json: Ly,
        dnsrecordaoraaaa_new: Fy,
        dnsrecordaoraaaa_record: Oy,
        dnsrecordaoraaaa_to_bytes: jy,
        dnsrecordaoraaaa_to_hex: Iy,
        dnsrecordaoraaaa_to_js_value: Ny,
        dnsrecordaoraaaa_to_json: Ry,
        dnsrecordsrv_from_bytes: zy,
        dnsrecordsrv_from_hex: Py,
        dnsrecordsrv_from_json: Vy,
        dnsrecordsrv_new: My,
        dnsrecordsrv_record: E4,
        dnsrecordsrv_to_bytes: Uy,
        dnsrecordsrv_to_hex: Dy,
        dnsrecordsrv_to_js_value: I4,
        dnsrecordsrv_to_json: k4,
        drep_from_bech32: Cg,
        drep_from_bytes: dg,
        drep_from_hex: pg,
        drep_from_json: gg,
        drep_kind: mg,
        drep_new_always_abstain: bg,
        drep_new_always_no_confidence: yg,
        drep_new_from_credential: vg,
        drep_new_key_hash: wg,
        drep_new_script_hash: hg,
        drep_to_bech32: Eg,
        drep_to_bytes: cg,
        drep_to_hex: lg,
        drep_to_js_value: fg,
        drep_to_json: ug,
        drep_to_key_hash: kg,
        drep_to_script_hash: xg,
        drepderegistration_coin: _H,
        drepderegistration_from_bytes: Yq,
        drepderegistration_from_hex: Jq,
        drepderegistration_from_json: eH,
        drepderegistration_has_script_credentials: aH,
        drepderegistration_new: nH,
        drepderegistration_to_bytes: $q,
        drepderegistration_to_hex: Xq,
        drepderegistration_to_js_value: tH,
        drepderegistration_to_json: Zq,
        drepderegistration_voting_credential: rH,
        drepregistration_anchor: uN,
        drepregistration_coin: pN,
        drepregistration_from_bytes: aN,
        drepregistration_from_hex: sN,
        drepregistration_from_json: dN,
        drepregistration_has_script_credentials: wN,
        drepregistration_new: fN,
        drepregistration_new_with_anchor: gN,
        drepregistration_to_bytes: nN,
        drepregistration_to_hex: oN,
        drepregistration_to_js_value: cN,
        drepregistration_to_json: iN,
        drepregistration_voting_credential: lN,
        drepupdate_anchor: gH,
        drepupdate_from_bytes: iH,
        drepupdate_from_hex: dH,
        drepupdate_from_json: uH,
        drepupdate_has_script_credentials: bH,
        drepupdate_new: wH,
        drepupdate_new_with_anchor: hH,
        drepupdate_to_bytes: sH,
        drepupdate_to_hex: cH,
        drepupdate_to_js_value: pH,
        drepupdate_to_json: lH,
        drepupdate_voting_credential: fH,
        drepvotingthresholds_committee_no_confidence: Lx,
        drepvotingthresholds_committee_normal: Nx,
        drepvotingthresholds_from_bytes: gx,
        drepvotingthresholds_from_hex: hx,
        drepvotingthresholds_from_json: vx,
        drepvotingthresholds_hard_fork_initiation: Ox,
        drepvotingthresholds_motion_no_confidence: Rx,
        drepvotingthresholds_new: mx,
        drepvotingthresholds_pp_economic_group: zx,
        drepvotingthresholds_pp_governance_group: Px,
        drepvotingthresholds_pp_network_group: Ux,
        drepvotingthresholds_pp_technical_group: Dx,
        drepvotingthresholds_set_committee_no_confidence: Ex,
        drepvotingthresholds_set_committee_normal: xx,
        drepvotingthresholds_set_hard_fork_initiation: Sx,
        drepvotingthresholds_set_motion_no_confidence: kx,
        drepvotingthresholds_set_pp_economic_group: jx,
        drepvotingthresholds_set_pp_governance_group: Ix,
        drepvotingthresholds_set_pp_network_group: Tx,
        drepvotingthresholds_set_pp_technical_group: Ax,
        drepvotingthresholds_set_treasury_withdrawal: Bx,
        drepvotingthresholds_set_update_constitution: Cx,
        drepvotingthresholds_to_bytes: fx,
        drepvotingthresholds_to_hex: wx,
        drepvotingthresholds_to_js_value: yx,
        drepvotingthresholds_to_json: bx,
        drepvotingthresholds_treasury_withdrawal: Vx,
        drepvotingthresholds_update_constitution: Fx,
        ed25519keyhash_from_bech32: jz,
        ed25519keyhash_from_bytes: Cz,
        ed25519keyhash_from_hex: Iz,
        ed25519keyhash_to_bech32: Tz,
        ed25519keyhash_to_bytes: Sz,
        ed25519keyhash_to_hex: Az,
        ed25519keyhashes_add: mz,
        ed25519keyhashes_contains: kz,
        ed25519keyhashes_from_bytes: pz,
        ed25519keyhashes_from_hex: fz,
        ed25519keyhashes_from_json: hz,
        ed25519keyhashes_get: vz,
        ed25519keyhashes_len: yz,
        ed25519keyhashes_new: bz,
        ed25519keyhashes_to_bytes: lz,
        ed25519keyhashes_to_hex: uz,
        ed25519keyhashes_to_js_value: wz,
        ed25519keyhashes_to_json: gz,
        ed25519keyhashes_to_option: xz,
        ed25519signature_from_bech32: EE,
        ed25519signature_from_bytes: SE,
        ed25519signature_from_hex: CE,
        ed25519signature_to_bech32: kE,
        ed25519signature_to_bytes: mE,
        ed25519signature_to_hex: xE,
        encode_arbitrary_bytes_as_metadatum: tx,
        encode_json_str_to_metadatum: rx,
        encode_json_str_to_native_script: pj,
        encode_json_str_to_plutus_datum: I2,
        encrypt_with_password: Qj,
        enterpriseaddress_from_address: pB,
        enterpriseaddress_network_id: uB,
        enterpriseaddress_new: dB,
        enterpriseaddress_payment_cred: p9,
        enterpriseaddress_to_address: lB,
        exunitprices_from_bytes: ek,
        exunitprices_from_hex: _k,
        exunitprices_from_json: ok,
        exunitprices_mem_price: fC,
        exunitprices_new: sk,
        exunitprices_step_price: gC,
        exunitprices_to_bytes: tk,
        exunitprices_to_hex: rk,
        exunitprices_to_js_value: ak,
        exunitprices_to_json: nk,
        exunits_from_bytes: nK,
        exunits_from_hex: oK,
        exunits_from_json: cK,
        exunits_mem: dK,
        exunits_new: pK,
        exunits_steps: lK,
        exunits_to_bytes: _K,
        exunits_to_hex: aK,
        exunits_to_js_value: iK,
        exunits_to_json: sK,
        fixedblock_auxiliary_data_set: _T,
        fixedblock_block_hash: aT,
        fixedblock_from_bytes: JS,
        fixedblock_from_hex: ZS,
        fixedblock_header: tT,
        fixedblock_invalid_transactions: nT,
        fixedblock_transaction_bodies: eT,
        fixedblock_transaction_witness_sets: rT,
        fixedtransaction_add_bootstrap_witness: f8,
        fixedtransaction_add_vkey_witness: u8,
        fixedtransaction_auxiliary_data: d8,
        fixedtransaction_body: e8,
        fixedtransaction_from_bytes: $I,
        fixedtransaction_from_hex: XI,
        fixedtransaction_is_valid: i8,
        fixedtransaction_new: JI,
        fixedtransaction_new_from_body_bytes: t8,
        fixedtransaction_new_with_auxiliary: ZI,
        fixedtransaction_raw_auxiliary_data: l8,
        fixedtransaction_raw_body: r8,
        fixedtransaction_raw_witness_set: o8,
        fixedtransaction_set_auxiliary_data: c8,
        fixedtransaction_set_body: _8,
        fixedtransaction_set_is_valid: s8,
        fixedtransaction_set_witness_set: n8,
        fixedtransaction_sign_and_add_daedalus_bootstrap_signature: h8,
        fixedtransaction_sign_and_add_icarus_bootstrap_signature: w8,
        fixedtransaction_sign_and_add_vkey_signature: g8,
        fixedtransaction_to_bytes: QI,
        fixedtransaction_to_hex: YI,
        fixedtransaction_transaction_hash: p8,
        fixedtransaction_witness_set: a8,
        fixedtransactionbodies_add: ZR,
        fixedtransactionbodies_from_bytes: QR,
        fixedtransactionbodies_from_hex: $R,
        fixedtransactionbodies_get: JR,
        fixedtransactionbodies_len: XR,
        fixedtransactionbodies_new: YR,
        fixedtransactionbody_from_bytes: RR,
        fixedtransactionbody_from_hex: NR,
        fixedtransactionbody_original_bytes: FR,
        fixedtransactionbody_transaction_body: f9,
        fixedtransactionbody_tx_hash: LR,
        fixedtxwitnessesset_add_bootstrap_witness: GB,
        fixedtxwitnessesset_add_vkey_witness: HB,
        fixedtxwitnessesset_from_bytes: QB,
        fixedtxwitnessesset_to_bytes: WB,
        fixedtxwitnessesset_tx_witnesses_set: qB,
        fixedversionedblock_block: ZE,
        fixedversionedblock_era: tC,
        fixedversionedblock_from_bytes: XE,
        fixedversionedblock_from_hex: JE,
        generaltransactionmetadata_from_bytes: S6,
        generaltransactionmetadata_from_hex: j6,
        generaltransactionmetadata_from_json: B6,
        generaltransactionmetadata_get: F6,
        generaltransactionmetadata_insert: L6,
        generaltransactionmetadata_keys: O6,
        generaltransactionmetadata_len: N6,
        generaltransactionmetadata_new: R6,
        generaltransactionmetadata_to_bytes: C6,
        generaltransactionmetadata_to_hex: T6,
        generaltransactionmetadata_to_js_value: I6,
        generaltransactionmetadata_to_json: A6,
        genesisdelegatehash_from_bech32: Hz,
        genesisdelegatehash_from_bytes: qz,
        genesisdelegatehash_from_hex: Gz,
        genesisdelegatehash_to_bech32: nP,
        genesisdelegatehash_to_bytes: GD,
        genesisdelegatehash_to_hex: LD,
        genesishash_from_bech32: Qz,
        genesishash_from_bytes: Wz,
        genesishash_from_hex: $z,
        genesishash_to_bech32: aP,
        genesishash_to_bytes: WD,
        genesishash_to_hex: FD,
        genesishashes_add: Dm,
        genesishashes_from_bytes: Im,
        genesishashes_from_hex: Rm,
        genesishashes_from_json: Fm,
        genesishashes_get: zm,
        genesishashes_len: Um,
        genesishashes_new: Om,
        genesishashes_to_bytes: Am,
        genesishashes_to_hex: Bm,
        genesishashes_to_js_value: Lm,
        genesishashes_to_json: Nm,
        genesiskeydelegation_from_bytes: sU,
        genesiskeydelegation_from_hex: cU,
        genesiskeydelegation_from_json: pU,
        genesiskeydelegation_genesis_delegate_hash: fU,
        genesiskeydelegation_genesishash: uU,
        genesiskeydelegation_new: wU,
        genesiskeydelegation_to_bytes: oU,
        genesiskeydelegation_to_hex: iU,
        genesiskeydelegation_to_js_value: lU,
        genesiskeydelegation_to_json: dU,
        genesiskeydelegation_vrf_keyhash: gU,
        get_deposit: dj,
        get_implicit_input: cj,
        governanceaction_as_hard_fork_initiation_action: WH,
        governanceaction_as_info_action: JH,
        governanceaction_as_new_committee_action: YH,
        governanceaction_as_new_constitution_action: XH,
        governanceaction_as_no_confidence_action: $H,
        governanceaction_as_parameter_change_action: GH,
        governanceaction_as_treasury_withdrawals_action: QH,
        governanceaction_from_bytes: RH,
        governanceaction_from_hex: LH,
        governanceaction_from_json: UH,
        governanceaction_kind: HH,
        governanceaction_new_hard_fork_initiation_action: DH,
        governanceaction_new_info_action: qH,
        governanceaction_new_new_committee_action: MH,
        governanceaction_new_new_constitution_action: KH,
        governanceaction_new_no_confidence_action: VH,
        governanceaction_new_parameter_change_action: zH,
        governanceaction_new_treasury_withdrawals_action: PH,
        governanceaction_to_bytes: BH,
        governanceaction_to_hex: NH,
        governanceaction_to_js_value: OH,
        governanceaction_to_json: FH,
        governanceactionid_from_bytes: PC,
        governanceactionid_from_hex: MC,
        governanceactionid_from_json: HC,
        governanceactionid_index: WC,
        governanceactionid_new: QC,
        governanceactionid_to_bytes: DC,
        governanceactionid_to_hex: VC,
        governanceactionid_to_js_value: qC,
        governanceactionid_to_json: KC,
        governanceactionid_transaction_id: GC,
        governanceactionids_add: NN,
        governanceactionids_from_json: BN,
        governanceactionids_get: LN,
        governanceactionids_len: FN,
        governanceactionids_new: RN,
        governanceactionids_to_js_value: IN,
        governanceactionids_to_json: AN,
        hardforkinitiationaction_from_bytes: p5,
        hardforkinitiationaction_from_hex: f5,
        hardforkinitiationaction_from_json: h5,
        hardforkinitiationaction_gov_action_id: b5,
        hardforkinitiationaction_new: v5,
        hardforkinitiationaction_new_with_action_id: m5,
        hardforkinitiationaction_protocol_version: y5,
        hardforkinitiationaction_to_bytes: l5,
        hardforkinitiationaction_to_hex: u5,
        hardforkinitiationaction_to_js_value: w5,
        hardforkinitiationaction_to_json: g5,
        has_transaction_set_tag: uj,
        hash_auxiliary_data: oj,
        hash_plutus_data: sj,
        hash_script_data: ij,
        header_body_signature: gT,
        header_from_bytes: iT,
        header_from_hex: dT,
        header_from_json: uT,
        header_header_body: fT,
        header_new: wT,
        header_to_bytes: sT,
        header_to_hex: cT,
        header_to_js_value: pT,
        header_to_json: lT,
        headerbody_block_body_hash: lF,
        headerbody_block_body_size: dF,
        headerbody_block_number: ZL,
        headerbody_from_bytes: WL,
        headerbody_from_hex: $L,
        headerbody_from_json: JL,
        headerbody_has_nonce_and_leader_vrf: aF,
        headerbody_has_vrf_result: iF,
        headerbody_issuer_vkey: _F,
        headerbody_leader_vrf_or_nothing: sF,
        headerbody_new: fF,
        headerbody_new_headerbody: gF,
        headerbody_nonce_vrf_or_nothing: oF,
        headerbody_operational_cert: pF,
        headerbody_prev_hash: rF,
        headerbody_protocol_version: uF,
        headerbody_slot: tF,
        headerbody_slot_bignum: eF,
        headerbody_to_bytes: GL,
        headerbody_to_hex: QL,
        headerbody_to_js_value: XL,
        headerbody_to_json: YL,
        headerbody_vrf_result_or_nothing: cF,
        headerbody_vrf_vkey: nF,
        infoaction_new: UN,
        int_as_i32: IG,
        int_as_i32_or_fail: RG,
        int_as_i32_or_nothing: BG,
        int_as_negative: AG,
        int_as_positive: jG,
        int_from_bytes: bG,
        int_from_hex: vG,
        int_from_json: xG,
        int_from_str: LG,
        int_is_positive: TG,
        int_new: EG,
        int_new_i32: SG,
        int_new_negative: CG,
        int_to_bytes: hG,
        int_to_hex: yG,
        int_to_js_value: kG,
        int_to_json: mG,
        int_to_str: NG,
        ipv4_from_bytes: ny,
        ipv4_from_hex: oy,
        ipv4_from_json: cy,
        ipv4_ip: ly,
        ipv4_new: dy,
        ipv4_to_bytes: _y,
        ipv4_to_hex: ay,
        ipv4_to_js_value: iy,
        ipv4_to_json: sy,
        ipv6_from_bytes: fy,
        ipv6_from_hex: wy,
        ipv6_from_json: yy,
        ipv6_ip: my,
        ipv6_new: vy,
        ipv6_to_bytes: uy,
        ipv6_to_hex: gy,
        ipv6_to_js_value: by,
        ipv6_to_json: hy,
        kessignature_from_bytes: y7,
        kessignature_to_bytes: b7,
        kesvkey_from_bech32: bD,
        kesvkey_from_bytes: hD,
        kesvkey_from_hex: yD,
        kesvkey_to_bech32: uP,
        kesvkey_to_bytes: eP,
        kesvkey_to_hex: KD,
        language_from_bytes: Hg,
        language_from_hex: Wg,
        language_from_json: Yg,
        language_kind: tw,
        language_new_plutus_v1: Xg,
        language_new_plutus_v2: Jg,
        language_new_plutus_v3: Zg,
        language_to_bytes: qg,
        language_to_hex: Gg,
        language_to_js_value: $g,
        language_to_json: Qg,
        languages_add: X4,
        languages_get: Y4,
        languages_len: $4,
        languages_list: J4,
        languages_new: Q4,
        legacydaedalusprivatekey_as_bytes: Uh,
        legacydaedalusprivatekey_chaincode: zh,
        legacydaedalusprivatekey_from_bytes: Oh,
        linearfee_coefficient: V4,
        linearfee_constant: P4,
        linearfee_new: M4,
        make_daedalus_bootstrap_witness: _j,
        make_icarus_bootstrap_witness: nj,
        make_vkey_witness: aj,
        malformedaddress_from_address: j8,
        malformedaddress_original_bytes: S8,
        malformedaddress_to_address: T8,
        memory: Sp,
        metadatalist_add: Z2,
        metadatalist_from_bytes: W2,
        metadatalist_from_hex: $2,
        metadatalist_get: J2,
        metadatalist_len: X2,
        metadatalist_new: Y2,
        metadatalist_to_bytes: G2,
        metadatalist_to_hex: Q2,
        metadatamap_from_bytes: L2,
        metadatamap_from_hex: O2,
        metadatamap_get: P2,
        metadatamap_get_i32: M2,
        metadatamap_get_str: V2,
        metadatamap_has: K2,
        metadatamap_insert: U2,
        metadatamap_insert_i32: D2,
        metadatamap_insert_str: z2,
        metadatamap_keys: q2,
        metadatamap_len: vC,
        metadatamap_new: CC,
        metadatamap_to_bytes: N2,
        metadatamap_to_hex: F2,
        min_ada_for_output: lj,
        min_fee: K4,
        min_ref_script_fee: G4,
        min_script_fee: H4,
        mint_as_negative_multiasset: K0,
        mint_as_positive_multiasset: M0,
        mint_from_bytes: B0,
        mint_from_hex: N0,
        mint_from_json: O0,
        mint_get: P0,
        mint_insert: D0,
        mint_keys: V0,
        mint_len: z0,
        mint_new: z4,
        mint_new_from_entry: U0,
        mint_to_bytes: I0,
        mint_to_hex: R0,
        mint_to_js_value: F0,
        mint_to_json: L0,
        mintassets_get: T0,
        mintassets_insert: S0,
        mintassets_keys: j0,
        mintassets_len: b4,
        mintassets_new: S4,
        mintassets_new_from_entry: C0,
        mintbuilder_add_asset: _I,
        mintbuilder_build: aI,
        mintbuilder_get_native_scripts: oI,
        mintbuilder_get_plutus_witnesses: sI,
        mintbuilder_get_redeemers: cI,
        mintbuilder_get_ref_inputs: iI,
        mintbuilder_has_native_scripts: lI,
        mintbuilder_has_plutus_scripts: dI,
        mintbuilder_new: rI,
        mintbuilder_set_asset: nI,
        mintsassets_add: k0,
        mintsassets_from_json: m0,
        mintsassets_get: x0,
        mintsassets_len: v4,
        mintsassets_new: U4,
        mintsassets_to_js_value: v0,
        mintsassets_to_json: y0,
        mintwitness_new_native_script: ZA,
        mintwitness_new_plutus_script: tI,
        mirtostakecredentials_from_bytes: Dp,
        mirtostakecredentials_from_hex: Vp,
        mirtostakecredentials_from_json: qp,
        mirtostakecredentials_get: Qp,
        mirtostakecredentials_insert: Wp,
        mirtostakecredentials_keys: $p,
        mirtostakecredentials_len: Gp,
        mirtostakecredentials_new: Hp,
        mirtostakecredentials_to_bytes: zp,
        mirtostakecredentials_to_hex: Pp,
        mirtostakecredentials_to_js_value: Kp,
        mirtostakecredentials_to_json: Mp,
        moveinstantaneousreward_as_to_other_pot: iu,
        moveinstantaneousreward_as_to_stake_creds: cu,
        moveinstantaneousreward_from_bytes: Jp,
        moveinstantaneousreward_from_hex: tu,
        moveinstantaneousreward_from_json: _u,
        moveinstantaneousreward_kind: su,
        moveinstantaneousreward_new_to_other_pot: nu,
        moveinstantaneousreward_new_to_stake_creds: au,
        moveinstantaneousreward_pot: ou,
        moveinstantaneousreward_to_bytes: Xp,
        moveinstantaneousreward_to_hex: Zp,
        moveinstantaneousreward_to_js_value: ru,
        moveinstantaneousreward_to_json: eu,
        moveinstantaneousrewardscert_from_bytes: Ap,
        moveinstantaneousrewardscert_from_hex: Bp,
        moveinstantaneousrewardscert_from_json: Lp,
        moveinstantaneousrewardscert_move_instantaneous_reward: Fp,
        moveinstantaneousrewardscert_new: Op,
        moveinstantaneousrewardscert_to_bytes: jp,
        moveinstantaneousrewardscert_to_hex: Ip,
        moveinstantaneousrewardscert_to_js_value: Np,
        moveinstantaneousrewardscert_to_json: Rp,
        multiasset_from_bytes: o0,
        multiasset_from_hex: i0,
        multiasset_from_json: l0,
        multiasset_get: u0,
        multiasset_get_asset: g0,
        multiasset_insert: p0,
        multiasset_keys: w0,
        multiasset_len: h4,
        multiasset_new: C4,
        multiasset_set_asset: f0,
        multiasset_sub: h0,
        multiasset_to_bytes: a0,
        multiasset_to_hex: s0,
        multiasset_to_js_value: d0,
        multiasset_to_json: c0,
        multihostname_dns_name: bv,
        multihostname_from_bytes: pv,
        multihostname_from_hex: fv,
        multihostname_from_json: hv,
        multihostname_new: O4,
        multihostname_to_bytes: lv,
        multihostname_to_hex: uv,
        multihostname_to_js_value: wv,
        multihostname_to_json: gv,
        nativescript_as_script_all: U7,
        nativescript_as_script_any: z7,
        nativescript_as_script_n_of_k: D7,
        nativescript_as_script_pubkey: O7,
        nativescript_as_timelock_expiry: V7,
        nativescript_as_timelock_start: P7,
        nativescript_from_bytes: k7,
        nativescript_from_hex: E7,
        nativescript_from_json: T7,
        nativescript_get_required_signers: M7,
        nativescript_hash: j7,
        nativescript_kind: F7,
        nativescript_new_script_all: I7,
        nativescript_new_script_any: B7,
        nativescript_new_script_n_of_k: R7,
        nativescript_new_script_pubkey: A7,
        nativescript_new_timelock_expiry: L7,
        nativescript_new_timelock_start: N7,
        nativescript_to_bytes: m7,
        nativescript_to_hex: x7,
        nativescript_to_js_value: S7,
        nativescript_to_json: C7,
        nativescripts_add: tR,
        nativescripts_from_bytes: rR,
        nativescripts_from_hex: nR,
        nativescripts_from_json: sR,
        nativescripts_get: ZB,
        nativescripts_len: JB,
        nativescripts_new: XB,
        nativescripts_to_bytes: eR,
        nativescripts_to_hex: _R,
        nativescripts_to_js_value: oR,
        nativescripts_to_json: aR,
        nativescriptsource_get_ref_script_size: zF,
        nativescriptsource_new: FF,
        nativescriptsource_new_ref_input: OF,
        nativescriptsource_set_required_signers: UF,
        networkid_from_bytes: G0,
        networkid_from_hex: Q0,
        networkid_from_json: X0,
        networkid_kind: t4,
        networkid_mainnet: Z0,
        networkid_testnet: J0,
        networkid_to_bytes: H0,
        networkid_to_hex: W0,
        networkid_to_js_value: Y0,
        networkid_to_json: $0,
        networkinfo_mainnet: E8,
        networkinfo_network_id: v8,
        networkinfo_new: y8,
        networkinfo_protocol_magic: m8,
        networkinfo_testnet_preprod: x8,
        networkinfo_testnet_preview: k8,
        newconstitutionaction_constitution: uS,
        newconstitutionaction_from_bytes: sS,
        newconstitutionaction_from_hex: cS,
        newconstitutionaction_from_json: pS,
        newconstitutionaction_gov_action_id: wj,
        newconstitutionaction_has_script_hash: wS,
        newconstitutionaction_new: fS,
        newconstitutionaction_new_with_action_id: gS,
        newconstitutionaction_to_bytes: oS,
        newconstitutionaction_to_hex: iS,
        newconstitutionaction_to_js_value: lS,
        newconstitutionaction_to_json: dS,
        noconfidenceaction_from_bytes: mH,
        noconfidenceaction_from_hex: xH,
        noconfidenceaction_from_json: SH,
        noconfidenceaction_gov_action_id: TH,
        noconfidenceaction_new: jH,
        noconfidenceaction_new_with_action_id: AH,
        noconfidenceaction_to_bytes: vH,
        noconfidenceaction_to_hex: kH,
        noconfidenceaction_to_js_value: CH,
        noconfidenceaction_to_json: EH,
        nonce_from_bytes: Vh,
        nonce_from_hex: Kh,
        nonce_from_json: Gh,
        nonce_get_hash: $h,
        nonce_new_from_hash: Qh,
        nonce_new_identity: Wh,
        nonce_to_bytes: Ph,
        nonce_to_hex: Mh,
        nonce_to_js_value: Hh,
        nonce_to_json: qh,
        operationalcert_from_bytes: DE,
        operationalcert_from_hex: VE,
        operationalcert_from_json: qE,
        operationalcert_hot_vkey: HE,
        operationalcert_kes_period: WE,
        operationalcert_new: $E,
        operationalcert_sequence_number: GE,
        operationalcert_sigma: QE,
        operationalcert_to_bytes: zE,
        operationalcert_to_hex: PE,
        operationalcert_to_js_value: KE,
        operationalcert_to_json: ME,
        outputdatum_data: wm,
        outputdatum_data_hash: gm,
        outputdatum_new_data: fm,
        outputdatum_new_data_hash: um,
        parameterchangeaction_from_bytes: XC,
        parameterchangeaction_from_hex: ZC,
        parameterchangeaction_from_json: r5,
        parameterchangeaction_gov_action_id: _5,
        parameterchangeaction_new: o5,
        parameterchangeaction_new_with_action_id: s5,
        parameterchangeaction_new_with_policy_hash: i5,
        parameterchangeaction_new_with_policy_hash_and_action_id: c5,
        parameterchangeaction_policy_hash: a5,
        parameterchangeaction_protocol_param_updates: n5,
        parameterchangeaction_to_bytes: YC,
        parameterchangeaction_to_hex: JC,
        parameterchangeaction_to_js_value: e5,
        parameterchangeaction_to_json: t5,
        plutusdata_as_address: v2,
        plutusdata_as_bytes: b2,
        plutusdata_as_constr_plutus_data: f2,
        plutusdata_as_integer: h2,
        plutusdata_as_list: w2,
        plutusdata_as_map: g2,
        plutusdata_from_address: y2,
        plutusdata_from_bytes: _2,
        plutusdata_from_hex: a2,
        plutusdata_from_json: xC,
        plutusdata_kind: u2,
        plutusdata_new_bytes: p2,
        plutusdata_new_constr_plutus_data: o2,
        plutusdata_new_empty_constr_plutus_data: s2,
        plutusdata_new_integer: l2,
        plutusdata_new_list: d2,
        plutusdata_new_map: c2,
        plutusdata_new_single_value_constr_plutus_data: i2,
        plutusdata_to_bytes: r2,
        plutusdata_to_hex: n2,
        plutusdata_to_json: kC,
        plutuslist_add: A2,
        plutuslist_from_bytes: x2,
        plutuslist_from_hex: C2,
        plutuslist_get: j2,
        plutuslist_len: T2,
        plutuslist_new: S2,
        plutuslist_to_bytes: k2,
        plutuslist_to_hex: E2,
        plutusmap_from_bytes: $k,
        plutusmap_from_hex: Xk,
        plutusmap_get: Zk,
        plutusmap_insert: Jk,
        plutusmap_keys: t2,
        plutusmap_len: yC,
        plutusmap_new: EC,
        plutusmap_to_bytes: Qk,
        plutusmap_to_hex: Yk,
        plutusmapvalues_add: Gk,
        plutusmapvalues_get: Hk,
        plutusmapvalues_len: mC,
        plutusmapvalues_new: qk,
        plutusscript_bytes: AA,
        plutusscript_from_bytes: kA,
        plutusscript_from_bytes_v2: IA,
        plutusscript_from_bytes_v3: BA,
        plutusscript_from_bytes_with_version: RA,
        plutusscript_from_hex: EA,
        plutusscript_from_hex_with_version: NA,
        plutusscript_hash: LA,
        plutusscript_language_version: FA,
        plutusscript_new: CA,
        plutusscript_new_v2: SA,
        plutusscript_new_v3: TA,
        plutusscript_new_with_version: jA,
        plutusscript_to_bytes: mA,
        plutusscript_to_hex: xA,
        plutusscripts_add: $U,
        plutusscripts_from_bytes: PU,
        plutusscripts_from_hex: MU,
        plutusscripts_from_json: HU,
        plutusscripts_get: QU,
        plutusscripts_len: WU,
        plutusscripts_new: GU,
        plutusscripts_to_bytes: DU,
        plutusscripts_to_hex: VU,
        plutusscripts_to_js_value: qU,
        plutusscripts_to_json: KU,
        plutusscriptsource_get_ref_script_size: NF,
        plutusscriptsource_new: IF,
        plutusscriptsource_new_ref_input: BF,
        plutusscriptsource_set_required_signers: RF,
        plutuswitness_datum: bI,
        plutuswitness_new: uI,
        plutuswitness_new_with_ref: fI,
        plutuswitness_new_with_ref_without_datum: wI,
        plutuswitness_new_without_datum: gI,
        plutuswitness_redeemer: yI,
        plutuswitness_script: hI,
        plutuswitnesses_add: xI,
        plutuswitnesses_get: kI,
        plutuswitnesses_len: mI,
        plutuswitnesses_new: v9,
        pointer_cert_index: mB,
        pointer_cert_index_bignum: EB,
        pointer_new: hB,
        pointer_new_pointer: bB,
        pointer_slot: yB,
        pointer_slot_bignum: kB,
        pointer_tx_index: vB,
        pointer_tx_index_bignum: xB,
        pointeraddress_from_address: IB,
        pointeraddress_network_id: BB,
        pointeraddress_new: SB,
        pointeraddress_payment_cred: TB,
        pointeraddress_stake_pointer: jB,
        pointeraddress_to_address: AB,
        poolmetadata_from_bytes: Ov,
        poolmetadata_from_hex: zv,
        poolmetadata_from_json: Vv,
        poolmetadata_new: Kv,
        poolmetadata_pool_metadata_hash: Mv,
        poolmetadata_to_bytes: Fv,
        poolmetadata_to_hex: Uv,
        poolmetadata_to_js_value: Pv,
        poolmetadata_to_json: Dv,
        poolmetadata_url: N4,
        poolmetadatahash_from_bech32: tD,
        poolmetadatahash_from_bytes: Zz,
        poolmetadatahash_from_hex: eD,
        poolmetadatahash_to_bech32: sP,
        poolmetadatahash_to_bytes: $D,
        poolmetadatahash_to_hex: UD,
        poolparams_cost: Mu,
        poolparams_from_bytes: Nu,
        poolparams_from_hex: Fu,
        poolparams_from_json: zu,
        poolparams_margin: Ku,
        poolparams_new: Qu,
        poolparams_operator: Du,
        poolparams_pledge: Vu,
        poolparams_pool_metadata: Wu,
        poolparams_pool_owners: Hu,
        poolparams_relays: Gu,
        poolparams_reward_account: qu,
        poolparams_to_bytes: Ru,
        poolparams_to_hex: Lu,
        poolparams_to_js_value: Uu,
        poolparams_to_json: Ou,
        poolparams_vrf_keyhash: Pu,
        poolregistration_from_bytes: lu,
        poolregistration_from_hex: uu,
        poolregistration_from_json: wu,
        poolregistration_new: bu,
        poolregistration_pool_params: hu,
        poolregistration_to_bytes: du,
        poolregistration_to_hex: pu,
        poolregistration_to_js_value: gu,
        poolregistration_to_json: fu,
        poolretirement_epoch: I9,
        poolretirement_from_bytes: x9,
        poolretirement_from_hex: C9,
        poolretirement_from_json: j9,
        poolretirement_new: B9,
        poolretirement_pool_keyhash: A9,
        poolretirement_to_bytes: k9,
        poolretirement_to_hex: E9,
        poolretirement_to_js_value: T9,
        poolretirement_to_json: S9,
        poolvotingthresholds_committee_no_confidence: wC,
        poolvotingthresholds_committee_normal: uC,
        poolvotingthresholds_from_bytes: ox,
        poolvotingthresholds_from_hex: ix,
        poolvotingthresholds_from_json: lx,
        poolvotingthresholds_hard_fork_initiation: hC,
        poolvotingthresholds_motion_no_confidence: pC,
        poolvotingthresholds_new: px,
        poolvotingthresholds_security_relevant_threshold: bC,
        poolvotingthresholds_to_bytes: ax,
        poolvotingthresholds_to_hex: sx,
        poolvotingthresholds_to_js_value: dx,
        poolvotingthresholds_to_json: cx,
        privatekey_as_bytes: a9,
        privatekey_from_bech32: s9,
        privatekey_from_extended_bytes: n9,
        privatekey_from_hex: t9,
        privatekey_from_normal_bytes: _9,
        privatekey_generate_ed25519: c9,
        privatekey_generate_ed25519extended: i9,
        privatekey_sign: r9,
        privatekey_to_bech32: o9,
        privatekey_to_hex: e9,
        privatekey_to_public: d9,
        proposedprotocolparameterupdates_from_bytes: Xm,
        proposedprotocolparameterupdates_from_hex: Zm,
        proposedprotocolparameterupdates_from_json: r1,
        proposedprotocolparameterupdates_get: n1,
        proposedprotocolparameterupdates_insert: _1,
        proposedprotocolparameterupdates_keys: a1,
        proposedprotocolparameterupdates_len: w4,
        proposedprotocolparameterupdates_new: j4,
        proposedprotocolparameterupdates_to_bytes: Ym,
        proposedprotocolparameterupdates_to_hex: Jm,
        proposedprotocolparameterupdates_to_js_value: e1,
        proposedprotocolparameterupdates_to_json: t1,
        protocolparamupdate_ada_per_utxo_byte: T3,
        protocolparamupdate_collateral_percentage: D3,
        protocolparamupdate_committee_term_limit: $3,
        protocolparamupdate_cost_models: A3,
        protocolparamupdate_d: v3,
        protocolparamupdate_drep_deposit: eE,
        protocolparamupdate_drep_inactivity_period: _E,
        protocolparamupdate_drep_voting_thresholds: H3,
        protocolparamupdate_execution_costs: B3,
        protocolparamupdate_expansion_rate: h3,
        protocolparamupdate_extra_entropy: m3,
        protocolparamupdate_from_bytes: qx,
        protocolparamupdate_from_hex: Gx,
        protocolparamupdate_from_json: $x,
        protocolparamupdate_governance_action_deposit: Z3,
        protocolparamupdate_governance_action_validity_period: X3,
        protocolparamupdate_key_deposit: s3,
        protocolparamupdate_max_block_body_size: e3,
        protocolparamupdate_max_block_ex_units: F3,
        protocolparamupdate_max_block_header_size: a3,
        protocolparamupdate_max_collateral_inputs: V3,
        protocolparamupdate_max_epoch: l3,
        protocolparamupdate_max_tx_ex_units: N3,
        protocolparamupdate_max_tx_size: _3,
        protocolparamupdate_max_value_size: U3,
        protocolparamupdate_min_committee_size: W3,
        protocolparamupdate_min_pool_cost: C3,
        protocolparamupdate_minfee_a: Xx,
        protocolparamupdate_minfee_b: Zx,
        protocolparamupdate_n_opt: u3,
        protocolparamupdate_new: oE,
        protocolparamupdate_pool_deposit: c3,
        protocolparamupdate_pool_pledge_influence: g3,
        protocolparamupdate_pool_voting_thresholds: K3,
        protocolparamupdate_protocol_version: x3,
        protocolparamupdate_ref_script_coins_per_byte: aE,
        protocolparamupdate_set_ada_per_utxo_byte: S3,
        protocolparamupdate_set_collateral_percentage: z3,
        protocolparamupdate_set_committee_term_limit: Q3,
        protocolparamupdate_set_cost_models: j3,
        protocolparamupdate_set_drep_deposit: tE,
        protocolparamupdate_set_drep_inactivity_period: rE,
        protocolparamupdate_set_drep_voting_thresholds: q3,
        protocolparamupdate_set_execution_costs: I3,
        protocolparamupdate_set_expansion_rate: w3,
        protocolparamupdate_set_governance_action_deposit: J3,
        protocolparamupdate_set_governance_action_validity_period: Y3,
        protocolparamupdate_set_key_deposit: o3,
        protocolparamupdate_set_max_block_body_size: t3,
        protocolparamupdate_set_max_block_ex_units: L3,
        protocolparamupdate_set_max_block_header_size: n3,
        protocolparamupdate_set_max_collateral_inputs: P3,
        protocolparamupdate_set_max_epoch: d3,
        protocolparamupdate_set_max_tx_ex_units: R3,
        protocolparamupdate_set_max_tx_size: r3,
        protocolparamupdate_set_max_value_size: O3,
        protocolparamupdate_set_min_committee_size: G3,
        protocolparamupdate_set_min_pool_cost: E3,
        protocolparamupdate_set_minfee_a: Yx,
        protocolparamupdate_set_minfee_b: Jx,
        protocolparamupdate_set_n_opt: p3,
        protocolparamupdate_set_pool_deposit: i3,
        protocolparamupdate_set_pool_pledge_influence: f3,
        protocolparamupdate_set_pool_voting_thresholds: M3,
        protocolparamupdate_set_protocol_version: k3,
        protocolparamupdate_set_ref_script_coins_per_byte: nE,
        protocolparamupdate_set_treasury_growth_rate: b3,
        protocolparamupdate_to_bytes: Kx,
        protocolparamupdate_to_hex: Hx,
        protocolparamupdate_to_js_value: Qx,
        protocolparamupdate_to_json: Wx,
        protocolparamupdate_treasury_growth_rate: y3,
        protocolversion_from_bytes: i1,
        protocolversion_from_hex: d1,
        protocolversion_from_json: u1,
        protocolversion_major: f1,
        protocolversion_minor: g1,
        protocolversion_new: w1,
        protocolversion_to_bytes: s1,
        protocolversion_to_hex: c1,
        protocolversion_to_js_value: p1,
        protocolversion_to_json: l1,
        publickey_as_bytes: Kw,
        publickey_from_bech32: Hw,
        publickey_from_bytes: Mw,
        publickey_from_hex: zw,
        publickey_hash: Pw,
        publickey_to_bech32: qw,
        publickey_to_hex: Dw,
        publickey_verify: Vw,
        publickeys_add: w7,
        publickeys_get: g7,
        publickeys_new: u7,
        publickeys_size: f7,
        redeemer_data: bk,
        redeemer_ex_units: yk,
        redeemer_from_bytes: dk,
        redeemer_from_hex: pk,
        redeemer_from_json: gk,
        redeemer_index: hk,
        redeemer_new: vk,
        redeemer_tag: wk,
        redeemer_to_bytes: ck,
        redeemer_to_hex: lk,
        redeemer_to_js_value: fk,
        redeemer_to_json: uk,
        redeemers_add: Rk,
        redeemers_from_bytes: xk,
        redeemers_from_hex: Ck,
        redeemers_from_json: jk,
        redeemers_get: Bk,
        redeemers_get_container_type: Nk,
        redeemers_len: Ik,
        redeemers_new: Ak,
        redeemers_to_bytes: kk,
        redeemers_to_hex: Ek,
        redeemers_to_js_value: Tk,
        redeemers_to_json: Sk,
        redeemers_total_ex_units: Lk,
        redeemertag_from_bytes: mh,
        redeemertag_from_hex: xh,
        redeemertag_from_json: Sh,
        redeemertag_kind: Nh,
        redeemertag_new_cert: Ah,
        redeemertag_new_mint: jh,
        redeemertag_new_reward: Ih,
        redeemertag_new_spend: Th,
        redeemertag_new_vote: Bh,
        redeemertag_new_voting_proposal: Rh,
        redeemertag_to_bytes: vh,
        redeemertag_to_hex: kh,
        redeemertag_to_js_value: Ch,
        redeemertag_to_json: Eh,
        relay_as_multi_host_name: Nv,
        relay_as_single_host_addr: Bv,
        relay_as_single_host_name: Rv,
        relay_from_bytes: mv,
        relay_from_hex: xv,
        relay_from_json: Sv,
        relay_kind: Iv,
        relay_new_multi_host_name: Av,
        relay_new_single_host_addr: Tv,
        relay_new_single_host_name: jv,
        relay_to_bytes: vv,
        relay_to_hex: kv,
        relay_to_js_value: Cv,
        relay_to_json: Ev,
        relays_add: Iu,
        relays_from_bytes: mu,
        relays_from_hex: xu,
        relays_from_json: Su,
        relays_get: Au,
        relays_len: ju,
        relays_new: Tu,
        relays_to_bytes: vu,
        relays_to_hex: ku,
        relays_to_js_value: Cu,
        relays_to_json: Eu,
        rewardaddress_from_address: gB,
        rewardaddress_network_id: h9,
        rewardaddress_new: g9,
        rewardaddress_payment_cred: u9,
        rewardaddress_to_address: fB,
        rewardaddresses_add: tm,
        rewardaddresses_from_bytes: Gv,
        rewardaddresses_from_hex: Qv,
        rewardaddresses_from_json: Xv,
        rewardaddresses_get: Zv,
        rewardaddresses_len: Jv,
        rewardaddresses_new: L4,
        rewardaddresses_to_bytes: Hv,
        rewardaddresses_to_hex: Wv,
        rewardaddresses_to_js_value: Yv,
        rewardaddresses_to_json: $v,
        scriptall_from_bytes: eL,
        scriptall_from_hex: _L,
        scriptall_from_json: oL,
        scriptall_native_scripts: sL,
        scriptall_new: iL,
        scriptall_to_bytes: tL,
        scriptall_to_hex: rL,
        scriptall_to_js_value: aL,
        scriptall_to_json: nL,
        scriptany_from_bytes: dL,
        scriptany_from_hex: pL,
        scriptany_from_json: gL,
        scriptany_native_scripts: mF,
        scriptany_new: xF,
        scriptany_to_bytes: cL,
        scriptany_to_hex: lL,
        scriptany_to_js_value: fL,
        scriptany_to_json: uL,
        scriptdatahash_from_bech32: pD,
        scriptdatahash_from_bytes: lD,
        scriptdatahash_from_hex: uD,
        scriptdatahash_to_bech32: lP,
        scriptdatahash_to_bytes: ZD,
        scriptdatahash_to_hex: VD,
        scripthash_from_bech32: Rz,
        scripthash_from_bytes: Bz,
        scripthash_from_hex: Nz,
        scripthash_to_bech32: rP,
        scripthash_to_bytes: qD,
        scripthash_to_hex: RD,
        scripthashes_add: Qm,
        scripthashes_from_bytes: Vm,
        scripthashes_from_hex: Km,
        scripthashes_from_json: Gm,
        scripthashes_get: Wm,
        scripthashes_len: y4,
        scripthashes_new: F4,
        scripthashes_to_bytes: Pm,
        scripthashes_to_hex: Mm,
        scripthashes_to_js_value: Hm,
        scripthashes_to_json: qm,
        scriptnofk_from_bytes: bL,
        scriptnofk_from_hex: vL,
        scriptnofk_from_json: xL,
        scriptnofk_n: EL,
        scriptnofk_native_scripts: kF,
        scriptnofk_new: CL,
        scriptnofk_to_bytes: hL,
        scriptnofk_to_hex: yL,
        scriptnofk_to_js_value: kL,
        scriptnofk_to_json: mL,
        scriptpubkey_addr_keyhash: X7,
        scriptpubkey_from_bytes: H7,
        scriptpubkey_from_hex: W7,
        scriptpubkey_from_json: Y7,
        scriptpubkey_new: J7,
        scriptpubkey_to_bytes: q7,
        scriptpubkey_to_hex: G7,
        scriptpubkey_to_js_value: $7,
        scriptpubkey_to_json: Q7,
        scriptref_from_bytes: aW,
        scriptref_from_hex: sW,
        scriptref_from_json: dW,
        scriptref_is_native_script: uW,
        scriptref_is_plutus_script: fW,
        scriptref_native_script: gW,
        scriptref_new_native_script: lW,
        scriptref_new_plutus_script: pW,
        scriptref_plutus_script: wW,
        scriptref_to_bytes: nW,
        scriptref_to_hex: oW,
        scriptref_to_js_value: cW,
        scriptref_to_json: iW,
        scriptref_to_unwrapped_bytes: hW,
        singlehostaddr_from_bytes: Hy,
        singlehostaddr_from_hex: Wy,
        singlehostaddr_from_json: Yy,
        singlehostaddr_ipv4: Jy,
        singlehostaddr_ipv6: Zy,
        singlehostaddr_new: tv,
        singlehostaddr_port: Xy,
        singlehostaddr_to_bytes: qy,
        singlehostaddr_to_hex: Gy,
        singlehostaddr_to_js_value: $y,
        singlehostaddr_to_json: Qy,
        singlehostname_dns_name: R4,
        singlehostname_from_bytes: _v,
        singlehostname_from_hex: av,
        singlehostname_from_json: iv,
        singlehostname_new: dv,
        singlehostname_port: cv,
        singlehostname_to_bytes: rv,
        singlehostname_to_hex: nv,
        singlehostname_to_js_value: sv,
        singlehostname_to_json: ov,
        stakeandvotedelegation_drep: uf,
        stakeandvotedelegation_from_bytes: af,
        stakeandvotedelegation_from_hex: sf,
        stakeandvotedelegation_from_json: lf,
        stakeandvotedelegation_has_script_credentials: _h,
        stakeandvotedelegation_new: ff,
        stakeandvotedelegation_pool_keyhash: pf,
        stakeandvotedelegation_stake_credential: nh,
        stakeandvotedelegation_to_bytes: nf,
        stakeandvotedelegation_to_hex: of,
        stakeandvotedelegation_to_js_value: df,
        stakeandvotedelegation_to_json: cf,
        stakedelegation_from_bytes: L9,
        stakedelegation_from_hex: O9,
        stakedelegation_from_json: D9,
        stakedelegation_has_script_credentials: K9,
        stakedelegation_new: M9,
        stakedelegation_pool_keyhash: V9,
        stakedelegation_stake_credential: P9,
        stakedelegation_to_bytes: N9,
        stakedelegation_to_hex: F9,
        stakedelegation_to_js_value: z9,
        stakedelegation_to_json: U9,
        stakederegistration_coin: SU,
        stakederegistration_from_bytes: yU,
        stakederegistration_from_hex: mU,
        stakederegistration_from_json: EU,
        stakederegistration_has_script_credentials: AU,
        stakederegistration_new: TU,
        stakederegistration_new_with_explicit_refund: jU,
        stakederegistration_stake_credential: CU,
        stakederegistration_to_bytes: bU,
        stakederegistration_to_hex: vU,
        stakederegistration_to_js_value: xU,
        stakederegistration_to_json: kU,
        stakeregistration_coin: gh,
        stakeregistration_from_bytes: ih,
        stakeregistration_from_hex: dh,
        stakeregistration_from_json: uh,
        stakeregistration_has_script_credentials: bh,
        stakeregistration_new: wh,
        stakeregistration_new_with_explicit_deposit: hh,
        stakeregistration_stake_credential: fh,
        stakeregistration_to_bytes: sh,
        stakeregistration_to_hex: ch,
        stakeregistration_to_js_value: ph,
        stakeregistration_to_json: lh,
        stakeregistrationanddelegation_coin: Cf,
        stakeregistrationanddelegation_from_bytes: hf,
        stakeregistrationanddelegation_from_hex: yf,
        stakeregistrationanddelegation_from_json: kf,
        stakeregistrationanddelegation_has_script_credentials: Tf,
        stakeregistrationanddelegation_new: Sf,
        stakeregistrationanddelegation_pool_keyhash: Ef,
        stakeregistrationanddelegation_stake_credential: xf,
        stakeregistrationanddelegation_to_bytes: wf,
        stakeregistrationanddelegation_to_hex: bf,
        stakeregistrationanddelegation_to_js_value: mf,
        stakeregistrationanddelegation_to_json: vf,
        stakevoteregistrationanddelegation_coin: th,
        stakevoteregistrationanddelegation_drep: Uf,
        stakevoteregistrationanddelegation_from_bytes: If,
        stakevoteregistrationanddelegation_from_hex: Rf,
        stakevoteregistrationanddelegation_from_json: Ff,
        stakevoteregistrationanddelegation_has_script_credentials: Df,
        stakevoteregistrationanddelegation_new: zf,
        stakevoteregistrationanddelegation_pool_keyhash: eh,
        stakevoteregistrationanddelegation_stake_credential: Of,
        stakevoteregistrationanddelegation_to_bytes: Af,
        stakevoteregistrationanddelegation_to_hex: Bf,
        stakevoteregistrationanddelegation_to_js_value: Lf,
        stakevoteregistrationanddelegation_to_json: Nf,
        strings_add: _G,
        strings_get: rG,
        strings_len: eG,
        strings_new: tG,
        timelockexpiry_from_bytes: FL,
        timelockexpiry_from_hex: UL,
        timelockexpiry_from_json: PL,
        timelockexpiry_new: KL,
        timelockexpiry_new_timelockexpiry: qL,
        timelockexpiry_slot: VL,
        timelockexpiry_slot_bignum: ML,
        timelockexpiry_to_bytes: LL,
        timelockexpiry_to_hex: OL,
        timelockexpiry_to_js_value: DL,
        timelockexpiry_to_json: zL,
        timelockstart_from_bytes: TL,
        timelockstart_from_hex: AL,
        timelockstart_from_json: RL,
        timelockstart_new: jF,
        timelockstart_new_timelockstart: TF,
        timelockstart_slot: yF,
        timelockstart_slot_bignum: bF,
        timelockstart_to_bytes: SL,
        timelockstart_to_hex: jL,
        timelockstart_to_js_value: BL,
        timelockstart_to_json: IL,
        transaction_auxiliary_data: hb,
        transaction_body: fb,
        transaction_from_bytes: ib,
        transaction_from_hex: db,
        transaction_from_json: ub,
        transaction_is_valid: wb,
        transaction_new: yb,
        transaction_set_is_valid: bb,
        transaction_to_bytes: sb,
        transaction_to_hex: cb,
        transaction_to_js_value: pb,
        transaction_to_json: lb,
        transaction_witness_set: gb,
        transactionbatch_get: qF,
        transactionbatch_len: KF,
        transactionbatchlist_get: VF,
        transactionbatchlist_len: PF,
        transactionbodies_add: GR,
        transactionbodies_from_bytes: zR,
        transactionbodies_from_hex: PR,
        transactionbodies_from_json: KR,
        transactionbodies_get: HR,
        transactionbodies_len: qR,
        transactionbodies_new: y9,
        transactionbodies_to_bytes: UR,
        transactionbodies_to_hex: DR,
        transactionbodies_to_js_value: MR,
        transactionbodies_to_json: VR,
        transactionbody_auxiliary_data_hash: FK,
        transactionbody_certs: AK,
        transactionbody_collateral: WK,
        transactionbody_collateral_return: ZK,
        transactionbody_current_treasury_value: cq,
        transactionbody_donation: sq,
        transactionbody_fee: xK,
        transactionbody_from_bytes: gK,
        transactionbody_from_hex: hK,
        transactionbody_from_json: vK,
        transactionbody_inputs: mK,
        transactionbody_mint: VK,
        transactionbody_network_id: XK,
        transactionbody_new: dq,
        transactionbody_new_tx_body: lq,
        transactionbody_outputs: kK,
        transactionbody_reference_inputs: KK,
        transactionbody_remove_ttl: TK,
        transactionbody_required_signers: $K,
        transactionbody_script_data_hash: HK,
        transactionbody_set_auxiliary_data_hash: LK,
        transactionbody_set_certs: jK,
        transactionbody_set_collateral: GK,
        transactionbody_set_collateral_return: JK,
        transactionbody_set_current_treasury_value: iq,
        transactionbody_set_donation: oq,
        transactionbody_set_mint: PK,
        transactionbody_set_network_id: YK,
        transactionbody_set_reference_inputs: MK,
        transactionbody_set_required_signers: QK,
        transactionbody_set_script_data_hash: qK,
        transactionbody_set_total_collateral: tq,
        transactionbody_set_ttl: SK,
        transactionbody_set_update: RK,
        transactionbody_set_validity_start_interval: OK,
        transactionbody_set_validity_start_interval_bignum: UK,
        transactionbody_set_voting_procedures: rq,
        transactionbody_set_voting_proposals: nq,
        transactionbody_set_withdrawals: IK,
        transactionbody_to_bytes: fK,
        transactionbody_to_hex: wK,
        transactionbody_to_js_value: yK,
        transactionbody_to_json: bK,
        transactionbody_total_collateral: eq,
        transactionbody_ttl: EK,
        transactionbody_ttl_bignum: CK,
        transactionbody_update: NK,
        transactionbody_validity_start_interval: DK,
        transactionbody_validity_start_interval_bignum: zK,
        transactionbody_voting_procedures: _q,
        transactionbody_voting_proposals: aq,
        transactionbody_withdrawals: BK,
        transactionbuilder_add_bootstrap_input: $P,
        transactionbuilder_add_change_if_needed: JV,
        transactionbuilder_add_change_if_needed_with_datum: ZV,
        transactionbuilder_add_extra_witness_datum: UV,
        transactionbuilder_add_inputs_from: FP,
        transactionbuilder_add_inputs_from_and_change: XP,
        transactionbuilder_add_inputs_from_and_change_with_collateral_return: JP,
        transactionbuilder_add_json_metadatum: CV,
        transactionbuilder_add_json_metadatum_with_schema: SV,
        transactionbuilder_add_key_input: GP,
        transactionbuilder_add_metadatum: EV,
        transactionbuilder_add_mint_asset: LV,
        transactionbuilder_add_mint_asset_and_output: FV,
        transactionbuilder_add_mint_asset_and_output_min_required_coin: OV,
        transactionbuilder_add_native_script_input: WP,
        transactionbuilder_add_output: rV,
        transactionbuilder_add_plutus_script_input: QP,
        transactionbuilder_add_reference_input: qP,
        transactionbuilder_add_regular_input: YP,
        transactionbuilder_add_required_signer: _M,
        transactionbuilder_add_script_reference_input: HP,
        transactionbuilder_build: oM,
        transactionbuilder_build_tx: sM,
        transactionbuilder_build_tx_unsafe: iM,
        transactionbuilder_calc_script_data_hash: tM,
        transactionbuilder_fee_for_input: eV,
        transactionbuilder_fee_for_output: _V,
        transactionbuilder_full_size: nM,
        transactionbuilder_get_auxiliary_data: vV,
        transactionbuilder_get_current_treasury_value: MV,
        transactionbuilder_get_deposit: YV,
        transactionbuilder_get_donation: PV,
        transactionbuilder_get_explicit_input: HV,
        transactionbuilder_get_explicit_output: $V,
        transactionbuilder_get_extra_witness_datums: zV,
        transactionbuilder_get_fee_if_set: XV,
        transactionbuilder_get_implicit_input: GV,
        transactionbuilder_get_mint: BV,
        transactionbuilder_get_mint_builder: AV,
        transactionbuilder_get_mint_scripts: RV,
        transactionbuilder_get_native_input_scripts: ZP,
        transactionbuilder_get_plutus_input_scripts: tV,
        transactionbuilder_get_reference_inputs: qV,
        transactionbuilder_get_total_input: WV,
        transactionbuilder_get_total_output: QV,
        transactionbuilder_min_fee: cM,
        transactionbuilder_new: KV,
        transactionbuilder_output_sizes: aM,
        transactionbuilder_remove_auxiliary_data: kV,
        transactionbuilder_remove_certs: uV,
        transactionbuilder_remove_collateral_return: DP,
        transactionbuilder_remove_mint_builder: jV,
        transactionbuilder_remove_script_data_hash: rM,
        transactionbuilder_remove_total_collateral: MP,
        transactionbuilder_remove_ttl: iV,
        transactionbuilder_remove_validity_start_interval: lV,
        transactionbuilder_remove_withdrawals: yV,
        transactionbuilder_set_auxiliary_data: mV,
        transactionbuilder_set_certs: pV,
        transactionbuilder_set_certs_builder: fV,
        transactionbuilder_set_collateral: UP,
        transactionbuilder_set_collateral_return: zP,
        transactionbuilder_set_collateral_return_and_total: PP,
        transactionbuilder_set_current_treasury_value: VV,
        transactionbuilder_set_donation: DV,
        transactionbuilder_set_fee: nV,
        transactionbuilder_set_inputs: OP,
        transactionbuilder_set_metadata: xV,
        transactionbuilder_set_min_fee: aV,
        transactionbuilder_set_mint: IV,
        transactionbuilder_set_mint_asset: NV,
        transactionbuilder_set_mint_builder: TV,
        transactionbuilder_set_script_data_hash: eM,
        transactionbuilder_set_total_collateral: VP,
        transactionbuilder_set_total_collateral_and_return: KP,
        transactionbuilder_set_ttl: oV,
        transactionbuilder_set_ttl_bignum: sV,
        transactionbuilder_set_validity_start_interval: cV,
        transactionbuilder_set_validity_start_interval_bignum: dV,
        transactionbuilder_set_voting_builder: hV,
        transactionbuilder_set_voting_proposal_builder: bV,
        transactionbuilder_set_withdrawals: gV,
        transactionbuilder_set_withdrawals_builder: wV,
        transactionbuilderconfigbuilder_build: jP,
        transactionbuilderconfigbuilder_coins_per_utxo_byte: bP,
        transactionbuilderconfigbuilder_deduplicate_explicit_ref_inputs_with_regular_inputs: SP,
        transactionbuilderconfigbuilder_do_not_burn_extra_change: TP,
        transactionbuilderconfigbuilder_ex_unit_prices: yP,
        transactionbuilderconfigbuilder_fee_algo: hP,
        transactionbuilderconfigbuilder_key_deposit: mP,
        transactionbuilderconfigbuilder_max_tx_size: xP,
        transactionbuilderconfigbuilder_max_value_size: kP,
        transactionbuilderconfigbuilder_new: wP,
        transactionbuilderconfigbuilder_pool_deposit: vP,
        transactionbuilderconfigbuilder_prefer_pure_change: CP,
        transactionbuilderconfigbuilder_ref_script_coins_per_byte: EP,
        transactionhash_from_bech32: Mz,
        transactionhash_from_bytes: Vz,
        transactionhash_from_hex: Kz,
        transactionhash_to_bech32: oP,
        transactionhash_to_bytes: QD,
        transactionhash_to_hex: ND,
        transactioninput_from_bytes: BS,
        transactioninput_from_hex: NS,
        transactioninput_from_json: OS,
        transactioninput_index: gj,
        transactioninput_new: hj,
        transactioninput_to_bytes: IS,
        transactioninput_to_hex: RS,
        transactioninput_to_js_value: FS,
        transactioninput_to_json: LS,
        transactioninput_transaction_id: bj,
        transactioninputs_add: WA,
        transactioninputs_from_bytes: zA,
        transactioninputs_from_hex: PA,
        transactioninputs_from_json: KA,
        transactioninputs_get: GA,
        transactioninputs_len: HA,
        transactioninputs_new: qA,
        transactioninputs_to_bytes: UA,
        transactioninputs_to_hex: DA,
        transactioninputs_to_js_value: MA,
        transactioninputs_to_json: VA,
        transactioninputs_to_option: QA,
        transactionmetadatum_as_bytes: f6,
        transactionmetadatum_as_int: u6,
        transactionmetadatum_as_list: p6,
        transactionmetadatum_as_map: l6,
        transactionmetadatum_as_text: g6,
        transactionmetadatum_from_bytes: r6,
        transactionmetadatum_from_hex: n6,
        transactionmetadatum_kind: d6,
        transactionmetadatum_new_bytes: i6,
        transactionmetadatum_new_int: s6,
        transactionmetadatum_new_list: o6,
        transactionmetadatum_new_map: a6,
        transactionmetadatum_new_text: c6,
        transactionmetadatum_to_bytes: e6,
        transactionmetadatum_to_hex: _6,
        transactionmetadatumlabels_add: x6,
        transactionmetadatumlabels_from_bytes: b6,
        transactionmetadatumlabels_from_hex: v6,
        transactionmetadatumlabels_get: k6,
        transactionmetadatumlabels_len: m6,
        transactionmetadatumlabels_new: SC,
        transactionmetadatumlabels_to_bytes: h6,
        transactionmetadatumlabels_to_hex: y6,
        transactionoutput_address: Kb,
        transactionoutput_amount: qb,
        transactionoutput_data_hash: Hb,
        transactionoutput_from_bytes: Ub,
        transactionoutput_from_hex: Db,
        transactionoutput_from_json: Mb,
        transactionoutput_has_data_hash: Jb,
        transactionoutput_has_plutus_data: Xb,
        transactionoutput_has_script_ref: Zb,
        transactionoutput_new: ty,
        transactionoutput_plutus_data: Gb,
        transactionoutput_script_ref: Wb,
        transactionoutput_serialization_format: ey,
        transactionoutput_set_data_hash: Yb,
        transactionoutput_set_plutus_data: $b,
        transactionoutput_set_script_ref: Qb,
        transactionoutput_to_bytes: Ob,
        transactionoutput_to_hex: zb,
        transactionoutput_to_js_value: Vb,
        transactionoutput_to_json: Pb,
        transactionoutputamountbuilder_build: GI,
        transactionoutputamountbuilder_with_asset_and_min_required_coin_by_utxo_cost: HI,
        transactionoutputamountbuilder_with_coin: KI,
        transactionoutputamountbuilder_with_coin_and_asset: qI,
        transactionoutputamountbuilder_with_value: MI,
        transactionoutputbuilder_new: FI,
        transactionoutputbuilder_next: PI,
        transactionoutputbuilder_with_address: OI,
        transactionoutputbuilder_with_data_hash: UI,
        transactionoutputbuilder_with_plutus_data: zI,
        transactionoutputbuilder_with_script_ref: DI,
        transactionoutputs_add: Bb,
        transactionoutputs_from_bytes: kb,
        transactionoutputs_from_hex: Eb,
        transactionoutputs_from_json: Tb,
        transactionoutputs_get: Ib,
        transactionoutputs_len: Ab,
        transactionoutputs_new: jb,
        transactionoutputs_to_bytes: mb,
        transactionoutputs_to_hex: xb,
        transactionoutputs_to_js_value: Sb,
        transactionoutputs_to_json: Cb,
        transactionunspentoutput_from_bytes: yT,
        transactionunspentoutput_from_hex: mT,
        transactionunspentoutput_from_json: ET,
        transactionunspentoutput_input: ST,
        transactionunspentoutput_new: CT,
        transactionunspentoutput_output: TT,
        transactionunspentoutput_to_bytes: bT,
        transactionunspentoutput_to_hex: vT,
        transactionunspentoutput_to_js_value: xT,
        transactionunspentoutput_to_json: kT,
        transactionunspentoutputs_add: FT,
        transactionunspentoutputs_from_json: BT,
        transactionunspentoutputs_get: LT,
        transactionunspentoutputs_len: NT,
        transactionunspentoutputs_new: RT,
        transactionunspentoutputs_to_js_value: IT,
        transactionunspentoutputs_to_json: AT,
        transactionwitnessset_bootstraps: Cq,
        transactionwitnessset_from_bytes: fq,
        transactionwitnessset_from_hex: wq,
        transactionwitnessset_from_json: yq,
        transactionwitnessset_native_scripts: xq,
        transactionwitnessset_new: Rq,
        transactionwitnessset_plutus_data: Aq,
        transactionwitnessset_plutus_scripts: Tq,
        transactionwitnessset_redeemers: Bq,
        transactionwitnessset_set_bootstraps: Eq,
        transactionwitnessset_set_native_scripts: kq,
        transactionwitnessset_set_plutus_data: jq,
        transactionwitnessset_set_plutus_scripts: Sq,
        transactionwitnessset_set_redeemers: Iq,
        transactionwitnessset_set_vkeys: vq,
        transactionwitnessset_to_bytes: uq,
        transactionwitnessset_to_hex: gq,
        transactionwitnessset_to_js_value: bq,
        transactionwitnessset_to_json: hq,
        transactionwitnessset_vkeys: mq,
        transactionwitnesssets_add: MB,
        transactionwitnesssets_from_bytes: LB,
        transactionwitnesssets_from_hex: OB,
        transactionwitnesssets_from_json: DB,
        transactionwitnesssets_get: VB,
        transactionwitnesssets_len: PB,
        transactionwitnesssets_new: b9,
        transactionwitnesssets_to_bytes: NB,
        transactionwitnesssets_to_hex: FB,
        transactionwitnesssets_to_js_value: zB,
        transactionwitnesssets_to_json: UB,
        treasurywithdrawals_from_json: CM,
        treasurywithdrawals_get: TM,
        treasurywithdrawals_insert: jM,
        treasurywithdrawals_keys: AM,
        treasurywithdrawals_len: IM,
        treasurywithdrawals_new: SM,
        treasurywithdrawals_to_js_value: EM,
        treasurywithdrawals_to_json: xM,
        treasurywithdrawalsaction_from_bytes: E5,
        treasurywithdrawalsaction_from_hex: S5,
        treasurywithdrawalsaction_from_json: A5,
        treasurywithdrawalsaction_new: R5,
        treasurywithdrawalsaction_new_with_policy_hash: N5,
        treasurywithdrawalsaction_policy_hash: B5,
        treasurywithdrawalsaction_to_bytes: x5,
        treasurywithdrawalsaction_to_hex: C5,
        treasurywithdrawalsaction_to_js_value: j5,
        treasurywithdrawalsaction_to_json: T5,
        treasurywithdrawalsaction_withdrawals: I5,
        txinputsbuilder_add_bootstrap_input: tO,
        txinputsbuilder_add_key_input: XF,
        txinputsbuilder_add_native_script_input: JF,
        txinputsbuilder_add_native_script_utxo: YF,
        txinputsbuilder_add_plutus_script_input: ZF,
        txinputsbuilder_add_plutus_script_utxo: $F,
        txinputsbuilder_add_regular_input: eO,
        txinputsbuilder_add_regular_utxo: QF,
        txinputsbuilder_add_required_signer: oO,
        txinputsbuilder_add_required_signers: sO,
        txinputsbuilder_get_native_input_scripts: _O,
        txinputsbuilder_get_plutus_input_scripts: nO,
        txinputsbuilder_get_ref_inputs: rO,
        txinputsbuilder_inputs: cO,
        txinputsbuilder_inputs_option: dO,
        txinputsbuilder_len: aO,
        txinputsbuilder_new: WF,
        txinputsbuilder_total_value: iO,
        unitinterval_denominator: nb,
        unitinterval_from_bytes: Jh,
        unitinterval_from_hex: tb,
        unitinterval_from_json: _b,
        unitinterval_new: ab,
        unitinterval_numerator: f4,
        unitinterval_to_bytes: Xh,
        unitinterval_to_hex: Zh,
        unitinterval_to_js_value: rb,
        unitinterval_to_json: eb,
        update_epoch: Sm,
        update_from_bytes: ym,
        update_from_hex: mm,
        update_from_json: Em,
        update_new: Tm,
        update_proposed_protocol_parameter_updates: Cm,
        update_to_bytes: bm,
        update_to_hex: vm,
        update_to_js_value: xm,
        update_to_json: km,
        updatecommitteeaction_committee: K5,
        updatecommitteeaction_from_bytes: O5,
        updatecommitteeaction_from_hex: z5,
        updatecommitteeaction_from_json: V5,
        updatecommitteeaction_gov_action_id: M5,
        updatecommitteeaction_members_to_remove: q5,
        updatecommitteeaction_new: H5,
        updatecommitteeaction_new_with_action_id: G5,
        updatecommitteeaction_to_bytes: F5,
        updatecommitteeaction_to_hex: U5,
        updatecommitteeaction_to_js_value: P5,
        updatecommitteeaction_to_json: D5,
        url_from_bytes: xy,
        url_from_hex: Cy,
        url_from_json: Sy,
        url_new: Ty,
        url_to_bytes: ky,
        url_to_hex: Ey,
        url_to_js_value: A4,
        url_to_json: m4,
        url_url: x4,
        value_checked_add: ZT,
        value_checked_sub: tj,
        value_clamped_sub: ej,
        value_coin: $T,
        value_compare: rj,
        value_from_bytes: zT,
        value_from_hex: PT,
        value_from_json: KT,
        value_is_zero: QT,
        value_multiasset: XT,
        value_new: qT,
        value_new_from_assets: HT,
        value_new_with_assets: GT,
        value_set_coin: YT,
        value_set_multiasset: JT,
        value_to_bytes: UT,
        value_to_hex: DT,
        value_to_js_value: MT,
        value_to_json: VT,
        value_zero: WT,
        versionedblock_block: dC,
        versionedblock_era: lC,
        versionedblock_from_bytes: _C,
        versionedblock_from_hex: aC,
        versionedblock_from_json: iC,
        versionedblock_new: cC,
        versionedblock_to_bytes: rC,
        versionedblock_to_hex: nC,
        versionedblock_to_js_value: sC,
        versionedblock_to_json: oC,
        vkey_from_bytes: AE,
        vkey_from_hex: BE,
        vkey_from_json: LE,
        vkey_new: FE,
        vkey_public_key: OE,
        vkey_to_bytes: jE,
        vkey_to_hex: IE,
        vkey_to_js_value: NE,
        vkey_to_json: RE,
        vkeys_add: l7,
        vkeys_get: d7,
        vkeys_len: vF,
        vkeys_new: CF,
        vkeywitness_from_bytes: PN,
        vkeywitness_from_hex: MN,
        vkeywitness_from_json: HN,
        vkeywitness_new: GN,
        vkeywitness_signature: QN,
        vkeywitness_to_bytes: DN,
        vkeywitness_to_hex: VN,
        vkeywitness_to_js_value: qN,
        vkeywitness_to_json: KN,
        vkeywitness_vkey: WN,
        vkeywitnesses_add: Ew,
        vkeywitnesses_from_bytes: hw,
        vkeywitnesses_from_hex: yw,
        vkeywitnesses_from_json: kw,
        vkeywitnesses_get: xw,
        vkeywitnesses_len: ah,
        vkeywitnesses_new: Yw,
        vkeywitnesses_to_bytes: ww,
        vkeywitnesses_to_hex: bw,
        vkeywitnesses_to_js_value: mw,
        vkeywitnesses_to_json: vw,
        votedelegation_drep: Xw,
        votedelegation_from_bytes: Yu,
        votedelegation_from_hex: Ju,
        votedelegation_from_json: ef,
        votedelegation_has_script_credentials: Jw,
        votedelegation_new: rf,
        votedelegation_stake_credential: Zw,
        votedelegation_to_bytes: $u,
        votedelegation_to_hex: Xu,
        votedelegation_to_js_value: tf,
        votedelegation_to_json: Zu,
        voter_from_bytes: jg,
        voter_from_hex: Ig,
        voter_from_json: Ng,
        voter_has_script_credentials: Vg,
        voter_kind: Ug,
        voter_new_constitutional_committee_hot_credential: Lg,
        voter_new_drep_credential: Fg,
        voter_new_stake_pool_key_hash: Og,
        voter_to_bytes: Tg,
        voter_to_constitutional_committee_hot_credential: zg,
        voter_to_drep_credential: Dg,
        voter_to_hex: Ag,
        voter_to_js_value: Rg,
        voter_to_json: Bg,
        voter_to_key_hash: Mg,
        voter_to_stake_pool_key_hash: Pg,
        voteregistrationanddelegation_coin: rh,
        voteregistrationanddelegation_drep: Qf,
        voteregistrationanddelegation_from_bytes: Vf,
        voteregistrationanddelegation_from_hex: Kf,
        voteregistrationanddelegation_from_json: Gf,
        voteregistrationanddelegation_has_script_credentials: Yf,
        voteregistrationanddelegation_new: $f,
        voteregistrationanddelegation_stake_credential: Wf,
        voteregistrationanddelegation_to_bytes: Pf,
        voteregistrationanddelegation_to_hex: Mf,
        voteregistrationanddelegation_to_js_value: Hf,
        voteregistrationanddelegation_to_json: qf,
        voters_add: FU,
        voters_from_json: NU,
        voters_get: OU,
        voters_len: UU,
        voters_new: LU,
        voters_to_js_value: RU,
        voters_to_json: BU,
        votingbuilder_add: Nj,
        votingbuilder_add_with_native_script: Fj,
        votingbuilder_add_with_plutus_witness: Lj,
        votingbuilder_build: Pj,
        votingbuilder_get_native_scripts: zj,
        votingbuilder_get_plutus_witnesses: Oj,
        votingbuilder_get_ref_inputs: Uj,
        votingbuilder_has_plutus_scripts: Dj,
        votingbuilder_new: Rj,
        votingprocedure_anchor: wF,
        votingprocedure_from_bytes: yN,
        votingprocedure_from_hex: mN,
        votingprocedure_from_json: EN,
        votingprocedure_new: CN,
        votingprocedure_new_with_anchor: SN,
        votingprocedure_to_bytes: bN,
        votingprocedure_to_hex: vN,
        votingprocedure_to_js_value: xN,
        votingprocedure_to_json: kN,
        votingprocedure_vote_kind: TN,
        votingprocedures_from_bytes: pM,
        votingprocedures_from_hex: fM,
        votingprocedures_from_json: hM,
        votingprocedures_get: yM,
        votingprocedures_get_governance_action_ids_by_voter: mM,
        votingprocedures_get_voters: vM,
        votingprocedures_insert: bM,
        votingprocedures_new: qq,
        votingprocedures_to_bytes: lM,
        votingprocedures_to_hex: uM,
        votingprocedures_to_js_value: wM,
        votingprocedures_to_json: gM,
        votingproposal_anchor: SS,
        votingproposal_deposit: jS,
        votingproposal_from_bytes: yS,
        votingproposal_from_hex: mS,
        votingproposal_from_json: ES,
        votingproposal_governance_action: CS,
        votingproposal_new: AS,
        votingproposal_reward_account: TS,
        votingproposal_to_bytes: bS,
        votingproposal_to_hex: vS,
        votingproposal_to_js_value: xS,
        votingproposal_to_json: kS,
        votingproposalbuilder_add: Mj,
        votingproposalbuilder_add_with_plutus_witness: Kj,
        votingproposalbuilder_build: Wj,
        votingproposalbuilder_get_plutus_witnesses: qj,
        votingproposalbuilder_get_ref_inputs: Hj,
        votingproposalbuilder_has_plutus_scripts: Gj,
        votingproposalbuilder_new: XA,
        votingproposals_add: hA,
        votingproposals_contains: bA,
        votingproposals_from_bytes: dA,
        votingproposals_from_hex: pA,
        votingproposals_from_json: gA,
        votingproposals_get: wA,
        votingproposals_len: YA,
        votingproposals_new: $A,
        votingproposals_to_bytes: cA,
        votingproposals_to_hex: lA,
        votingproposals_to_js_value: fA,
        votingproposals_to_json: uA,
        votingproposals_to_option: yA,
        vrfcert_from_bytes: Fq,
        vrfcert_from_hex: Uq,
        vrfcert_from_json: Pq,
        vrfcert_new: Kq,
        vrfcert_output: Vq,
        vrfcert_proof: Mq,
        vrfcert_to_bytes: Lq,
        vrfcert_to_hex: Oq,
        vrfcert_to_js_value: Dq,
        vrfcert_to_json: zq,
        vrfkeyhash_from_bech32: _D,
        vrfkeyhash_from_bytes: rD,
        vrfkeyhash_from_hex: nD,
        vrfkeyhash_to_bech32: _P,
        vrfkeyhash_to_bytes: HD,
        vrfkeyhash_to_hex: zD,
        vrfvkey_from_bech32: gD,
        vrfvkey_from_bytes: fD,
        vrfvkey_from_hex: wD,
        vrfvkey_to_bech32: pP,
        vrfvkey_to_bytes: tP,
        vrfvkey_to_hex: MD,
        withdrawals_from_bytes: _m,
        withdrawals_from_hex: am,
        withdrawals_from_json: im,
        withdrawals_get: dm,
        withdrawals_insert: cm,
        withdrawals_keys: lm,
        withdrawals_len: g4,
        withdrawals_new: T4,
        withdrawals_to_bytes: rm,
        withdrawals_to_hex: nm,
        withdrawals_to_js_value: sm,
        withdrawals_to_json: om,
        withdrawalsbuilder_add: CI,
        withdrawalsbuilder_add_with_native_script: TI,
        withdrawalsbuilder_add_with_plutus_witness: SI,
        withdrawalsbuilder_build: NI,
        withdrawalsbuilder_get_native_scripts: II,
        withdrawalsbuilder_get_plutus_witnesses: jI,
        withdrawalsbuilder_get_ref_inputs: AI,
        withdrawalsbuilder_get_total_withdrawals: BI,
        withdrawalsbuilder_has_plutus_scripts: RI,
        withdrawalsbuilder_new: w9
      }, Symbol.toStringTag, {
        value: "Module"
      }));
      Cl(xW);
      function yd(d, t) {
        return function() {
          return d.apply(t, arguments);
        };
      }
      const { toString: EW } = Object.prototype, { getPrototypeOf: wo } = Object, { iterator: oa, toStringTag: vd } = Symbol, sa = /* @__PURE__ */ ((d) => (t) => {
        const e = EW.call(t);
        return d[e] || (d[e] = e.slice(8, -1).toLowerCase());
      })(/* @__PURE__ */ Object.create(null)), nr = (d) => (d = d.toLowerCase(), (t) => sa(t) === d), ia = (d) => (t) => typeof t === d, { isArray: xn } = Array, Ln = ia("undefined");
      function Fn(d) {
        return d !== null && !Ln(d) && d.constructor !== null && !Ln(d.constructor) && Oe(d.constructor.isBuffer) && d.constructor.isBuffer(d);
      }
      const md = nr("ArrayBuffer");
      function CW(d) {
        let t;
        return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(d) : t = d && d.buffer && md(d.buffer), t;
      }
      const SW = ia("string"), Oe = ia("function"), kd = ia("number"), On = (d) => d !== null && typeof d == "object", TW = (d) => d === true || d === false, Jn = (d) => {
        if (sa(d) !== "object") return false;
        const t = wo(d);
        return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(vd in d) && !(oa in d);
      }, jW = (d) => {
        if (!On(d) || Fn(d)) return false;
        try {
          return Object.keys(d).length === 0 && Object.getPrototypeOf(d) === Object.prototype;
        } catch {
          return false;
        }
      }, AW = nr("Date"), IW = nr("File"), BW = nr("Blob"), RW = nr("FileList"), NW = (d) => On(d) && Oe(d.pipe), LW = (d) => {
        let t;
        return d && (typeof FormData == "function" && d instanceof FormData || Oe(d.append) && ((t = sa(d)) === "formdata" || t === "object" && Oe(d.toString) && d.toString() === "[object FormData]"));
      }, FW = nr("URLSearchParams"), [OW, UW, zW, DW] = [
        "ReadableStream",
        "Request",
        "Response",
        "Headers"
      ].map(nr), PW = (d) => d.trim ? d.trim() : d.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
      function Un(d, t, { allOwnKeys: e = false } = {}) {
        if (d === null || typeof d > "u") return;
        let a, n;
        if (typeof d != "object" && (d = [
          d
        ]), xn(d)) for (a = 0, n = d.length; a < n; a++) t.call(null, d[a], a, d);
        else {
          if (Fn(d)) return;
          const _ = e ? Object.getOwnPropertyNames(d) : Object.keys(d), c = _.length;
          let s;
          for (a = 0; a < c; a++) s = _[a], t.call(null, d[s], s, d);
        }
      }
      function xd(d, t) {
        if (Fn(d)) return null;
        t = t.toLowerCase();
        const e = Object.keys(d);
        let a = e.length, n;
        for (; a-- > 0; ) if (n = e[a], t === n.toLowerCase()) return n;
        return null;
      }
      const dn = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : globalThis, Ed = (d) => !Ln(d) && d !== dn;
      function co() {
        const { caseless: d } = Ed(this) && this || {}, t = {}, e = (a, n) => {
          const _ = d && xd(t, n) || n;
          Jn(t[_]) && Jn(a) ? t[_] = co(t[_], a) : Jn(a) ? t[_] = co({}, a) : xn(a) ? t[_] = a.slice() : t[_] = a;
        };
        for (let a = 0, n = arguments.length; a < n; a++) arguments[a] && Un(arguments[a], e);
        return t;
      }
      const VW = (d, t, e, { allOwnKeys: a } = {}) => (Un(t, (n, _) => {
        e && Oe(n) ? d[_] = yd(n, e) : d[_] = n;
      }, {
        allOwnKeys: a
      }), d), MW = (d) => (d.charCodeAt(0) === 65279 && (d = d.slice(1)), d), KW = (d, t, e, a) => {
        d.prototype = Object.create(t.prototype, a), d.prototype.constructor = d, Object.defineProperty(d, "super", {
          value: t.prototype
        }), e && Object.assign(d.prototype, e);
      }, qW = (d, t, e, a) => {
        let n, _, c;
        const s = {};
        if (t = t || {}, d == null) return t;
        do {
          for (n = Object.getOwnPropertyNames(d), _ = n.length; _-- > 0; ) c = n[_], (!a || a(c, d, t)) && !s[c] && (t[c] = d[c], s[c] = true);
          d = e !== false && wo(d);
        } while (d && (!e || e(d, t)) && d !== Object.prototype);
        return t;
      }, HW = (d, t, e) => {
        d = String(d), (e === void 0 || e > d.length) && (e = d.length), e -= t.length;
        const a = d.indexOf(t, e);
        return a !== -1 && a === e;
      }, GW = (d) => {
        if (!d) return null;
        if (xn(d)) return d;
        let t = d.length;
        if (!kd(t)) return null;
        const e = new Array(t);
        for (; t-- > 0; ) e[t] = d[t];
        return e;
      }, WW = /* @__PURE__ */ ((d) => (t) => d && t instanceof d)(typeof Uint8Array < "u" && wo(Uint8Array)), QW = (d, t) => {
        const a = (d && d[oa]).call(d);
        let n;
        for (; (n = a.next()) && !n.done; ) {
          const _ = n.value;
          t.call(d, _[0], _[1]);
        }
      }, $W = (d, t) => {
        let e;
        const a = [];
        for (; (e = d.exec(t)) !== null; ) a.push(e);
        return a;
      }, YW = nr("HTMLFormElement"), XW = (d) => d.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(e, a, n) {
        return a.toUpperCase() + n;
      }), dc = (({ hasOwnProperty: d }) => (t, e) => d.call(t, e))(Object.prototype), JW = nr("RegExp"), Cd = (d, t) => {
        const e = Object.getOwnPropertyDescriptors(d), a = {};
        Un(e, (n, _) => {
          let c;
          (c = t(n, _, d)) !== false && (a[_] = c || n);
        }), Object.defineProperties(d, a);
      }, ZW = (d) => {
        Cd(d, (t, e) => {
          if (Oe(d) && [
            "arguments",
            "caller",
            "callee"
          ].indexOf(e) !== -1) return false;
          const a = d[e];
          if (Oe(a)) {
            if (t.enumerable = false, "writable" in t) {
              t.writable = false;
              return;
            }
            t.set || (t.set = () => {
              throw Error("Can not rewrite read-only method '" + e + "'");
            });
          }
        });
      }, tQ = (d, t) => {
        const e = {}, a = (n) => {
          n.forEach((_) => {
            e[_] = true;
          });
        };
        return xn(d) ? a(d) : a(String(d).split(t)), e;
      }, eQ = () => {
      }, rQ = (d, t) => d != null && Number.isFinite(d = +d) ? d : t;
      function _Q(d) {
        return !!(d && Oe(d.append) && d[vd] === "FormData" && d[oa]);
      }
      const nQ = (d) => {
        const t = new Array(10), e = (a, n) => {
          if (On(a)) {
            if (t.indexOf(a) >= 0) return;
            if (Fn(a)) return a;
            if (!("toJSON" in a)) {
              t[n] = a;
              const _ = xn(a) ? [] : {};
              return Un(a, (c, s) => {
                const p = e(c, n + 1);
                !Ln(p) && (_[s] = p);
              }), t[n] = void 0, _;
            }
          }
          return a;
        };
        return e(d, 0);
      }, aQ = nr("AsyncFunction"), oQ = (d) => d && (On(d) || Oe(d)) && Oe(d.then) && Oe(d.catch), Sd = ((d, t) => d ? setImmediate : t ? ((e, a) => (dn.addEventListener("message", ({ source: n, data: _ }) => {
        n === dn && _ === e && a.length && a.shift()();
      }, false), (n) => {
        a.push(n), dn.postMessage(e, "*");
      }))(`axios@${Math.random()}`, []) : (e) => setTimeout(e))(typeof setImmediate == "function", Oe(dn.postMessage)), sQ = typeof queueMicrotask < "u" ? queueMicrotask.bind(dn) : typeof process < "u" && process.nextTick || Sd, iQ = (d) => d != null && Oe(d[oa]), st = {
        isArray: xn,
        isArrayBuffer: md,
        isBuffer: Fn,
        isFormData: LW,
        isArrayBufferView: CW,
        isString: SW,
        isNumber: kd,
        isBoolean: TW,
        isObject: On,
        isPlainObject: Jn,
        isEmptyObject: jW,
        isReadableStream: OW,
        isRequest: UW,
        isResponse: zW,
        isHeaders: DW,
        isUndefined: Ln,
        isDate: AW,
        isFile: IW,
        isBlob: BW,
        isRegExp: JW,
        isFunction: Oe,
        isStream: NW,
        isURLSearchParams: FW,
        isTypedArray: WW,
        isFileList: RW,
        forEach: Un,
        merge: co,
        extend: VW,
        trim: PW,
        stripBOM: MW,
        inherits: KW,
        toFlatObject: qW,
        kindOf: sa,
        kindOfTest: nr,
        endsWith: HW,
        toArray: GW,
        forEachEntry: QW,
        matchAll: $W,
        isHTMLForm: YW,
        hasOwnProperty: dc,
        hasOwnProp: dc,
        reduceDescriptors: Cd,
        freezeMethods: ZW,
        toObjectSet: tQ,
        toCamelCase: XW,
        noop: eQ,
        toFiniteNumber: rQ,
        findKey: xd,
        global: dn,
        isContextDefined: Ed,
        isSpecCompliantForm: _Q,
        toJSONObject: nQ,
        isAsyncFn: aQ,
        isThenable: oQ,
        setImmediate: Sd,
        asap: sQ,
        isIterable: iQ
      };
      function At(d, t, e, a, n) {
        Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = d, this.name = "AxiosError", t && (this.code = t), e && (this.config = e), a && (this.request = a), n && (this.response = n, this.status = n.status ? n.status : null);
      }
      st.inherits(At, Error, {
        toJSON: function() {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: st.toJSONObject(this.config),
            code: this.code,
            status: this.status
          };
        }
      });
      const Td = At.prototype, jd = {};
      [
        "ERR_BAD_OPTION_VALUE",
        "ERR_BAD_OPTION",
        "ECONNABORTED",
        "ETIMEDOUT",
        "ERR_NETWORK",
        "ERR_FR_TOO_MANY_REDIRECTS",
        "ERR_DEPRECATED",
        "ERR_BAD_RESPONSE",
        "ERR_BAD_REQUEST",
        "ERR_CANCELED",
        "ERR_NOT_SUPPORT",
        "ERR_INVALID_URL"
      ].forEach((d) => {
        jd[d] = {
          value: d
        };
      });
      Object.defineProperties(At, jd);
      Object.defineProperty(Td, "isAxiosError", {
        value: true
      });
      At.from = (d, t, e, a, n, _) => {
        const c = Object.create(Td);
        return st.toFlatObject(d, c, function(p) {
          return p !== Error.prototype;
        }, (s) => s !== "isAxiosError"), At.call(c, d.message, t, e, a, n), c.cause = d, c.name = d.name, _ && Object.assign(c, _), c;
      };
      const cQ = null;
      function lo(d) {
        return st.isPlainObject(d) || st.isArray(d);
      }
      function Ad(d) {
        return st.endsWith(d, "[]") ? d.slice(0, -2) : d;
      }
      function lc(d, t, e) {
        return d ? d.concat(t).map(function(n, _) {
          return n = Ad(n), !e && _ ? "[" + n + "]" : n;
        }).join(e ? "." : "") : t;
      }
      function dQ(d) {
        return st.isArray(d) && !d.some(lo);
      }
      const lQ = st.toFlatObject(st, {}, null, function(t) {
        return /^is[A-Z]/.test(t);
      });
      function ca(d, t, e) {
        if (!st.isObject(d)) throw new TypeError("target must be an object");
        t = t || new FormData(), e = st.toFlatObject(e, {
          metaTokens: true,
          dots: false,
          indexes: false
        }, false, function(A, T) {
          return !st.isUndefined(T[A]);
        });
        const a = e.metaTokens, n = e.visitor || y, _ = e.dots, c = e.indexes, p = (e.Blob || typeof Blob < "u" && Blob) && st.isSpecCompliantForm(t);
        if (!st.isFunction(n)) throw new TypeError("visitor must be a function");
        function l(C) {
          if (C === null) return "";
          if (st.isDate(C)) return C.toISOString();
          if (st.isBoolean(C)) return C.toString();
          if (!p && st.isBlob(C)) throw new At("Blob is not supported. Use a Buffer instead.");
          return st.isArrayBuffer(C) || st.isTypedArray(C) ? p && typeof Blob == "function" ? new Blob([
            C
          ]) : Buffer.from(C) : C;
        }
        function y(C, A, T) {
          let h = C;
          if (C && !T && typeof C == "object") {
            if (st.endsWith(A, "{}")) A = a ? A : A.slice(0, -2), C = JSON.stringify(C);
            else if (st.isArray(C) && dQ(C) || (st.isFileList(C) || st.endsWith(A, "[]")) && (h = st.toArray(C))) return A = Ad(A), h.forEach(function(S, N) {
              !(st.isUndefined(S) || S === null) && t.append(c === true ? lc([
                A
              ], N, _) : c === null ? A : A + "[]", l(S));
            }), false;
          }
          return lo(C) ? true : (t.append(lc(T, A, _), l(C)), false);
        }
        const R = [], j = Object.assign(lQ, {
          defaultVisitor: y,
          convertValue: l,
          isVisitable: lo
        });
        function b(C, A) {
          if (!st.isUndefined(C)) {
            if (R.indexOf(C) !== -1) throw Error("Circular reference detected in " + A.join("."));
            R.push(C), st.forEach(C, function(h, k) {
              (!(st.isUndefined(h) || h === null) && n.call(t, h, st.isString(k) ? k.trim() : k, A, j)) === true && b(h, A ? A.concat(k) : [
                k
              ]);
            }), R.pop();
          }
        }
        if (!st.isObject(d)) throw new TypeError("data must be an object");
        return b(d), t;
      }
      function pc(d) {
        const t = {
          "!": "%21",
          "'": "%27",
          "(": "%28",
          ")": "%29",
          "~": "%7E",
          "%20": "+",
          "%00": "\0"
        };
        return encodeURIComponent(d).replace(/[!'()~]|%20|%00/g, function(a) {
          return t[a];
        });
      }
      function ho(d, t) {
        this._pairs = [], d && ca(d, this, t);
      }
      const Id = ho.prototype;
      Id.append = function(t, e) {
        this._pairs.push([
          t,
          e
        ]);
      };
      Id.toString = function(t) {
        const e = t ? function(a) {
          return t.call(this, a, pc);
        } : pc;
        return this._pairs.map(function(n) {
          return e(n[0]) + "=" + e(n[1]);
        }, "").join("&");
      };
      function pQ(d) {
        return encodeURIComponent(d).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      function Bd(d, t, e) {
        if (!t) return d;
        const a = e && e.encode || pQ;
        st.isFunction(e) && (e = {
          serialize: e
        });
        const n = e && e.serialize;
        let _;
        if (n ? _ = n(t, e) : _ = st.isURLSearchParams(t) ? t.toString() : new ho(t, e).toString(a), _) {
          const c = d.indexOf("#");
          c !== -1 && (d = d.slice(0, c)), d += (d.indexOf("?") === -1 ? "?" : "&") + _;
        }
        return d;
      }
      class uc {
        constructor() {
          this.handlers = [];
        }
        use(t, e, a) {
          return this.handlers.push({
            fulfilled: t,
            rejected: e,
            synchronous: a ? a.synchronous : false,
            runWhen: a ? a.runWhen : null
          }), this.handlers.length - 1;
        }
        eject(t) {
          this.handlers[t] && (this.handlers[t] = null);
        }
        clear() {
          this.handlers && (this.handlers = []);
        }
        forEach(t) {
          st.forEach(this.handlers, function(a) {
            a !== null && t(a);
          });
        }
      }
      const Rd = {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      }, uQ = typeof URLSearchParams < "u" ? URLSearchParams : ho, fQ = typeof FormData < "u" ? FormData : null, gQ = typeof Blob < "u" ? Blob : null, wQ = {
        isBrowser: true,
        classes: {
          URLSearchParams: uQ,
          FormData: fQ,
          Blob: gQ
        },
        protocols: [
          "http",
          "https",
          "file",
          "blob",
          "url",
          "data"
        ]
      }, bo = typeof window < "u" && typeof document < "u", po = typeof navigator == "object" && navigator || void 0, hQ = bo && (!po || [
        "ReactNative",
        "NativeScript",
        "NS"
      ].indexOf(po.product) < 0), bQ = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", yQ = bo && window.location.href || "http://localhost", vQ = Object.freeze(Object.defineProperty({
        __proto__: null,
        hasBrowserEnv: bo,
        hasStandardBrowserEnv: hQ,
        hasStandardBrowserWebWorkerEnv: bQ,
        navigator: po,
        origin: yQ
      }, Symbol.toStringTag, {
        value: "Module"
      })), je = {
        ...vQ,
        ...wQ
      };
      function mQ(d, t) {
        return ca(d, new je.classes.URLSearchParams(), {
          visitor: function(e, a, n, _) {
            return je.isNode && st.isBuffer(e) ? (this.append(a, e.toString("base64")), false) : _.defaultVisitor.apply(this, arguments);
          },
          ...t
        });
      }
      function kQ(d) {
        return st.matchAll(/\w+|\[(\w*)]/g, d).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
      }
      function xQ(d) {
        const t = {}, e = Object.keys(d);
        let a;
        const n = e.length;
        let _;
        for (a = 0; a < n; a++) _ = e[a], t[_] = d[_];
        return t;
      }
      function Nd(d) {
        function t(e, a, n, _) {
          let c = e[_++];
          if (c === "__proto__") return true;
          const s = Number.isFinite(+c), p = _ >= e.length;
          return c = !c && st.isArray(n) ? n.length : c, p ? (st.hasOwnProp(n, c) ? n[c] = [
            n[c],
            a
          ] : n[c] = a, !s) : ((!n[c] || !st.isObject(n[c])) && (n[c] = []), t(e, a, n[c], _) && st.isArray(n[c]) && (n[c] = xQ(n[c])), !s);
        }
        if (st.isFormData(d) && st.isFunction(d.entries)) {
          const e = {};
          return st.forEachEntry(d, (a, n) => {
            t(kQ(a), n, e, 0);
          }), e;
        }
        return null;
      }
      function EQ(d, t, e) {
        if (st.isString(d)) try {
          return (t || JSON.parse)(d), st.trim(d);
        } catch (a) {
          if (a.name !== "SyntaxError") throw a;
        }
        return (e || JSON.stringify)(d);
      }
      const zn = {
        transitional: Rd,
        adapter: [
          "xhr",
          "http",
          "fetch"
        ],
        transformRequest: [
          function(t, e) {
            const a = e.getContentType() || "", n = a.indexOf("application/json") > -1, _ = st.isObject(t);
            if (_ && st.isHTMLForm(t) && (t = new FormData(t)), st.isFormData(t)) return n ? JSON.stringify(Nd(t)) : t;
            if (st.isArrayBuffer(t) || st.isBuffer(t) || st.isStream(t) || st.isFile(t) || st.isBlob(t) || st.isReadableStream(t)) return t;
            if (st.isArrayBufferView(t)) return t.buffer;
            if (st.isURLSearchParams(t)) return e.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), t.toString();
            let s;
            if (_) {
              if (a.indexOf("application/x-www-form-urlencoded") > -1) return mQ(t, this.formSerializer).toString();
              if ((s = st.isFileList(t)) || a.indexOf("multipart/form-data") > -1) {
                const p = this.env && this.env.FormData;
                return ca(s ? {
                  "files[]": t
                } : t, p && new p(), this.formSerializer);
              }
            }
            return _ || n ? (e.setContentType("application/json", false), EQ(t)) : t;
          }
        ],
        transformResponse: [
          function(t) {
            const e = this.transitional || zn.transitional, a = e && e.forcedJSONParsing, n = this.responseType === "json";
            if (st.isResponse(t) || st.isReadableStream(t)) return t;
            if (t && st.isString(t) && (a && !this.responseType || n)) {
              const c = !(e && e.silentJSONParsing) && n;
              try {
                return JSON.parse(t);
              } catch (s) {
                if (c) throw s.name === "SyntaxError" ? At.from(s, At.ERR_BAD_RESPONSE, this, null, this.response) : s;
              }
            }
            return t;
          }
        ],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
          FormData: je.classes.FormData,
          Blob: je.classes.Blob
        },
        validateStatus: function(t) {
          return t >= 200 && t < 300;
        },
        headers: {
          common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
          }
        }
      };
      st.forEach([
        "delete",
        "get",
        "head",
        "post",
        "put",
        "patch"
      ], (d) => {
        zn.headers[d] = {};
      });
      const CQ = st.toObjectSet([
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ]), SQ = (d) => {
        const t = {};
        let e, a, n;
        return d && d.split(`
`).forEach(function(c) {
          n = c.indexOf(":"), e = c.substring(0, n).trim().toLowerCase(), a = c.substring(n + 1).trim(), !(!e || t[e] && CQ[e]) && (e === "set-cookie" ? t[e] ? t[e].push(a) : t[e] = [
            a
          ] : t[e] = t[e] ? t[e] + ", " + a : a);
        }), t;
      }, fc = Symbol("internals");
      function Tn(d) {
        return d && String(d).trim().toLowerCase();
      }
      function Zn(d) {
        return d === false || d == null ? d : st.isArray(d) ? d.map(Zn) : String(d);
      }
      function TQ(d) {
        const t = /* @__PURE__ */ Object.create(null), e = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
        let a;
        for (; a = e.exec(d); ) t[a[1]] = a[2];
        return t;
      }
      const jQ = (d) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(d.trim());
      function wa(d, t, e, a, n) {
        if (st.isFunction(a)) return a.call(this, t, e);
        if (n && (t = e), !!st.isString(t)) {
          if (st.isString(a)) return t.indexOf(a) !== -1;
          if (st.isRegExp(a)) return a.test(t);
        }
      }
      function AQ(d) {
        return d.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, e, a) => e.toUpperCase() + a);
      }
      function IQ(d, t) {
        const e = st.toCamelCase(" " + t);
        [
          "get",
          "set",
          "has"
        ].forEach((a) => {
          Object.defineProperty(d, a + e, {
            value: function(n, _, c) {
              return this[a].call(this, t, n, _, c);
            },
            configurable: true
          });
        });
      }
      let Ue = class {
        constructor(t) {
          t && this.set(t);
        }
        set(t, e, a) {
          const n = this;
          function _(s, p, l) {
            const y = Tn(p);
            if (!y) throw new Error("header name must be a non-empty string");
            const R = st.findKey(n, y);
            (!R || n[R] === void 0 || l === true || l === void 0 && n[R] !== false) && (n[R || p] = Zn(s));
          }
          const c = (s, p) => st.forEach(s, (l, y) => _(l, y, p));
          if (st.isPlainObject(t) || t instanceof this.constructor) c(t, e);
          else if (st.isString(t) && (t = t.trim()) && !jQ(t)) c(SQ(t), e);
          else if (st.isObject(t) && st.isIterable(t)) {
            let s = {}, p, l;
            for (const y of t) {
              if (!st.isArray(y)) throw TypeError("Object iterator must return a key-value pair");
              s[l = y[0]] = (p = s[l]) ? st.isArray(p) ? [
                ...p,
                y[1]
              ] : [
                p,
                y[1]
              ] : y[1];
            }
            c(s, e);
          } else t != null && _(e, t, a);
          return this;
        }
        get(t, e) {
          if (t = Tn(t), t) {
            const a = st.findKey(this, t);
            if (a) {
              const n = this[a];
              if (!e) return n;
              if (e === true) return TQ(n);
              if (st.isFunction(e)) return e.call(this, n, a);
              if (st.isRegExp(e)) return e.exec(n);
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(t, e) {
          if (t = Tn(t), t) {
            const a = st.findKey(this, t);
            return !!(a && this[a] !== void 0 && (!e || wa(this, this[a], a, e)));
          }
          return false;
        }
        delete(t, e) {
          const a = this;
          let n = false;
          function _(c) {
            if (c = Tn(c), c) {
              const s = st.findKey(a, c);
              s && (!e || wa(a, a[s], s, e)) && (delete a[s], n = true);
            }
          }
          return st.isArray(t) ? t.forEach(_) : _(t), n;
        }
        clear(t) {
          const e = Object.keys(this);
          let a = e.length, n = false;
          for (; a--; ) {
            const _ = e[a];
            (!t || wa(this, this[_], _, t, true)) && (delete this[_], n = true);
          }
          return n;
        }
        normalize(t) {
          const e = this, a = {};
          return st.forEach(this, (n, _) => {
            const c = st.findKey(a, _);
            if (c) {
              e[c] = Zn(n), delete e[_];
              return;
            }
            const s = t ? AQ(_) : String(_).trim();
            s !== _ && delete e[_], e[s] = Zn(n), a[s] = true;
          }), this;
        }
        concat(...t) {
          return this.constructor.concat(this, ...t);
        }
        toJSON(t) {
          const e = /* @__PURE__ */ Object.create(null);
          return st.forEach(this, (a, n) => {
            a != null && a !== false && (e[n] = t && st.isArray(a) ? a.join(", ") : a);
          }), e;
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON()).map(([t, e]) => t + ": " + e).join(`
`);
        }
        getSetCookie() {
          return this.get("set-cookie") || [];
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(t) {
          return t instanceof this ? t : new this(t);
        }
        static concat(t, ...e) {
          const a = new this(t);
          return e.forEach((n) => a.set(n)), a;
        }
        static accessor(t) {
          const a = (this[fc] = this[fc] = {
            accessors: {}
          }).accessors, n = this.prototype;
          function _(c) {
            const s = Tn(c);
            a[s] || (IQ(n, c), a[s] = true);
          }
          return st.isArray(t) ? t.forEach(_) : _(t), this;
        }
      };
      Ue.accessor([
        "Content-Type",
        "Content-Length",
        "Accept",
        "Accept-Encoding",
        "User-Agent",
        "Authorization"
      ]);
      st.reduceDescriptors(Ue.prototype, ({ value: d }, t) => {
        let e = t[0].toUpperCase() + t.slice(1);
        return {
          get: () => d,
          set(a) {
            this[e] = a;
          }
        };
      });
      st.freezeMethods(Ue);
      function ha(d, t) {
        const e = this || zn, a = t || e, n = Ue.from(a.headers);
        let _ = a.data;
        return st.forEach(d, function(s) {
          _ = s.call(e, _, n.normalize(), t ? t.status : void 0);
        }), n.normalize(), _;
      }
      function Ld(d) {
        return !!(d && d.__CANCEL__);
      }
      function En(d, t, e) {
        At.call(this, d ?? "canceled", At.ERR_CANCELED, t, e), this.name = "CanceledError";
      }
      st.inherits(En, At, {
        __CANCEL__: true
      });
      function Fd(d, t, e) {
        const a = e.config.validateStatus;
        !e.status || !a || a(e.status) ? d(e) : t(new At("Request failed with status code " + e.status, [
          At.ERR_BAD_REQUEST,
          At.ERR_BAD_RESPONSE
        ][Math.floor(e.status / 100) - 4], e.config, e.request, e));
      }
      function BQ(d) {
        const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(d);
        return t && t[1] || "";
      }
      function RQ(d, t) {
        d = d || 10;
        const e = new Array(d), a = new Array(d);
        let n = 0, _ = 0, c;
        return t = t !== void 0 ? t : 1e3, function(p) {
          const l = Date.now(), y = a[_];
          c || (c = l), e[n] = p, a[n] = l;
          let R = _, j = 0;
          for (; R !== n; ) j += e[R++], R = R % d;
          if (n = (n + 1) % d, n === _ && (_ = (_ + 1) % d), l - c < t) return;
          const b = y && l - y;
          return b ? Math.round(j * 1e3 / b) : void 0;
        };
      }
      function NQ(d, t) {
        let e = 0, a = 1e3 / t, n, _;
        const c = (l, y = Date.now()) => {
          e = y, n = null, _ && (clearTimeout(_), _ = null), d(...l);
        };
        return [
          (...l) => {
            const y = Date.now(), R = y - e;
            R >= a ? c(l, y) : (n = l, _ || (_ = setTimeout(() => {
              _ = null, c(n);
            }, a - R)));
          },
          () => n && c(n)
        ];
      }
      const na = (d, t, e = 3) => {
        let a = 0;
        const n = RQ(50, 250);
        return NQ((_) => {
          const c = _.loaded, s = _.lengthComputable ? _.total : void 0, p = c - a, l = n(p), y = c <= s;
          a = c;
          const R = {
            loaded: c,
            total: s,
            progress: s ? c / s : void 0,
            bytes: p,
            rate: l || void 0,
            estimated: l && s && y ? (s - c) / l : void 0,
            event: _,
            lengthComputable: s != null,
            [t ? "download" : "upload"]: true
          };
          d(R);
        }, e);
      }, gc = (d, t) => {
        const e = d != null;
        return [
          (a) => t[0]({
            lengthComputable: e,
            total: d,
            loaded: a
          }),
          t[1]
        ];
      }, wc = (d) => (...t) => st.asap(() => d(...t)), LQ = je.hasStandardBrowserEnv ? /* @__PURE__ */ ((d, t) => (e) => (e = new URL(e, je.origin), d.protocol === e.protocol && d.host === e.host && (t || d.port === e.port)))(new URL(je.origin), je.navigator && /(msie|trident)/i.test(je.navigator.userAgent)) : () => true, FQ = je.hasStandardBrowserEnv ? {
        write(d, t, e, a, n, _) {
          const c = [
            d + "=" + encodeURIComponent(t)
          ];
          st.isNumber(e) && c.push("expires=" + new Date(e).toGMTString()), st.isString(a) && c.push("path=" + a), st.isString(n) && c.push("domain=" + n), _ === true && c.push("secure"), document.cookie = c.join("; ");
        },
        read(d) {
          const t = document.cookie.match(new RegExp("(^|;\\s*)(" + d + ")=([^;]*)"));
          return t ? decodeURIComponent(t[3]) : null;
        },
        remove(d) {
          this.write(d, "", Date.now() - 864e5);
        }
      } : {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      };
      function OQ(d) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(d);
      }
      function UQ(d, t) {
        return t ? d.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : d;
      }
      function Od(d, t, e) {
        let a = !OQ(t);
        return d && (a || e == false) ? UQ(d, t) : t;
      }
      const hc = (d) => d instanceof Ue ? {
        ...d
      } : d;
      function un(d, t) {
        t = t || {};
        const e = {};
        function a(l, y, R, j) {
          return st.isPlainObject(l) && st.isPlainObject(y) ? st.merge.call({
            caseless: j
          }, l, y) : st.isPlainObject(y) ? st.merge({}, y) : st.isArray(y) ? y.slice() : y;
        }
        function n(l, y, R, j) {
          if (st.isUndefined(y)) {
            if (!st.isUndefined(l)) return a(void 0, l, R, j);
          } else return a(l, y, R, j);
        }
        function _(l, y) {
          if (!st.isUndefined(y)) return a(void 0, y);
        }
        function c(l, y) {
          if (st.isUndefined(y)) {
            if (!st.isUndefined(l)) return a(void 0, l);
          } else return a(void 0, y);
        }
        function s(l, y, R) {
          if (R in t) return a(l, y);
          if (R in d) return a(void 0, l);
        }
        const p = {
          url: _,
          method: _,
          data: _,
          baseURL: c,
          transformRequest: c,
          transformResponse: c,
          paramsSerializer: c,
          timeout: c,
          timeoutMessage: c,
          withCredentials: c,
          withXSRFToken: c,
          adapter: c,
          responseType: c,
          xsrfCookieName: c,
          xsrfHeaderName: c,
          onUploadProgress: c,
          onDownloadProgress: c,
          decompress: c,
          maxContentLength: c,
          maxBodyLength: c,
          beforeRedirect: c,
          transport: c,
          httpAgent: c,
          httpsAgent: c,
          cancelToken: c,
          socketPath: c,
          responseEncoding: c,
          validateStatus: s,
          headers: (l, y, R) => n(hc(l), hc(y), R, true)
        };
        return st.forEach(Object.keys({
          ...d,
          ...t
        }), function(y) {
          const R = p[y] || n, j = R(d[y], t[y], y);
          st.isUndefined(j) && R !== s || (e[y] = j);
        }), e;
      }
      const Ud = (d) => {
        const t = un({}, d);
        let { data: e, withXSRFToken: a, xsrfHeaderName: n, xsrfCookieName: _, headers: c, auth: s } = t;
        t.headers = c = Ue.from(c), t.url = Bd(Od(t.baseURL, t.url, t.allowAbsoluteUrls), d.params, d.paramsSerializer), s && c.set("Authorization", "Basic " + btoa((s.username || "") + ":" + (s.password ? unescape(encodeURIComponent(s.password)) : "")));
        let p;
        if (st.isFormData(e)) {
          if (je.hasStandardBrowserEnv || je.hasStandardBrowserWebWorkerEnv) c.setContentType(void 0);
          else if ((p = c.getContentType()) !== false) {
            const [l, ...y] = p ? p.split(";").map((R) => R.trim()).filter(Boolean) : [];
            c.setContentType([
              l || "multipart/form-data",
              ...y
            ].join("; "));
          }
        }
        if (je.hasStandardBrowserEnv && (a && st.isFunction(a) && (a = a(t)), a || a !== false && LQ(t.url))) {
          const l = n && _ && FQ.read(_);
          l && c.set(n, l);
        }
        return t;
      }, zQ = typeof XMLHttpRequest < "u", DQ = zQ && function(d) {
        return new Promise(function(e, a) {
          const n = Ud(d);
          let _ = n.data;
          const c = Ue.from(n.headers).normalize();
          let { responseType: s, onUploadProgress: p, onDownloadProgress: l } = n, y, R, j, b, C;
          function A() {
            b && b(), C && C(), n.cancelToken && n.cancelToken.unsubscribe(y), n.signal && n.signal.removeEventListener("abort", y);
          }
          let T = new XMLHttpRequest();
          T.open(n.method.toUpperCase(), n.url, true), T.timeout = n.timeout;
          function h() {
            if (!T) return;
            const S = Ue.from("getAllResponseHeaders" in T && T.getAllResponseHeaders()), P = {
              data: !s || s === "text" || s === "json" ? T.responseText : T.response,
              status: T.status,
              statusText: T.statusText,
              headers: S,
              config: d,
              request: T
            };
            Fd(function(g) {
              e(g), A();
            }, function(g) {
              a(g), A();
            }, P), T = null;
          }
          "onloadend" in T ? T.onloadend = h : T.onreadystatechange = function() {
            !T || T.readyState !== 4 || T.status === 0 && !(T.responseURL && T.responseURL.indexOf("file:") === 0) || setTimeout(h);
          }, T.onabort = function() {
            T && (a(new At("Request aborted", At.ECONNABORTED, d, T)), T = null);
          }, T.onerror = function() {
            a(new At("Network Error", At.ERR_NETWORK, d, T)), T = null;
          }, T.ontimeout = function() {
            let N = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
            const P = n.transitional || Rd;
            n.timeoutErrorMessage && (N = n.timeoutErrorMessage), a(new At(N, P.clarifyTimeoutError ? At.ETIMEDOUT : At.ECONNABORTED, d, T)), T = null;
          }, _ === void 0 && c.setContentType(null), "setRequestHeader" in T && st.forEach(c.toJSON(), function(N, P) {
            T.setRequestHeader(P, N);
          }), st.isUndefined(n.withCredentials) || (T.withCredentials = !!n.withCredentials), s && s !== "json" && (T.responseType = n.responseType), l && ([j, C] = na(l, true), T.addEventListener("progress", j)), p && T.upload && ([R, b] = na(p), T.upload.addEventListener("progress", R), T.upload.addEventListener("loadend", b)), (n.cancelToken || n.signal) && (y = (S) => {
            T && (a(!S || S.type ? new En(null, d, T) : S), T.abort(), T = null);
          }, n.cancelToken && n.cancelToken.subscribe(y), n.signal && (n.signal.aborted ? y() : n.signal.addEventListener("abort", y)));
          const k = BQ(n.url);
          if (k && je.protocols.indexOf(k) === -1) {
            a(new At("Unsupported protocol " + k + ":", At.ERR_BAD_REQUEST, d));
            return;
          }
          T.send(_ || null);
        });
      }, PQ = (d, t) => {
        const { length: e } = d = d ? d.filter(Boolean) : [];
        if (t || e) {
          let a = new AbortController(), n;
          const _ = function(l) {
            if (!n) {
              n = true, s();
              const y = l instanceof Error ? l : this.reason;
              a.abort(y instanceof At ? y : new En(y instanceof Error ? y.message : y));
            }
          };
          let c = t && setTimeout(() => {
            c = null, _(new At(`timeout ${t} of ms exceeded`, At.ETIMEDOUT));
          }, t);
          const s = () => {
            d && (c && clearTimeout(c), c = null, d.forEach((l) => {
              l.unsubscribe ? l.unsubscribe(_) : l.removeEventListener("abort", _);
            }), d = null);
          };
          d.forEach((l) => l.addEventListener("abort", _));
          const { signal: p } = a;
          return p.unsubscribe = () => st.asap(s), p;
        }
      }, VQ = function* (d, t) {
        let e = d.byteLength;
        if (e < t) {
          yield d;
          return;
        }
        let a = 0, n;
        for (; a < e; ) n = a + t, yield d.slice(a, n), a = n;
      }, MQ = async function* (d, t) {
        for await (const e of KQ(d)) yield* VQ(e, t);
      }, KQ = async function* (d) {
        if (d[Symbol.asyncIterator]) {
          yield* d;
          return;
        }
        const t = d.getReader();
        try {
          for (; ; ) {
            const { done: e, value: a } = await t.read();
            if (e) break;
            yield a;
          }
        } finally {
          await t.cancel();
        }
      }, bc = (d, t, e, a) => {
        const n = MQ(d, t);
        let _ = 0, c, s = (p) => {
          c || (c = true, a && a(p));
        };
        return new ReadableStream({
          async pull(p) {
            try {
              const { done: l, value: y } = await n.next();
              if (l) {
                s(), p.close();
                return;
              }
              let R = y.byteLength;
              if (e) {
                let j = _ += R;
                e(j);
              }
              p.enqueue(new Uint8Array(y));
            } catch (l) {
              throw s(l), l;
            }
          },
          cancel(p) {
            return s(p), n.return();
          }
        }, {
          highWaterMark: 2
        });
      }, da = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", zd = da && typeof ReadableStream == "function", qQ = da && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((d) => (t) => d.encode(t))(new TextEncoder()) : async (d) => new Uint8Array(await new Response(d).arrayBuffer())), Dd = (d, ...t) => {
        try {
          return !!d(...t);
        } catch {
          return false;
        }
      }, HQ = zd && Dd(() => {
        let d = false;
        const t = new Request(je.origin, {
          body: new ReadableStream(),
          method: "POST",
          get duplex() {
            return d = true, "half";
          }
        }).headers.has("Content-Type");
        return d && !t;
      }), yc = 64 * 1024, uo = zd && Dd(() => st.isReadableStream(new Response("").body)), aa = {
        stream: uo && ((d) => d.body)
      };
      da && ((d) => {
        [
          "text",
          "arrayBuffer",
          "blob",
          "formData",
          "stream"
        ].forEach((t) => {
          !aa[t] && (aa[t] = st.isFunction(d[t]) ? (e) => e[t]() : (e, a) => {
            throw new At(`Response type '${t}' is not supported`, At.ERR_NOT_SUPPORT, a);
          });
        });
      })(new Response());
      const GQ = async (d) => {
        if (d == null) return 0;
        if (st.isBlob(d)) return d.size;
        if (st.isSpecCompliantForm(d)) return (await new Request(je.origin, {
          method: "POST",
          body: d
        }).arrayBuffer()).byteLength;
        if (st.isArrayBufferView(d) || st.isArrayBuffer(d)) return d.byteLength;
        if (st.isURLSearchParams(d) && (d = d + ""), st.isString(d)) return (await qQ(d)).byteLength;
      }, WQ = async (d, t) => {
        const e = st.toFiniteNumber(d.getContentLength());
        return e ?? GQ(t);
      }, QQ = da && (async (d) => {
        let { url: t, method: e, data: a, signal: n, cancelToken: _, timeout: c, onDownloadProgress: s, onUploadProgress: p, responseType: l, headers: y, withCredentials: R = "same-origin", fetchOptions: j } = Ud(d);
        l = l ? (l + "").toLowerCase() : "text";
        let b = PQ([
          n,
          _ && _.toAbortSignal()
        ], c), C;
        const A = b && b.unsubscribe && (() => {
          b.unsubscribe();
        });
        let T;
        try {
          if (p && HQ && e !== "get" && e !== "head" && (T = await WQ(y, a)) !== 0) {
            let P = new Request(t, {
              method: "POST",
              body: a,
              duplex: "half"
            }), v;
            if (st.isFormData(a) && (v = P.headers.get("content-type")) && y.setContentType(v), P.body) {
              const [g, u] = gc(T, na(wc(p)));
              a = bc(P.body, yc, g, u);
            }
          }
          st.isString(R) || (R = R ? "include" : "omit");
          const h = "credentials" in Request.prototype;
          C = new Request(t, {
            ...j,
            signal: b,
            method: e.toUpperCase(),
            headers: y.normalize().toJSON(),
            body: a,
            duplex: "half",
            credentials: h ? R : void 0
          });
          let k = await fetch(C, j);
          const S = uo && (l === "stream" || l === "response");
          if (uo && (s || S && A)) {
            const P = {};
            [
              "status",
              "statusText",
              "headers"
            ].forEach((F) => {
              P[F] = k[F];
            });
            const v = st.toFiniteNumber(k.headers.get("content-length")), [g, u] = s && gc(v, na(wc(s), true)) || [];
            k = new Response(bc(k.body, yc, g, () => {
              u && u(), A && A();
            }), P);
          }
          l = l || "text";
          let N = await aa[st.findKey(aa, l) || "text"](k, d);
          return !S && A && A(), await new Promise((P, v) => {
            Fd(P, v, {
              data: N,
              headers: Ue.from(k.headers),
              status: k.status,
              statusText: k.statusText,
              config: d,
              request: C
            });
          });
        } catch (h) {
          throw A && A(), h && h.name === "TypeError" && /Load failed|fetch/i.test(h.message) ? Object.assign(new At("Network Error", At.ERR_NETWORK, d, C), {
            cause: h.cause || h
          }) : At.from(h, h && h.code, d, C);
        }
      }), fo = {
        http: cQ,
        xhr: DQ,
        fetch: QQ
      };
      st.forEach(fo, (d, t) => {
        if (d) {
          try {
            Object.defineProperty(d, "name", {
              value: t
            });
          } catch {
          }
          Object.defineProperty(d, "adapterName", {
            value: t
          });
        }
      });
      const vc = (d) => `- ${d}`, $Q = (d) => st.isFunction(d) || d === null || d === false, Pd = {
        getAdapter: (d) => {
          d = st.isArray(d) ? d : [
            d
          ];
          const { length: t } = d;
          let e, a;
          const n = {};
          for (let _ = 0; _ < t; _++) {
            e = d[_];
            let c;
            if (a = e, !$Q(e) && (a = fo[(c = String(e)).toLowerCase()], a === void 0)) throw new At(`Unknown adapter '${c}'`);
            if (a) break;
            n[c || "#" + _] = a;
          }
          if (!a) {
            const _ = Object.entries(n).map(([s, p]) => `adapter ${s} ` + (p === false ? "is not supported by the environment" : "is not available in the build"));
            let c = t ? _.length > 1 ? `since :
` + _.map(vc).join(`
`) : " " + vc(_[0]) : "as no adapter specified";
            throw new At("There is no suitable adapter to dispatch the request " + c, "ERR_NOT_SUPPORT");
          }
          return a;
        },
        adapters: fo
      };
      function ba(d) {
        if (d.cancelToken && d.cancelToken.throwIfRequested(), d.signal && d.signal.aborted) throw new En(null, d);
      }
      function mc(d) {
        return ba(d), d.headers = Ue.from(d.headers), d.data = ha.call(d, d.transformRequest), [
          "post",
          "put",
          "patch"
        ].indexOf(d.method) !== -1 && d.headers.setContentType("application/x-www-form-urlencoded", false), Pd.getAdapter(d.adapter || zn.adapter)(d).then(function(a) {
          return ba(d), a.data = ha.call(d, d.transformResponse, a), a.headers = Ue.from(a.headers), a;
        }, function(a) {
          return Ld(a) || (ba(d), a && a.response && (a.response.data = ha.call(d, d.transformResponse, a.response), a.response.headers = Ue.from(a.response.headers))), Promise.reject(a);
        });
      }
      const Vd = "1.11.0", la = {};
      [
        "object",
        "boolean",
        "number",
        "function",
        "string",
        "symbol"
      ].forEach((d, t) => {
        la[d] = function(a) {
          return typeof a === d || "a" + (t < 1 ? "n " : " ") + d;
        };
      });
      const kc = {};
      la.transitional = function(t, e, a) {
        function n(_, c) {
          return "[Axios v" + Vd + "] Transitional option '" + _ + "'" + c + (a ? ". " + a : "");
        }
        return (_, c, s) => {
          if (t === false) throw new At(n(c, " has been removed" + (e ? " in " + e : "")), At.ERR_DEPRECATED);
          return e && !kc[c] && (kc[c] = true, console.warn(n(c, " has been deprecated since v" + e + " and will be removed in the near future"))), t ? t(_, c, s) : true;
        };
      };
      la.spelling = function(t) {
        return (e, a) => (console.warn(`${a} is likely a misspelling of ${t}`), true);
      };
      function YQ(d, t, e) {
        if (typeof d != "object") throw new At("options must be an object", At.ERR_BAD_OPTION_VALUE);
        const a = Object.keys(d);
        let n = a.length;
        for (; n-- > 0; ) {
          const _ = a[n], c = t[_];
          if (c) {
            const s = d[_], p = s === void 0 || c(s, _, d);
            if (p !== true) throw new At("option " + _ + " must be " + p, At.ERR_BAD_OPTION_VALUE);
            continue;
          }
          if (e !== true) throw new At("Unknown option " + _, At.ERR_BAD_OPTION);
        }
      }
      const ta = {
        assertOptions: YQ,
        validators: la
      }, sr = ta.validators;
      let pn = class {
        constructor(t) {
          this.defaults = t || {}, this.interceptors = {
            request: new uc(),
            response: new uc()
          };
        }
        async request(t, e) {
          try {
            return await this._request(t, e);
          } catch (a) {
            if (a instanceof Error) {
              let n = {};
              Error.captureStackTrace ? Error.captureStackTrace(n) : n = new Error();
              const _ = n.stack ? n.stack.replace(/^.+\n/, "") : "";
              try {
                a.stack ? _ && !String(a.stack).endsWith(_.replace(/^.+\n.+\n/, "")) && (a.stack += `
` + _) : a.stack = _;
              } catch {
              }
            }
            throw a;
          }
        }
        _request(t, e) {
          typeof t == "string" ? (e = e || {}, e.url = t) : e = t || {}, e = un(this.defaults, e);
          const { transitional: a, paramsSerializer: n, headers: _ } = e;
          a !== void 0 && ta.assertOptions(a, {
            silentJSONParsing: sr.transitional(sr.boolean),
            forcedJSONParsing: sr.transitional(sr.boolean),
            clarifyTimeoutError: sr.transitional(sr.boolean)
          }, false), n != null && (st.isFunction(n) ? e.paramsSerializer = {
            serialize: n
          } : ta.assertOptions(n, {
            encode: sr.function,
            serialize: sr.function
          }, true)), e.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? e.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : e.allowAbsoluteUrls = true), ta.assertOptions(e, {
            baseUrl: sr.spelling("baseURL"),
            withXsrfToken: sr.spelling("withXSRFToken")
          }, true), e.method = (e.method || this.defaults.method || "get").toLowerCase();
          let c = _ && st.merge(_.common, _[e.method]);
          _ && st.forEach([
            "delete",
            "get",
            "head",
            "post",
            "put",
            "patch",
            "common"
          ], (C) => {
            delete _[C];
          }), e.headers = Ue.concat(c, _);
          const s = [];
          let p = true;
          this.interceptors.request.forEach(function(A) {
            typeof A.runWhen == "function" && A.runWhen(e) === false || (p = p && A.synchronous, s.unshift(A.fulfilled, A.rejected));
          });
          const l = [];
          this.interceptors.response.forEach(function(A) {
            l.push(A.fulfilled, A.rejected);
          });
          let y, R = 0, j;
          if (!p) {
            const C = [
              mc.bind(this),
              void 0
            ];
            for (C.unshift(...s), C.push(...l), j = C.length, y = Promise.resolve(e); R < j; ) y = y.then(C[R++], C[R++]);
            return y;
          }
          j = s.length;
          let b = e;
          for (R = 0; R < j; ) {
            const C = s[R++], A = s[R++];
            try {
              b = C(b);
            } catch (T) {
              A.call(this, T);
              break;
            }
          }
          try {
            y = mc.call(this, b);
          } catch (C) {
            return Promise.reject(C);
          }
          for (R = 0, j = l.length; R < j; ) y = y.then(l[R++], l[R++]);
          return y;
        }
        getUri(t) {
          t = un(this.defaults, t);
          const e = Od(t.baseURL, t.url, t.allowAbsoluteUrls);
          return Bd(e, t.params, t.paramsSerializer);
        }
      };
      st.forEach([
        "delete",
        "get",
        "head",
        "options"
      ], function(t) {
        pn.prototype[t] = function(e, a) {
          return this.request(un(a || {}, {
            method: t,
            url: e,
            data: (a || {}).data
          }));
        };
      });
      st.forEach([
        "post",
        "put",
        "patch"
      ], function(t) {
        function e(a) {
          return function(_, c, s) {
            return this.request(un(s || {}, {
              method: t,
              headers: a ? {
                "Content-Type": "multipart/form-data"
              } : {},
              url: _,
              data: c
            }));
          };
        }
        pn.prototype[t] = e(), pn.prototype[t + "Form"] = e(true);
      });
      let XQ = class Md {
        constructor(t) {
          if (typeof t != "function") throw new TypeError("executor must be a function.");
          let e;
          this.promise = new Promise(function(_) {
            e = _;
          });
          const a = this;
          this.promise.then((n) => {
            if (!a._listeners) return;
            let _ = a._listeners.length;
            for (; _-- > 0; ) a._listeners[_](n);
            a._listeners = null;
          }), this.promise.then = (n) => {
            let _;
            const c = new Promise((s) => {
              a.subscribe(s), _ = s;
            }).then(n);
            return c.cancel = function() {
              a.unsubscribe(_);
            }, c;
          }, t(function(_, c, s) {
            a.reason || (a.reason = new En(_, c, s), e(a.reason));
          });
        }
        throwIfRequested() {
          if (this.reason) throw this.reason;
        }
        subscribe(t) {
          if (this.reason) {
            t(this.reason);
            return;
          }
          this._listeners ? this._listeners.push(t) : this._listeners = [
            t
          ];
        }
        unsubscribe(t) {
          if (!this._listeners) return;
          const e = this._listeners.indexOf(t);
          e !== -1 && this._listeners.splice(e, 1);
        }
        toAbortSignal() {
          const t = new AbortController(), e = (a) => {
            t.abort(a);
          };
          return this.subscribe(e), t.signal.unsubscribe = () => this.unsubscribe(e), t.signal;
        }
        static source() {
          let t;
          return {
            token: new Md(function(n) {
              t = n;
            }),
            cancel: t
          };
        }
      };
      function JQ(d) {
        return function(e) {
          return d.apply(null, e);
        };
      }
      function ZQ(d) {
        return st.isObject(d) && d.isAxiosError === true;
      }
      const go = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511
      };
      Object.entries(go).forEach(([d, t]) => {
        go[t] = d;
      });
      function Kd(d) {
        const t = new pn(d), e = yd(pn.prototype.request, t);
        return st.extend(e, pn.prototype, t, {
          allOwnKeys: true
        }), st.extend(e, t, null, {
          allOwnKeys: true
        }), e.create = function(n) {
          return Kd(un(d, n));
        }, e;
      }
      const zt = Kd(zn);
      zt.Axios = pn;
      zt.CanceledError = En;
      zt.CancelToken = XQ;
      zt.isCancel = Ld;
      zt.VERSION = Vd;
      zt.toFormData = ca;
      zt.AxiosError = At;
      zt.Cancel = zt.CanceledError;
      zt.all = function(t) {
        return Promise.all(t);
      };
      zt.spread = JQ;
      zt.isAxiosError = ZQ;
      zt.mergeConfig = un;
      zt.AxiosHeaders = Ue;
      zt.formToJSON = (d) => Nd(st.isHTMLForm(d) ? new FormData(d) : d);
      zt.getAdapter = Pd.getAdapter;
      zt.HttpStatusCode = go;
      zt.default = zt;
      const { Axios: U$, AxiosError: z$, CanceledError: D$, isCancel: P$, CancelToken: V$, VERSION: M$, all: K$, Cancel: q$, isAxiosError: H$, spread: G$, toFormData: W$, AxiosHeaders: Q$, HttpStatusCode: $$, formToJSON: Y$, getAdapter: X$, mergeConfig: J$ } = zt;
      function qd(d) {
        return d && d.__esModule && Object.prototype.hasOwnProperty.call(d, "default") ? d.default : d;
      }
      function t$(d) {
        if (Object.prototype.hasOwnProperty.call(d, "__esModule")) return d;
        var t = d.default;
        if (typeof t == "function") {
          var e = function a() {
            var n = false;
            try {
              n = this instanceof a;
            } catch {
            }
            return n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
          };
          e.prototype = t.prototype;
        } else e = {};
        return Object.defineProperty(e, "__esModule", {
          value: true
        }), Object.keys(d).forEach(function(a) {
          var n = Object.getOwnPropertyDescriptor(d, a);
          Object.defineProperty(e, a, n.get ? n : {
            enumerable: true,
            get: function() {
              return d[a];
            }
          });
        }), e;
      }
      var jn = {
        exports: {}
      }, ya = {
        exports: {}
      }, ea = {
        exports: {}
      }, e$ = ea.exports, xc;
      function Hd() {
        return xc || (xc = 1, (function(d) {
          (function(t) {
            var e, a = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, n = Math.ceil, _ = Math.floor, c = "[BigNumber Error] ", s = c + "Number primitive has more than 15 significant digits: ", p = 1e14, l = 14, y = 9007199254740991, R = [
              1,
              10,
              100,
              1e3,
              1e4,
              1e5,
              1e6,
              1e7,
              1e8,
              1e9,
              1e10,
              1e11,
              1e12,
              1e13
            ], j = 1e7, b = 1e9;
            function C(v) {
              var g, u, F, z = rt.prototype = {
                constructor: rt,
                toString: null,
                valueOf: null
              }, W = new rt(1), M = 20, Y = 4, tt = -7, Z = 21, ot = -1e7, ct = 1e7, pt = false, wt = 1, yt = 0, St = {
                prefix: "",
                groupSize: 3,
                secondaryGroupSize: 0,
                groupSeparator: ",",
                decimalSeparator: ".",
                fractionGroupSize: 0,
                fractionGroupSeparator: "\xA0",
                suffix: ""
              }, Bt = "0123456789abcdefghijklmnopqrstuvwxyz", Kt = true;
              function rt(m, E) {
                var f, I, D, L, $, Q, X, G, J = this;
                if (!(J instanceof rt)) return new rt(m, E);
                if (E == null) {
                  if (m && m._isBigNumber === true) {
                    J.s = m.s, !m.c || m.e > ct ? J.c = J.e = null : m.e < ot ? J.c = [
                      J.e = 0
                    ] : (J.e = m.e, J.c = m.c.slice());
                    return;
                  }
                  if ((Q = typeof m == "number") && m * 0 == 0) {
                    if (J.s = 1 / m < 0 ? (m = -m, -1) : 1, m === ~~m) {
                      for (L = 0, $ = m; $ >= 10; $ /= 10, L++) ;
                      L > ct ? J.c = J.e = null : (J.e = L, J.c = [
                        m
                      ]);
                      return;
                    }
                    G = String(m);
                  } else {
                    if (!a.test(G = String(m))) return F(J, G, Q);
                    J.s = G.charCodeAt(0) == 45 ? (G = G.slice(1), -1) : 1;
                  }
                  (L = G.indexOf(".")) > -1 && (G = G.replace(".", "")), ($ = G.search(/e/i)) > 0 ? (L < 0 && (L = $), L += +G.slice($ + 1), G = G.substring(0, $)) : L < 0 && (L = G.length);
                } else {
                  if (k(E, 2, Bt.length, "Base"), E == 10 && Kt) return J = new rt(m), Ct(J, M + J.e + 1, Y);
                  if (G = String(m), Q = typeof m == "number") {
                    if (m * 0 != 0) return F(J, G, Q, E);
                    if (J.s = 1 / m < 0 ? (G = G.slice(1), -1) : 1, rt.DEBUG && G.replace(/^0\.0*|\./, "").length > 15) throw Error(s + m);
                  } else J.s = G.charCodeAt(0) === 45 ? (G = G.slice(1), -1) : 1;
                  for (f = Bt.slice(0, E), L = $ = 0, X = G.length; $ < X; $++) if (f.indexOf(I = G.charAt($)) < 0) {
                    if (I == ".") {
                      if ($ > L) {
                        L = X;
                        continue;
                      }
                    } else if (!D && (G == G.toUpperCase() && (G = G.toLowerCase()) || G == G.toLowerCase() && (G = G.toUpperCase()))) {
                      D = true, $ = -1, L = 0;
                      continue;
                    }
                    return F(J, String(m), Q, E);
                  }
                  Q = false, G = u(G, E, 10, J.s), (L = G.indexOf(".")) > -1 ? G = G.replace(".", "") : L = G.length;
                }
                for ($ = 0; G.charCodeAt($) === 48; $++) ;
                for (X = G.length; G.charCodeAt(--X) === 48; ) ;
                if (G = G.slice($, ++X)) {
                  if (X -= $, Q && rt.DEBUG && X > 15 && (m > y || m !== _(m))) throw Error(s + J.s * m);
                  if ((L = L - $ - 1) > ct) J.c = J.e = null;
                  else if (L < ot) J.c = [
                    J.e = 0
                  ];
                  else {
                    if (J.e = L, J.c = [], $ = (L + 1) % l, L < 0 && ($ += l), $ < X) {
                      for ($ && J.c.push(+G.slice(0, $)), X -= l; $ < X; ) J.c.push(+G.slice($, $ += l));
                      $ = l - (G = G.slice($)).length;
                    } else $ -= X;
                    for (; $--; G += "0") ;
                    J.c.push(+G);
                  }
                } else J.c = [
                  J.e = 0
                ];
              }
              rt.clone = C, rt.ROUND_UP = 0, rt.ROUND_DOWN = 1, rt.ROUND_CEIL = 2, rt.ROUND_FLOOR = 3, rt.ROUND_HALF_UP = 4, rt.ROUND_HALF_DOWN = 5, rt.ROUND_HALF_EVEN = 6, rt.ROUND_HALF_CEIL = 7, rt.ROUND_HALF_FLOOR = 8, rt.EUCLID = 9, rt.config = rt.set = function(m) {
                var E, f;
                if (m != null) if (typeof m == "object") {
                  if (m.hasOwnProperty(E = "DECIMAL_PLACES") && (f = m[E], k(f, 0, b, E), M = f), m.hasOwnProperty(E = "ROUNDING_MODE") && (f = m[E], k(f, 0, 8, E), Y = f), m.hasOwnProperty(E = "EXPONENTIAL_AT") && (f = m[E], f && f.pop ? (k(f[0], -b, 0, E), k(f[1], 0, b, E), tt = f[0], Z = f[1]) : (k(f, -b, b, E), tt = -(Z = f < 0 ? -f : f))), m.hasOwnProperty(E = "RANGE")) if (f = m[E], f && f.pop) k(f[0], -b, -1, E), k(f[1], 1, b, E), ot = f[0], ct = f[1];
                  else if (k(f, -b, b, E), f) ot = -(ct = f < 0 ? -f : f);
                  else throw Error(c + E + " cannot be zero: " + f);
                  if (m.hasOwnProperty(E = "CRYPTO")) if (f = m[E], f === !!f) if (f) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) pt = f;
                  else throw pt = !f, Error(c + "crypto unavailable");
                  else pt = f;
                  else throw Error(c + E + " not true or false: " + f);
                  if (m.hasOwnProperty(E = "MODULO_MODE") && (f = m[E], k(f, 0, 9, E), wt = f), m.hasOwnProperty(E = "POW_PRECISION") && (f = m[E], k(f, 0, b, E), yt = f), m.hasOwnProperty(E = "FORMAT")) if (f = m[E], typeof f == "object") St = f;
                  else throw Error(c + E + " not an object: " + f);
                  if (m.hasOwnProperty(E = "ALPHABET")) if (f = m[E], typeof f == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(f)) Kt = f.slice(0, 10) == "0123456789", Bt = f;
                  else throw Error(c + E + " invalid: " + f);
                } else throw Error(c + "Object expected: " + m);
                return {
                  DECIMAL_PLACES: M,
                  ROUNDING_MODE: Y,
                  EXPONENTIAL_AT: [
                    tt,
                    Z
                  ],
                  RANGE: [
                    ot,
                    ct
                  ],
                  CRYPTO: pt,
                  MODULO_MODE: wt,
                  POW_PRECISION: yt,
                  FORMAT: St,
                  ALPHABET: Bt
                };
              }, rt.isBigNumber = function(m) {
                if (!m || m._isBigNumber !== true) return false;
                if (!rt.DEBUG) return true;
                var E, f, I = m.c, D = m.e, L = m.s;
                t: if ({}.toString.call(I) == "[object Array]") {
                  if ((L === 1 || L === -1) && D >= -b && D <= b && D === _(D)) {
                    if (I[0] === 0) {
                      if (D === 0 && I.length === 1) return true;
                      break t;
                    }
                    if (E = (D + 1) % l, E < 1 && (E += l), String(I[0]).length == E) {
                      for (E = 0; E < I.length; E++) if (f = I[E], f < 0 || f >= p || f !== _(f)) break t;
                      if (f !== 0) return true;
                    }
                  }
                } else if (I === null && D === null && (L === null || L === 1 || L === -1)) return true;
                throw Error(c + "Invalid BigNumber: " + m);
              }, rt.maximum = rt.max = function() {
                return gt(arguments, -1);
              }, rt.minimum = rt.min = function() {
                return gt(arguments, 1);
              }, rt.random = (function() {
                var m = 9007199254740992, E = Math.random() * m & 2097151 ? function() {
                  return _(Math.random() * m);
                } : function() {
                  return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
                };
                return function(f) {
                  var I, D, L, $, Q, X = 0, G = [], J = new rt(W);
                  if (f == null ? f = M : k(f, 0, b), $ = n(f / l), pt) if (crypto.getRandomValues) {
                    for (I = crypto.getRandomValues(new Uint32Array($ *= 2)); X < $; ) Q = I[X] * 131072 + (I[X + 1] >>> 11), Q >= 9e15 ? (D = crypto.getRandomValues(new Uint32Array(2)), I[X] = D[0], I[X + 1] = D[1]) : (G.push(Q % 1e14), X += 2);
                    X = $ / 2;
                  } else if (crypto.randomBytes) {
                    for (I = crypto.randomBytes($ *= 7); X < $; ) Q = (I[X] & 31) * 281474976710656 + I[X + 1] * 1099511627776 + I[X + 2] * 4294967296 + I[X + 3] * 16777216 + (I[X + 4] << 16) + (I[X + 5] << 8) + I[X + 6], Q >= 9e15 ? crypto.randomBytes(7).copy(I, X) : (G.push(Q % 1e14), X += 7);
                    X = $ / 7;
                  } else throw pt = false, Error(c + "crypto unavailable");
                  if (!pt) for (; X < $; ) Q = E(), Q < 9e15 && (G[X++] = Q % 1e14);
                  for ($ = G[--X], f %= l, $ && f && (Q = R[l - f], G[X] = _($ / Q) * Q); G[X] === 0; G.pop(), X--) ;
                  if (X < 0) G = [
                    L = 0
                  ];
                  else {
                    for (L = -1; G[0] === 0; G.splice(0, 1), L -= l) ;
                    for (X = 1, Q = G[0]; Q >= 10; Q /= 10, X++) ;
                    X < l && (L -= l - X);
                  }
                  return J.e = L, J.c = G, J;
                };
              })(), rt.sum = function() {
                for (var m = 1, E = arguments, f = new rt(E[0]); m < E.length; ) f = f.plus(E[m++]);
                return f;
              }, u = /* @__PURE__ */ (function() {
                var m = "0123456789";
                function E(f, I, D, L) {
                  for (var $, Q = [
                    0
                  ], X, G = 0, J = f.length; G < J; ) {
                    for (X = Q.length; X--; Q[X] *= I) ;
                    for (Q[0] += L.indexOf(f.charAt(G++)), $ = 0; $ < Q.length; $++) Q[$] > D - 1 && (Q[$ + 1] == null && (Q[$ + 1] = 0), Q[$ + 1] += Q[$] / D | 0, Q[$] %= D);
                  }
                  return Q.reverse();
                }
                return function(f, I, D, L, $) {
                  var Q, X, G, J, at, ft, ut, kt, jt = f.indexOf("."), Rt = M, mt = Y;
                  for (jt >= 0 && (J = yt, yt = 0, f = f.replace(".", ""), kt = new rt(I), ft = kt.pow(f.length - jt), yt = J, kt.c = E(P(T(ft.c), ft.e, "0"), 10, D, m), kt.e = kt.c.length), ut = E(f, I, D, $ ? (Q = Bt, m) : (Q = m, Bt)), G = J = ut.length; ut[--J] == 0; ut.pop()) ;
                  if (!ut[0]) return Q.charAt(0);
                  if (jt < 0 ? --G : (ft.c = ut, ft.e = G, ft.s = L, ft = g(ft, kt, Rt, mt, D), ut = ft.c, at = ft.r, G = ft.e), X = G + Rt + 1, jt = ut[X], J = D / 2, at = at || X < 0 || ut[X + 1] != null, at = mt < 4 ? (jt != null || at) && (mt == 0 || mt == (ft.s < 0 ? 3 : 2)) : jt > J || jt == J && (mt == 4 || at || mt == 6 && ut[X - 1] & 1 || mt == (ft.s < 0 ? 8 : 7)), X < 1 || !ut[0]) f = at ? P(Q.charAt(1), -Rt, Q.charAt(0)) : Q.charAt(0);
                  else {
                    if (ut.length = X, at) for (--D; ++ut[--X] > D; ) ut[X] = 0, X || (++G, ut = [
                      1
                    ].concat(ut));
                    for (J = ut.length; !ut[--J]; ) ;
                    for (jt = 0, f = ""; jt <= J; f += Q.charAt(ut[jt++])) ;
                    f = P(f, G, Q.charAt(0));
                  }
                  return f;
                };
              })(), g = /* @__PURE__ */ (function() {
                function m(I, D, L) {
                  var $, Q, X, G, J = 0, at = I.length, ft = D % j, ut = D / j | 0;
                  for (I = I.slice(); at--; ) X = I[at] % j, G = I[at] / j | 0, $ = ut * X + G * ft, Q = ft * X + $ % j * j + J, J = (Q / L | 0) + ($ / j | 0) + ut * G, I[at] = Q % L;
                  return J && (I = [
                    J
                  ].concat(I)), I;
                }
                function E(I, D, L, $) {
                  var Q, X;
                  if (L != $) X = L > $ ? 1 : -1;
                  else for (Q = X = 0; Q < L; Q++) if (I[Q] != D[Q]) {
                    X = I[Q] > D[Q] ? 1 : -1;
                    break;
                  }
                  return X;
                }
                function f(I, D, L, $) {
                  for (var Q = 0; L--; ) I[L] -= Q, Q = I[L] < D[L] ? 1 : 0, I[L] = Q * $ + I[L] - D[L];
                  for (; !I[0] && I.length > 1; I.splice(0, 1)) ;
                }
                return function(I, D, L, $, Q) {
                  var X, G, J, at, ft, ut, kt, jt, Rt, mt, Et, Nt, Qt, Zt, te, qt, ee, Ht = I.s == D.s ? 1 : -1, Pt = I.c, Ft = D.c;
                  if (!Pt || !Pt[0] || !Ft || !Ft[0]) return new rt(!I.s || !D.s || (Pt ? Ft && Pt[0] == Ft[0] : !Ft) ? NaN : Pt && Pt[0] == 0 || !Ft ? Ht * 0 : Ht / 0);
                  for (jt = new rt(Ht), Rt = jt.c = [], G = I.e - D.e, Ht = L + G + 1, Q || (Q = p, G = A(I.e / l) - A(D.e / l), Ht = Ht / l | 0), J = 0; Ft[J] == (Pt[J] || 0); J++) ;
                  if (Ft[J] > (Pt[J] || 0) && G--, Ht < 0) Rt.push(1), at = true;
                  else {
                    for (Zt = Pt.length, qt = Ft.length, J = 0, Ht += 2, ft = _(Q / (Ft[0] + 1)), ft > 1 && (Ft = m(Ft, ft, Q), Pt = m(Pt, ft, Q), qt = Ft.length, Zt = Pt.length), Qt = qt, mt = Pt.slice(0, qt), Et = mt.length; Et < qt; mt[Et++] = 0) ;
                    ee = Ft.slice(), ee = [
                      0
                    ].concat(ee), te = Ft[0], Ft[1] >= Q / 2 && te++;
                    do {
                      if (ft = 0, X = E(Ft, mt, qt, Et), X < 0) {
                        if (Nt = mt[0], qt != Et && (Nt = Nt * Q + (mt[1] || 0)), ft = _(Nt / te), ft > 1) for (ft >= Q && (ft = Q - 1), ut = m(Ft, ft, Q), kt = ut.length, Et = mt.length; E(ut, mt, kt, Et) == 1; ) ft--, f(ut, qt < kt ? ee : Ft, kt, Q), kt = ut.length, X = 1;
                        else ft == 0 && (X = ft = 1), ut = Ft.slice(), kt = ut.length;
                        if (kt < Et && (ut = [
                          0
                        ].concat(ut)), f(mt, ut, Et, Q), Et = mt.length, X == -1) for (; E(Ft, mt, qt, Et) < 1; ) ft++, f(mt, qt < Et ? ee : Ft, Et, Q), Et = mt.length;
                      } else X === 0 && (ft++, mt = [
                        0
                      ]);
                      Rt[J++] = ft, mt[0] ? mt[Et++] = Pt[Qt] || 0 : (mt = [
                        Pt[Qt]
                      ], Et = 1);
                    } while ((Qt++ < Zt || mt[0] != null) && Ht--);
                    at = mt[0] != null, Rt[0] || Rt.splice(0, 1);
                  }
                  if (Q == p) {
                    for (J = 1, Ht = Rt[0]; Ht >= 10; Ht /= 10, J++) ;
                    Ct(jt, L + (jt.e = J + G * l - 1) + 1, $, at);
                  } else jt.e = G, jt.r = +at;
                  return jt;
                };
              })();
              function Tt(m, E, f, I) {
                var D, L, $, Q, X;
                if (f == null ? f = Y : k(f, 0, 8), !m.c) return m.toString();
                if (D = m.c[0], $ = m.e, E == null) X = T(m.c), X = I == 1 || I == 2 && ($ <= tt || $ >= Z) ? N(X, $) : P(X, $, "0");
                else if (m = Ct(new rt(m), E, f), L = m.e, X = T(m.c), Q = X.length, I == 1 || I == 2 && (E <= L || L <= tt)) {
                  for (; Q < E; X += "0", Q++) ;
                  X = N(X, L);
                } else if (E -= $ + (I === 2 && L > $), X = P(X, L, "0"), L + 1 > Q) {
                  if (--E > 0) for (X += "."; E--; X += "0") ;
                } else if (E += L - Q, E > 0) for (L + 1 == Q && (X += "."); E--; X += "0") ;
                return m.s < 0 && D ? "-" + X : X;
              }
              function gt(m, E) {
                for (var f, I, D = 1, L = new rt(m[0]); D < m.length; D++) I = new rt(m[D]), (!I.s || (f = h(L, I)) === E || f === 0 && L.s === E) && (L = I);
                return L;
              }
              function ae(m, E, f) {
                for (var I = 1, D = E.length; !E[--D]; E.pop()) ;
                for (D = E[0]; D >= 10; D /= 10, I++) ;
                return (f = I + f * l - 1) > ct ? m.c = m.e = null : f < ot ? m.c = [
                  m.e = 0
                ] : (m.e = f, m.c = E), m;
              }
              F = /* @__PURE__ */ (function() {
                var m = /^(-?)0([xbo])(?=\w[\w.]*$)/i, E = /^([^.]+)\.$/, f = /^\.([^.]+)$/, I = /^-?(Infinity|NaN)$/, D = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
                return function(L, $, Q, X) {
                  var G, J = Q ? $ : $.replace(D, "");
                  if (I.test(J)) L.s = isNaN(J) ? null : J < 0 ? -1 : 1;
                  else {
                    if (!Q && (J = J.replace(m, function(at, ft, ut) {
                      return G = (ut = ut.toLowerCase()) == "x" ? 16 : ut == "b" ? 2 : 8, !X || X == G ? ft : at;
                    }), X && (G = X, J = J.replace(E, "$1").replace(f, "0.$1")), $ != J)) return new rt(J, G);
                    if (rt.DEBUG) throw Error(c + "Not a" + (X ? " base " + X : "") + " number: " + $);
                    L.s = null;
                  }
                  L.c = L.e = null;
                };
              })();
              function Ct(m, E, f, I) {
                var D, L, $, Q, X, G, J, at = m.c, ft = R;
                if (at) {
                  t: {
                    for (D = 1, Q = at[0]; Q >= 10; Q /= 10, D++) ;
                    if (L = E - D, L < 0) L += l, $ = E, X = at[G = 0], J = _(X / ft[D - $ - 1] % 10);
                    else if (G = n((L + 1) / l), G >= at.length) if (I) {
                      for (; at.length <= G; at.push(0)) ;
                      X = J = 0, D = 1, L %= l, $ = L - l + 1;
                    } else break t;
                    else {
                      for (X = Q = at[G], D = 1; Q >= 10; Q /= 10, D++) ;
                      L %= l, $ = L - l + D, J = $ < 0 ? 0 : _(X / ft[D - $ - 1] % 10);
                    }
                    if (I = I || E < 0 || at[G + 1] != null || ($ < 0 ? X : X % ft[D - $ - 1]), I = f < 4 ? (J || I) && (f == 0 || f == (m.s < 0 ? 3 : 2)) : J > 5 || J == 5 && (f == 4 || I || f == 6 && (L > 0 ? $ > 0 ? X / ft[D - $] : 0 : at[G - 1]) % 10 & 1 || f == (m.s < 0 ? 8 : 7)), E < 1 || !at[0]) return at.length = 0, I ? (E -= m.e + 1, at[0] = ft[(l - E % l) % l], m.e = -E || 0) : at[0] = m.e = 0, m;
                    if (L == 0 ? (at.length = G, Q = 1, G--) : (at.length = G + 1, Q = ft[l - L], at[G] = $ > 0 ? _(X / ft[D - $] % ft[$]) * Q : 0), I) for (; ; ) if (G == 0) {
                      for (L = 1, $ = at[0]; $ >= 10; $ /= 10, L++) ;
                      for ($ = at[0] += Q, Q = 1; $ >= 10; $ /= 10, Q++) ;
                      L != Q && (m.e++, at[0] == p && (at[0] = 1));
                      break;
                    } else {
                      if (at[G] += Q, at[G] != p) break;
                      at[G--] = 0, Q = 1;
                    }
                    for (L = at.length; at[--L] === 0; at.pop()) ;
                  }
                  m.e > ct ? m.c = m.e = null : m.e < ot && (m.c = [
                    m.e = 0
                  ]);
                }
                return m;
              }
              function x(m) {
                var E, f = m.e;
                return f === null ? m.toString() : (E = T(m.c), E = f <= tt || f >= Z ? N(E, f) : P(E, f, "0"), m.s < 0 ? "-" + E : E);
              }
              return z.absoluteValue = z.abs = function() {
                var m = new rt(this);
                return m.s < 0 && (m.s = 1), m;
              }, z.comparedTo = function(m, E) {
                return h(this, new rt(m, E));
              }, z.decimalPlaces = z.dp = function(m, E) {
                var f, I, D, L = this;
                if (m != null) return k(m, 0, b), E == null ? E = Y : k(E, 0, 8), Ct(new rt(L), m + L.e + 1, E);
                if (!(f = L.c)) return null;
                if (I = ((D = f.length - 1) - A(this.e / l)) * l, D = f[D]) for (; D % 10 == 0; D /= 10, I--) ;
                return I < 0 && (I = 0), I;
              }, z.dividedBy = z.div = function(m, E) {
                return g(this, new rt(m, E), M, Y);
              }, z.dividedToIntegerBy = z.idiv = function(m, E) {
                return g(this, new rt(m, E), 0, 1);
              }, z.exponentiatedBy = z.pow = function(m, E) {
                var f, I, D, L, $, Q, X, G, J, at = this;
                if (m = new rt(m), m.c && !m.isInteger()) throw Error(c + "Exponent not an integer: " + x(m));
                if (E != null && (E = new rt(E)), Q = m.e > 14, !at.c || !at.c[0] || at.c[0] == 1 && !at.e && at.c.length == 1 || !m.c || !m.c[0]) return J = new rt(Math.pow(+x(at), Q ? m.s * (2 - S(m)) : +x(m))), E ? J.mod(E) : J;
                if (X = m.s < 0, E) {
                  if (E.c ? !E.c[0] : !E.s) return new rt(NaN);
                  I = !X && at.isInteger() && E.isInteger(), I && (at = at.mod(E));
                } else {
                  if (m.e > 9 && (at.e > 0 || at.e < -1 || (at.e == 0 ? at.c[0] > 1 || Q && at.c[1] >= 24e7 : at.c[0] < 8e13 || Q && at.c[0] <= 9999975e7))) return L = at.s < 0 && S(m) ? -0 : 0, at.e > -1 && (L = 1 / L), new rt(X ? 1 / L : L);
                  yt && (L = n(yt / l + 2));
                }
                for (Q ? (f = new rt(0.5), X && (m.s = 1), G = S(m)) : (D = Math.abs(+x(m)), G = D % 2), J = new rt(W); ; ) {
                  if (G) {
                    if (J = J.times(at), !J.c) break;
                    L ? J.c.length > L && (J.c.length = L) : I && (J = J.mod(E));
                  }
                  if (D) {
                    if (D = _(D / 2), D === 0) break;
                    G = D % 2;
                  } else if (m = m.times(f), Ct(m, m.e + 1, 1), m.e > 14) G = S(m);
                  else {
                    if (D = +x(m), D === 0) break;
                    G = D % 2;
                  }
                  at = at.times(at), L ? at.c && at.c.length > L && (at.c.length = L) : I && (at = at.mod(E));
                }
                return I ? J : (X && (J = W.div(J)), E ? J.mod(E) : L ? Ct(J, yt, Y, $) : J);
              }, z.integerValue = function(m) {
                var E = new rt(this);
                return m == null ? m = Y : k(m, 0, 8), Ct(E, E.e + 1, m);
              }, z.isEqualTo = z.eq = function(m, E) {
                return h(this, new rt(m, E)) === 0;
              }, z.isFinite = function() {
                return !!this.c;
              }, z.isGreaterThan = z.gt = function(m, E) {
                return h(this, new rt(m, E)) > 0;
              }, z.isGreaterThanOrEqualTo = z.gte = function(m, E) {
                return (E = h(this, new rt(m, E))) === 1 || E === 0;
              }, z.isInteger = function() {
                return !!this.c && A(this.e / l) > this.c.length - 2;
              }, z.isLessThan = z.lt = function(m, E) {
                return h(this, new rt(m, E)) < 0;
              }, z.isLessThanOrEqualTo = z.lte = function(m, E) {
                return (E = h(this, new rt(m, E))) === -1 || E === 0;
              }, z.isNaN = function() {
                return !this.s;
              }, z.isNegative = function() {
                return this.s < 0;
              }, z.isPositive = function() {
                return this.s > 0;
              }, z.isZero = function() {
                return !!this.c && this.c[0] == 0;
              }, z.minus = function(m, E) {
                var f, I, D, L, $ = this, Q = $.s;
                if (m = new rt(m, E), E = m.s, !Q || !E) return new rt(NaN);
                if (Q != E) return m.s = -E, $.plus(m);
                var X = $.e / l, G = m.e / l, J = $.c, at = m.c;
                if (!X || !G) {
                  if (!J || !at) return J ? (m.s = -E, m) : new rt(at ? $ : NaN);
                  if (!J[0] || !at[0]) return at[0] ? (m.s = -E, m) : new rt(J[0] ? $ : Y == 3 ? -0 : 0);
                }
                if (X = A(X), G = A(G), J = J.slice(), Q = X - G) {
                  for ((L = Q < 0) ? (Q = -Q, D = J) : (G = X, D = at), D.reverse(), E = Q; E--; D.push(0)) ;
                  D.reverse();
                } else for (I = (L = (Q = J.length) < (E = at.length)) ? Q : E, Q = E = 0; E < I; E++) if (J[E] != at[E]) {
                  L = J[E] < at[E];
                  break;
                }
                if (L && (D = J, J = at, at = D, m.s = -m.s), E = (I = at.length) - (f = J.length), E > 0) for (; E--; J[f++] = 0) ;
                for (E = p - 1; I > Q; ) {
                  if (J[--I] < at[I]) {
                    for (f = I; f && !J[--f]; J[f] = E) ;
                    --J[f], J[I] += p;
                  }
                  J[I] -= at[I];
                }
                for (; J[0] == 0; J.splice(0, 1), --G) ;
                return J[0] ? ae(m, J, G) : (m.s = Y == 3 ? -1 : 1, m.c = [
                  m.e = 0
                ], m);
              }, z.modulo = z.mod = function(m, E) {
                var f, I, D = this;
                return m = new rt(m, E), !D.c || !m.s || m.c && !m.c[0] ? new rt(NaN) : !m.c || D.c && !D.c[0] ? new rt(D) : (wt == 9 ? (I = m.s, m.s = 1, f = g(D, m, 0, 3), m.s = I, f.s *= I) : f = g(D, m, 0, wt), m = D.minus(f.times(m)), !m.c[0] && wt == 1 && (m.s = D.s), m);
              }, z.multipliedBy = z.times = function(m, E) {
                var f, I, D, L, $, Q, X, G, J, at, ft, ut, kt, jt, Rt, mt = this, Et = mt.c, Nt = (m = new rt(m, E)).c;
                if (!Et || !Nt || !Et[0] || !Nt[0]) return !mt.s || !m.s || Et && !Et[0] && !Nt || Nt && !Nt[0] && !Et ? m.c = m.e = m.s = null : (m.s *= mt.s, !Et || !Nt ? m.c = m.e = null : (m.c = [
                  0
                ], m.e = 0)), m;
                for (I = A(mt.e / l) + A(m.e / l), m.s *= mt.s, X = Et.length, at = Nt.length, X < at && (kt = Et, Et = Nt, Nt = kt, D = X, X = at, at = D), D = X + at, kt = []; D--; kt.push(0)) ;
                for (jt = p, Rt = j, D = at; --D >= 0; ) {
                  for (f = 0, ft = Nt[D] % Rt, ut = Nt[D] / Rt | 0, $ = X, L = D + $; L > D; ) G = Et[--$] % Rt, J = Et[$] / Rt | 0, Q = ut * G + J * ft, G = ft * G + Q % Rt * Rt + kt[L] + f, f = (G / jt | 0) + (Q / Rt | 0) + ut * J, kt[L--] = G % jt;
                  kt[L] = f;
                }
                return f ? ++I : kt.splice(0, 1), ae(m, kt, I);
              }, z.negated = function() {
                var m = new rt(this);
                return m.s = -m.s || null, m;
              }, z.plus = function(m, E) {
                var f, I = this, D = I.s;
                if (m = new rt(m, E), E = m.s, !D || !E) return new rt(NaN);
                if (D != E) return m.s = -E, I.minus(m);
                var L = I.e / l, $ = m.e / l, Q = I.c, X = m.c;
                if (!L || !$) {
                  if (!Q || !X) return new rt(D / 0);
                  if (!Q[0] || !X[0]) return X[0] ? m : new rt(Q[0] ? I : D * 0);
                }
                if (L = A(L), $ = A($), Q = Q.slice(), D = L - $) {
                  for (D > 0 ? ($ = L, f = X) : (D = -D, f = Q), f.reverse(); D--; f.push(0)) ;
                  f.reverse();
                }
                for (D = Q.length, E = X.length, D - E < 0 && (f = X, X = Q, Q = f, E = D), D = 0; E; ) D = (Q[--E] = Q[E] + X[E] + D) / p | 0, Q[E] = p === Q[E] ? 0 : Q[E] % p;
                return D && (Q = [
                  D
                ].concat(Q), ++$), ae(m, Q, $);
              }, z.precision = z.sd = function(m, E) {
                var f, I, D, L = this;
                if (m != null && m !== !!m) return k(m, 1, b), E == null ? E = Y : k(E, 0, 8), Ct(new rt(L), m, E);
                if (!(f = L.c)) return null;
                if (D = f.length - 1, I = D * l + 1, D = f[D]) {
                  for (; D % 10 == 0; D /= 10, I--) ;
                  for (D = f[0]; D >= 10; D /= 10, I++) ;
                }
                return m && L.e + 1 > I && (I = L.e + 1), I;
              }, z.shiftedBy = function(m) {
                return k(m, -y, y), this.times("1e" + m);
              }, z.squareRoot = z.sqrt = function() {
                var m, E, f, I, D, L = this, $ = L.c, Q = L.s, X = L.e, G = M + 4, J = new rt("0.5");
                if (Q !== 1 || !$ || !$[0]) return new rt(!Q || Q < 0 && (!$ || $[0]) ? NaN : $ ? L : 1 / 0);
                if (Q = Math.sqrt(+x(L)), Q == 0 || Q == 1 / 0 ? (E = T($), (E.length + X) % 2 == 0 && (E += "0"), Q = Math.sqrt(+E), X = A((X + 1) / 2) - (X < 0 || X % 2), Q == 1 / 0 ? E = "5e" + X : (E = Q.toExponential(), E = E.slice(0, E.indexOf("e") + 1) + X), f = new rt(E)) : f = new rt(Q + ""), f.c[0]) {
                  for (X = f.e, Q = X + G, Q < 3 && (Q = 0); ; ) if (D = f, f = J.times(D.plus(g(L, D, G, 1))), T(D.c).slice(0, Q) === (E = T(f.c)).slice(0, Q)) if (f.e < X && --Q, E = E.slice(Q - 3, Q + 1), E == "9999" || !I && E == "4999") {
                    if (!I && (Ct(D, D.e + M + 2, 0), D.times(D).eq(L))) {
                      f = D;
                      break;
                    }
                    G += 4, Q += 4, I = 1;
                  } else {
                    (!+E || !+E.slice(1) && E.charAt(0) == "5") && (Ct(f, f.e + M + 2, 1), m = !f.times(f).eq(L));
                    break;
                  }
                }
                return Ct(f, f.e + M + 1, Y, m);
              }, z.toExponential = function(m, E) {
                return m != null && (k(m, 0, b), m++), Tt(this, m, E, 1);
              }, z.toFixed = function(m, E) {
                return m != null && (k(m, 0, b), m = m + this.e + 1), Tt(this, m, E);
              }, z.toFormat = function(m, E, f) {
                var I, D = this;
                if (f == null) m != null && E && typeof E == "object" ? (f = E, E = null) : m && typeof m == "object" ? (f = m, m = E = null) : f = St;
                else if (typeof f != "object") throw Error(c + "Argument not an object: " + f);
                if (I = D.toFixed(m, E), D.c) {
                  var L, $ = I.split("."), Q = +f.groupSize, X = +f.secondaryGroupSize, G = f.groupSeparator || "", J = $[0], at = $[1], ft = D.s < 0, ut = ft ? J.slice(1) : J, kt = ut.length;
                  if (X && (L = Q, Q = X, X = L, kt -= L), Q > 0 && kt > 0) {
                    for (L = kt % Q || Q, J = ut.substr(0, L); L < kt; L += Q) J += G + ut.substr(L, Q);
                    X > 0 && (J += G + ut.slice(L)), ft && (J = "-" + J);
                  }
                  I = at ? J + (f.decimalSeparator || "") + ((X = +f.fractionGroupSize) ? at.replace(new RegExp("\\d{" + X + "}\\B", "g"), "$&" + (f.fractionGroupSeparator || "")) : at) : J;
                }
                return (f.prefix || "") + I + (f.suffix || "");
              }, z.toFraction = function(m) {
                var E, f, I, D, L, $, Q, X, G, J, at, ft, ut = this, kt = ut.c;
                if (m != null && (Q = new rt(m), !Q.isInteger() && (Q.c || Q.s !== 1) || Q.lt(W))) throw Error(c + "Argument " + (Q.isInteger() ? "out of range: " : "not an integer: ") + x(Q));
                if (!kt) return new rt(ut);
                for (E = new rt(W), G = f = new rt(W), I = X = new rt(W), ft = T(kt), L = E.e = ft.length - ut.e - 1, E.c[0] = R[($ = L % l) < 0 ? l + $ : $], m = !m || Q.comparedTo(E) > 0 ? L > 0 ? E : G : Q, $ = ct, ct = 1 / 0, Q = new rt(ft), X.c[0] = 0; J = g(Q, E, 0, 1), D = f.plus(J.times(I)), D.comparedTo(m) != 1; ) f = I, I = D, G = X.plus(J.times(D = G)), X = D, E = Q.minus(J.times(D = E)), Q = D;
                return D = g(m.minus(f), I, 0, 1), X = X.plus(D.times(G)), f = f.plus(D.times(I)), X.s = G.s = ut.s, L = L * 2, at = g(G, I, L, Y).minus(ut).abs().comparedTo(g(X, f, L, Y).minus(ut).abs()) < 1 ? [
                  G,
                  I
                ] : [
                  X,
                  f
                ], ct = $, at;
              }, z.toNumber = function() {
                return +x(this);
              }, z.toPrecision = function(m, E) {
                return m != null && k(m, 1, b), Tt(this, m, E, 2);
              }, z.toString = function(m) {
                var E, f = this, I = f.s, D = f.e;
                return D === null ? I ? (E = "Infinity", I < 0 && (E = "-" + E)) : E = "NaN" : (m == null ? E = D <= tt || D >= Z ? N(T(f.c), D) : P(T(f.c), D, "0") : m === 10 && Kt ? (f = Ct(new rt(f), M + D + 1, Y), E = P(T(f.c), f.e, "0")) : (k(m, 2, Bt.length, "Base"), E = u(P(T(f.c), D, "0"), 10, m, I, true)), I < 0 && f.c[0] && (E = "-" + E)), E;
              }, z.valueOf = z.toJSON = function() {
                return x(this);
              }, z._isBigNumber = true, v != null && rt.set(v), rt;
            }
            function A(v) {
              var g = v | 0;
              return v > 0 || v === g ? g : g - 1;
            }
            function T(v) {
              for (var g, u, F = 1, z = v.length, W = v[0] + ""; F < z; ) {
                for (g = v[F++] + "", u = l - g.length; u--; g = "0" + g) ;
                W += g;
              }
              for (z = W.length; W.charCodeAt(--z) === 48; ) ;
              return W.slice(0, z + 1 || 1);
            }
            function h(v, g) {
              var u, F, z = v.c, W = g.c, M = v.s, Y = g.s, tt = v.e, Z = g.e;
              if (!M || !Y) return null;
              if (u = z && !z[0], F = W && !W[0], u || F) return u ? F ? 0 : -Y : M;
              if (M != Y) return M;
              if (u = M < 0, F = tt == Z, !z || !W) return F ? 0 : !z ^ u ? 1 : -1;
              if (!F) return tt > Z ^ u ? 1 : -1;
              for (Y = (tt = z.length) < (Z = W.length) ? tt : Z, M = 0; M < Y; M++) if (z[M] != W[M]) return z[M] > W[M] ^ u ? 1 : -1;
              return tt == Z ? 0 : tt > Z ^ u ? 1 : -1;
            }
            function k(v, g, u, F) {
              if (v < g || v > u || v !== _(v)) throw Error(c + (F || "Argument") + (typeof v == "number" ? v < g || v > u ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(v));
            }
            function S(v) {
              var g = v.c.length - 1;
              return A(v.e / l) == g && v.c[g] % 2 != 0;
            }
            function N(v, g) {
              return (v.length > 1 ? v.charAt(0) + "." + v.slice(1) : v) + (g < 0 ? "e" : "e+") + g;
            }
            function P(v, g, u) {
              var F, z;
              if (g < 0) {
                for (z = u + "."; ++g; z += u) ;
                v = z + v;
              } else if (F = v.length, ++g > F) {
                for (z = u, g -= F; --g; z += u) ;
                v += z;
              } else g < F && (v = v.slice(0, g) + "." + v.slice(g));
              return v;
            }
            e = C(), e.default = e.BigNumber = e, d.exports ? d.exports = e : (t || (t = typeof self < "u" && self ? self : window), t.BigNumber = e);
          })(e$);
        })(ea)), ea.exports;
      }
      var Ec;
      function r$() {
        return Ec || (Ec = 1, (function(d) {
          var t = Hd(), e = d.exports;
          (function() {
            var a = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, n, _, c = {
              "\b": "\\b",
              "	": "\\t",
              "\n": "\\n",
              "\f": "\\f",
              "\r": "\\r",
              '"': '\\"',
              "\\": "\\\\"
            }, s;
            function p(y) {
              return a.lastIndex = 0, a.test(y) ? '"' + y.replace(a, function(R) {
                var j = c[R];
                return typeof j == "string" ? j : "\\u" + ("0000" + R.charCodeAt(0).toString(16)).slice(-4);
              }) + '"' : '"' + y + '"';
            }
            function l(y, R) {
              var j, b, C, A, T = n, h, k = R[y], S = k != null && (k instanceof t || t.isBigNumber(k));
              switch (k && typeof k == "object" && typeof k.toJSON == "function" && (k = k.toJSON(y)), typeof s == "function" && (k = s.call(R, y, k)), typeof k) {
                case "string":
                  return S ? k : p(k);
                case "number":
                  return isFinite(k) ? String(k) : "null";
                case "boolean":
                case "null":
                case "bigint":
                  return String(k);
                case "object":
                  if (!k) return "null";
                  if (n += _, h = [], Object.prototype.toString.apply(k) === "[object Array]") {
                    for (A = k.length, j = 0; j < A; j += 1) h[j] = l(j, k) || "null";
                    return C = h.length === 0 ? "[]" : n ? `[
` + n + h.join(`,
` + n) + `
` + T + "]" : "[" + h.join(",") + "]", n = T, C;
                  }
                  if (s && typeof s == "object") for (A = s.length, j = 0; j < A; j += 1) typeof s[j] == "string" && (b = s[j], C = l(b, k), C && h.push(p(b) + (n ? ": " : ":") + C));
                  else Object.keys(k).forEach(function(N) {
                    var P = l(N, k);
                    P && h.push(p(N) + (n ? ": " : ":") + P);
                  });
                  return C = h.length === 0 ? "{}" : n ? `{
` + n + h.join(`,
` + n) + `
` + T + "}" : "{" + h.join(",") + "}", n = T, C;
              }
            }
            typeof e.stringify != "function" && (e.stringify = function(y, R, j) {
              var b;
              if (n = "", _ = "", typeof j == "number") for (b = 0; b < j; b += 1) _ += " ";
              else typeof j == "string" && (_ = j);
              if (s = R, R && typeof R != "function" && (typeof R != "object" || typeof R.length != "number")) throw new Error("JSON.stringify");
              return l("", {
                "": y
              });
            });
          })();
        })(ya)), ya.exports;
      }
      var va, Cc;
      function _$() {
        if (Cc) return va;
        Cc = 1;
        var d = null;
        const t = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/, e = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
        var a = function(n) {
          var _ = {
            strict: false,
            storeAsString: false,
            alwaysParseAsBig: false,
            useNativeBigInt: false,
            protoAction: "error",
            constructorAction: "error"
          };
          if (n != null) {
            if (n.strict === true && (_.strict = true), n.storeAsString === true && (_.storeAsString = true), _.alwaysParseAsBig = n.alwaysParseAsBig === true ? n.alwaysParseAsBig : false, _.useNativeBigInt = n.useNativeBigInt === true ? n.useNativeBigInt : false, typeof n.constructorAction < "u") if (n.constructorAction === "error" || n.constructorAction === "ignore" || n.constructorAction === "preserve") _.constructorAction = n.constructorAction;
            else throw new Error(`Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${n.constructorAction}`);
            if (typeof n.protoAction < "u") if (n.protoAction === "error" || n.protoAction === "ignore" || n.protoAction === "preserve") _.protoAction = n.protoAction;
            else throw new Error(`Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${n.protoAction}`);
          }
          var c, s, p = {
            '"': '"',
            "\\": "\\",
            "/": "/",
            b: "\b",
            f: "\f",
            n: `
`,
            r: "\r",
            t: "	"
          }, l, y = function(S) {
            throw {
              name: "SyntaxError",
              message: S,
              at: c,
              text: l
            };
          }, R = function(S) {
            return S && S !== s && y("Expected '" + S + "' instead of '" + s + "'"), s = l.charAt(c), c += 1, s;
          }, j = function() {
            var S, N = "";
            for (s === "-" && (N = "-", R("-")); s >= "0" && s <= "9"; ) N += s, R();
            if (s === ".") for (N += "."; R() && s >= "0" && s <= "9"; ) N += s;
            if (s === "e" || s === "E") for (N += s, R(), (s === "-" || s === "+") && (N += s, R()); s >= "0" && s <= "9"; ) N += s, R();
            if (S = +N, !isFinite(S)) y("Bad number");
            else return d == null && (d = Hd()), N.length > 15 ? _.storeAsString ? N : _.useNativeBigInt ? BigInt(N) : new d(N) : _.alwaysParseAsBig ? _.useNativeBigInt ? BigInt(S) : new d(S) : S;
          }, b = function() {
            var S, N, P = "", v;
            if (s === '"') for (var g = c; R(); ) {
              if (s === '"') return c - 1 > g && (P += l.substring(g, c - 1)), R(), P;
              if (s === "\\") {
                if (c - 1 > g && (P += l.substring(g, c - 1)), R(), s === "u") {
                  for (v = 0, N = 0; N < 4 && (S = parseInt(R(), 16), !!isFinite(S)); N += 1) v = v * 16 + S;
                  P += String.fromCharCode(v);
                } else if (typeof p[s] == "string") P += p[s];
                else break;
                g = c;
              }
            }
            y("Bad string");
          }, C = function() {
            for (; s && s <= " "; ) R();
          }, A = function() {
            switch (s) {
              case "t":
                return R("t"), R("r"), R("u"), R("e"), true;
              case "f":
                return R("f"), R("a"), R("l"), R("s"), R("e"), false;
              case "n":
                return R("n"), R("u"), R("l"), R("l"), null;
            }
            y("Unexpected '" + s + "'");
          }, T, h = function() {
            var S = [];
            if (s === "[") {
              if (R("["), C(), s === "]") return R("]"), S;
              for (; s; ) {
                if (S.push(T()), C(), s === "]") return R("]"), S;
                R(","), C();
              }
            }
            y("Bad array");
          }, k = function() {
            var S, N = /* @__PURE__ */ Object.create(null);
            if (s === "{") {
              if (R("{"), C(), s === "}") return R("}"), N;
              for (; s; ) {
                if (S = b(), C(), R(":"), _.strict === true && Object.hasOwnProperty.call(N, S) && y('Duplicate key "' + S + '"'), t.test(S) === true ? _.protoAction === "error" ? y("Object contains forbidden prototype property") : _.protoAction === "ignore" ? T() : N[S] = T() : e.test(S) === true ? _.constructorAction === "error" ? y("Object contains forbidden constructor property") : _.constructorAction === "ignore" ? T() : N[S] = T() : N[S] = T(), C(), s === "}") return R("}"), N;
                R(","), C();
              }
            }
            y("Bad object");
          };
          return T = function() {
            switch (C(), s) {
              case "{":
                return k();
              case "[":
                return h();
              case '"':
                return b();
              case "-":
                return j();
              default:
                return s >= "0" && s <= "9" ? j() : A();
            }
          }, function(S, N) {
            var P;
            return l = S + "", c = 0, s = " ", P = T(), C(), s && y("Syntax error"), typeof N == "function" ? (function v(g, u) {
              var F, z = g[u];
              return z && typeof z == "object" && Object.keys(z).forEach(function(W) {
                F = v(z, W), F !== void 0 ? z[W] = F : delete z[W];
              }), N.call(g, u, z);
            })({
              "": P
            }, "") : P;
          };
        };
        return va = a, va;
      }
      var Sc;
      function n$() {
        if (Sc) return jn.exports;
        Sc = 1;
        var d = r$().stringify, t = _$();
        return jn.exports = function(e) {
          return {
            parse: t(e),
            stringify: d
          };
        }, jn.exports.parse = t(), jn.exports.stringify = d, jn.exports;
      }
      var a$ = n$();
      const yo = qd(a$);
      class $t {
        constructor(t) {
          typeof t == "string" ? this.int = BigInt(t) : typeof t == "number" ? this.int = BigInt(t) : typeof t == "bigint" ? this.int = BigInt(t) : this.int = BigInt(t.toString());
        }
        add(t) {
          return new $t(this.int + t.int);
        }
        increase(t) {
          this.int += t.int;
        }
        toString() {
          return this.int.toString();
        }
        toNumber() {
          return Number(this.int);
        }
        toBigInt() {
          return this.int;
        }
        toBigNum() {
          return it.from_str(this.int.toString());
        }
        toJSON() {
          return this.int;
        }
      }
      const Gd = yo({
        storeAsString: false,
        useNativeBigInt: true
      });
      function Xe(d) {
        return Gd.stringify(d);
      }
      function Tc(d) {
        return Gd.parse(d);
      }
      function o$(d) {
        console.log(d);
        let t;
        if (typeof d == "string") t = yo({
          useNativeBigInt: true
        }).parse(d);
        else if (typeof d == "object") t = d;
        else return null;
        return {
          a_xi_int: new $t(t.a_xi_int),
          b_xi_int: new $t(t.b_xi_int),
          c_xi_int: new $t(t.c_xi_int),
          cmA_bytes: t.cmA_bytes,
          cmB_bytes: t.cmB_bytes,
          cmC_bytes: t.cmC_bytes,
          cmF_bytes: t.cmF_bytes,
          cmH1_bytes: t.cmH1_bytes,
          cmH2_bytes: t.cmH2_bytes,
          cmQhigh_bytes: t.cmQhigh_bytes,
          cmQlow_bytes: t.cmQlow_bytes,
          cmQmid_bytes: t.cmQmid_bytes,
          cmZ1_bytes: t.cmZ1_bytes,
          cmZ2_bytes: t.cmZ2_bytes,
          f_xi_int: new $t(t.f_xi_int),
          "h1_xi'_int": new $t(t["h1_xi'_int"]),
          h2_xi_int: new $t(t.h2_xi_int),
          l1_xi: new $t(t.l1_xi),
          l_xi: new $t(t.l_xi),
          proof1_bytes: t.proof1_bytes,
          proof2_bytes: t.proof2_bytes,
          s1_xi_int: new $t(t.s1_xi_int),
          s2_xi_int: new $t(t.s2_xi_int),
          "t_xi'_int": new $t(t["t_xi'_int"]),
          t_xi_int: new $t(t.t_xi_int),
          "z1_xi'_int": new $t(t["z1_xi'_int"]),
          "z2_xi'_int": new $t(t["z2_xi'_int"])
        };
      }
      function s$(d) {
        const t = [], e = d.length;
        for (let a = 0; a < e; a++) {
          const n = {
            pkbId: d[a].pkbId,
            pkbPublic: {
              public_e: new $t(d[a].pkbPublic.public_e),
              public_n: new $t(d[a].pkbPublic.public_n),
              public_size: new $t(d[a].pkbPublic.public_size)
            }
          };
          t.push(n);
        }
        return t;
      }
      function i$(d) {
        const e = yo({
          useNativeBigInt: true
        }).parse(d);
        return e.tag == "Completed" ? o$(e.contents.presBytes) || "" : e.tag;
      }
      class Ke {
        constructor(t, e = null) {
          this.url = t, this.secret = e;
        }
        headers(t = {}) {
          if (Object.keys(t).length === 0 && !this.secret) return {};
          const e = {
            headers: t
          };
          return this.secret && (e.headers["api-key"] = this.secret), e;
        }
        async walletAddress(t) {
          const { data: e } = await zt.post(`${this.url}/v0/wallet/address`, {
            email: t
          }, this.headers());
          return _e.from_bech32(e.address);
        }
        async isWalletInitialised(t, e) {
          const { data: a } = await zt.post(`${this.url}/v0/wallet/is-initialized`, {
            email: t
          }, this.headers());
          if (!a.is_initialized) return false;
          const n = a.is_initialized[1];
          for (let _ = 0; _ < n.length; _++) if (n[_] == e) return true;
          return false;
        }
        async createWallet(t, e, a, n, _) {
          const s = Xe({
            email: t,
            jwt: e,
            payment_key_hash: a,
            proof_bytes: n,
            fund_address: _
          }), { data: p } = await zt.post(`${this.url}/v0/wallet/create`, s, this.headers({
            "Content-Type": "application/json"
          }));
          return {
            address: _e.from_bech32(p.address),
            transaction: p.transaction,
            transaction_fee: p.transaction_fee,
            transaction_id: p.transaction_id
          };
        }
        async createAndSendFunds(t, e, a, n, _) {
          const s = Xe({
            email: t,
            jwt: e,
            payment_key_hash: a,
            proof_bytes: n,
            outs: _
          }), { data: p } = await zt.post(`${this.url}/v0/wallet/create-and-send-funds`, s, this.headers({
            "Content-Type": "application/json"
          }));
          return {
            address: _e.from_bech32(p.address),
            transaction: p.transaction,
            transaction_fee: p.transaction_fee,
            transaction_id: p.transaction_id
          };
        }
        async sendFunds(t, e, a) {
          const _ = Xe({
            email: t,
            outs: e,
            payment_key_hash: a
          }), { data: c } = await zt.post(`${this.url}/v0/wallet/send-funds`, _, this.headers({
            "Content-Type": "application/json"
          }));
          return {
            transaction: c.transaction,
            transaction_fee: c.transaction_fee,
            transaction_id: c.transaction_id
          };
        }
        async submitTx(t, e = []) {
          const { data: a } = await zt.post(`${this.url}/v0/tx/submit`, {
            email_recipients: e,
            tx: t
          }, this.headers());
          return a;
        }
        async addressUtxo(t) {
          const { data: e } = await zt.post(`${this.url}/v0/utxo/addresses`, [
            t.to_bech32()
          ], this.headers()), a = [];
          for (let n = 0; n < e.length; n++) {
            const c = e[n].ref.split("#"), s = {
              transaction_id: c[0],
              output_index: Number(c[1])
            }, p = {};
            for (const y in e[n].value) p[y] = new $t(e[n].value[y]);
            const l = {
              ref: s,
              address: _e.from_bech32(e[n].address),
              value: p
            };
            a.push(l);
          }
          return a;
        }
      }
      class c$ {
        constructor(t, e, a) {
          this.clientId = t, this.clientSecret = e, this.redirectURL = a;
        }
        getAuthUrl(t) {
          const e = [
            "https://www.googleapis.com/auth/userinfo.email",
            "openid"
          ];
          return `https://accounts.google.com/o/oauth2/v2/auth?${new URLSearchParams({
            client_id: this.clientId,
            redirect_uri: this.redirectURL,
            response_type: "code",
            scope: e.join(" "),
            access_type: "offline",
            include_granted_scopes: "true",
            state: t
          }).toString()}`;
        }
        async getJWT(t) {
          try {
            const e = "https://oauth2.googleapis.com/token", a = new URLSearchParams({
              client_id: this.clientId,
              client_secret: this.clientSecret,
              code: t,
              grant_type: "authorization_code",
              redirect_uri: this.redirectURL
            }), n = await fetch(e, {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded"
              },
              body: a.toString()
            });
            if (!n.ok) throw new Error(`Token exchange failed: ${n.status} ${n.statusText}`);
            const _ = await n.json();
            return console.info("Tokens acquired."), _.id_token;
          } catch (e) {
            console.log(e);
          }
        }
      }
      var ma, jc;
      function Lt() {
        return jc || (jc = 1, ma = {
          options: {
            usePureJavaScript: false
          }
        }), ma;
      }
      var ka = {
        exports: {}
      }, xa, Ac;
      function d$() {
        if (Ac) return xa;
        Ac = 1;
        var d = {};
        xa = d;
        var t = {};
        d.encode = function(a, n, _) {
          if (typeof n != "string") throw new TypeError('"alphabet" must be a string.');
          if (_ !== void 0 && typeof _ != "number") throw new TypeError('"maxline" must be a number.');
          var c = "";
          if (!(a instanceof Uint8Array)) c = e(a, n);
          else {
            var s = 0, p = n.length, l = n.charAt(0), y = [
              0
            ];
            for (s = 0; s < a.length; ++s) {
              for (var R = 0, j = a[s]; R < y.length; ++R) j += y[R] << 8, y[R] = j % p, j = j / p | 0;
              for (; j > 0; ) y.push(j % p), j = j / p | 0;
            }
            for (s = 0; a[s] === 0 && s < a.length - 1; ++s) c += l;
            for (s = y.length - 1; s >= 0; --s) c += n[y[s]];
          }
          if (_) {
            var b = new RegExp(".{1," + _ + "}", "g");
            c = c.match(b).join(`\r
`);
          }
          return c;
        }, d.decode = function(a, n) {
          if (typeof a != "string") throw new TypeError('"input" must be a string.');
          if (typeof n != "string") throw new TypeError('"alphabet" must be a string.');
          var _ = t[n];
          if (!_) {
            _ = t[n] = [];
            for (var c = 0; c < n.length; ++c) _[n.charCodeAt(c)] = c;
          }
          a = a.replace(/\s/g, "");
          for (var s = n.length, p = n.charAt(0), l = [
            0
          ], c = 0; c < a.length; c++) {
            var y = _[a.charCodeAt(c)];
            if (y === void 0) return;
            for (var R = 0, j = y; R < l.length; ++R) j += l[R] * s, l[R] = j & 255, j >>= 8;
            for (; j > 0; ) l.push(j & 255), j >>= 8;
          }
          for (var b = 0; a[b] === p && b < a.length - 1; ++b) l.push(0);
          return typeof Buffer < "u" ? Buffer.from(l.reverse()) : new Uint8Array(l.reverse());
        };
        function e(a, n) {
          var _ = 0, c = n.length, s = n.charAt(0), p = [
            0
          ];
          for (_ = 0; _ < a.length(); ++_) {
            for (var l = 0, y = a.at(_); l < p.length; ++l) y += p[l] << 8, p[l] = y % c, y = y / c | 0;
            for (; y > 0; ) p.push(y % c), y = y / c | 0;
          }
          var R = "";
          for (_ = 0; a.at(_) === 0 && _ < a.length() - 1; ++_) R += s;
          for (_ = p.length - 1; _ >= 0; --_) R += n[p[_]];
          return R;
        }
        return xa;
      }
      var Ic;
      function Ut() {
        if (Ic) return ka.exports;
        Ic = 1;
        var d = Lt(), t = d$(), e = ka.exports = d.util = d.util || {};
        (function() {
          if (typeof process < "u" && process.nextTick && !process.browser) {
            e.nextTick = process.nextTick, typeof setImmediate == "function" ? e.setImmediate = setImmediate : e.setImmediate = e.nextTick;
            return;
          }
          if (typeof setImmediate == "function") {
            e.setImmediate = function() {
              return setImmediate.apply(void 0, arguments);
            }, e.nextTick = function(g) {
              return setImmediate(g);
            };
            return;
          }
          if (e.setImmediate = function(g) {
            setTimeout(g, 0);
          }, typeof window < "u" && typeof window.postMessage == "function") {
            let g = function(u) {
              if (u.source === window && u.data === h) {
                u.stopPropagation();
                var F = k.slice();
                k.length = 0, F.forEach(function(z) {
                  z();
                });
              }
            };
            var h = "forge.setImmediate", k = [];
            e.setImmediate = function(u) {
              k.push(u), k.length === 1 && window.postMessage(h, "*");
            }, window.addEventListener("message", g, true);
          }
          if (typeof MutationObserver < "u") {
            var S = Date.now(), N = true, P = document.createElement("div"), k = [];
            new MutationObserver(function() {
              var u = k.slice();
              k.length = 0, u.forEach(function(F) {
                F();
              });
            }).observe(P, {
              attributes: true
            });
            var v = e.setImmediate;
            e.setImmediate = function(u) {
              Date.now() - S > 15 ? (S = Date.now(), v(u)) : (k.push(u), k.length === 1 && P.setAttribute("a", N = !N));
            };
          }
          e.nextTick = e.setImmediate;
        })(), e.isNodejs = typeof process < "u" && process.versions && process.versions.node, e.globalScope = (function() {
          return e.isNodejs ? globalThis : typeof self > "u" ? window : self;
        })(), e.isArray = Array.isArray || function(h) {
          return Object.prototype.toString.call(h) === "[object Array]";
        }, e.isArrayBuffer = function(h) {
          return typeof ArrayBuffer < "u" && h instanceof ArrayBuffer;
        }, e.isArrayBufferView = function(h) {
          return h && e.isArrayBuffer(h.buffer) && h.byteLength !== void 0;
        };
        function a(h) {
          if (!(h === 8 || h === 16 || h === 24 || h === 32)) throw new Error("Only 8, 16, 24, or 32 bits supported: " + h);
        }
        e.ByteBuffer = n;
        function n(h) {
          if (this.data = "", this.read = 0, typeof h == "string") this.data = h;
          else if (e.isArrayBuffer(h) || e.isArrayBufferView(h)) if (typeof Buffer < "u" && h instanceof Buffer) this.data = h.toString("binary");
          else {
            var k = new Uint8Array(h);
            try {
              this.data = String.fromCharCode.apply(null, k);
            } catch {
              for (var S = 0; S < k.length; ++S) this.putByte(k[S]);
            }
          }
          else (h instanceof n || typeof h == "object" && typeof h.data == "string" && typeof h.read == "number") && (this.data = h.data, this.read = h.read);
          this._constructedStringLength = 0;
        }
        e.ByteStringBuffer = n;
        var _ = 4096;
        e.ByteStringBuffer.prototype._optimizeConstructedString = function(h) {
          this._constructedStringLength += h, this._constructedStringLength > _ && (this.data.substr(0, 1), this._constructedStringLength = 0);
        }, e.ByteStringBuffer.prototype.length = function() {
          return this.data.length - this.read;
        }, e.ByteStringBuffer.prototype.isEmpty = function() {
          return this.length() <= 0;
        }, e.ByteStringBuffer.prototype.putByte = function(h) {
          return this.putBytes(String.fromCharCode(h));
        }, e.ByteStringBuffer.prototype.fillWithByte = function(h, k) {
          h = String.fromCharCode(h);
          for (var S = this.data; k > 0; ) k & 1 && (S += h), k >>>= 1, k > 0 && (h += h);
          return this.data = S, this._optimizeConstructedString(k), this;
        }, e.ByteStringBuffer.prototype.putBytes = function(h) {
          return this.data += h, this._optimizeConstructedString(h.length), this;
        }, e.ByteStringBuffer.prototype.putString = function(h) {
          return this.putBytes(e.encodeUtf8(h));
        }, e.ByteStringBuffer.prototype.putInt16 = function(h) {
          return this.putBytes(String.fromCharCode(h >> 8 & 255) + String.fromCharCode(h & 255));
        }, e.ByteStringBuffer.prototype.putInt24 = function(h) {
          return this.putBytes(String.fromCharCode(h >> 16 & 255) + String.fromCharCode(h >> 8 & 255) + String.fromCharCode(h & 255));
        }, e.ByteStringBuffer.prototype.putInt32 = function(h) {
          return this.putBytes(String.fromCharCode(h >> 24 & 255) + String.fromCharCode(h >> 16 & 255) + String.fromCharCode(h >> 8 & 255) + String.fromCharCode(h & 255));
        }, e.ByteStringBuffer.prototype.putInt16Le = function(h) {
          return this.putBytes(String.fromCharCode(h & 255) + String.fromCharCode(h >> 8 & 255));
        }, e.ByteStringBuffer.prototype.putInt24Le = function(h) {
          return this.putBytes(String.fromCharCode(h & 255) + String.fromCharCode(h >> 8 & 255) + String.fromCharCode(h >> 16 & 255));
        }, e.ByteStringBuffer.prototype.putInt32Le = function(h) {
          return this.putBytes(String.fromCharCode(h & 255) + String.fromCharCode(h >> 8 & 255) + String.fromCharCode(h >> 16 & 255) + String.fromCharCode(h >> 24 & 255));
        }, e.ByteStringBuffer.prototype.putInt = function(h, k) {
          a(k);
          var S = "";
          do
            k -= 8, S += String.fromCharCode(h >> k & 255);
          while (k > 0);
          return this.putBytes(S);
        }, e.ByteStringBuffer.prototype.putSignedInt = function(h, k) {
          return h < 0 && (h += 2 << k - 1), this.putInt(h, k);
        }, e.ByteStringBuffer.prototype.putBuffer = function(h) {
          return this.putBytes(h.getBytes());
        }, e.ByteStringBuffer.prototype.getByte = function() {
          return this.data.charCodeAt(this.read++);
        }, e.ByteStringBuffer.prototype.getInt16 = function() {
          var h = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
          return this.read += 2, h;
        }, e.ByteStringBuffer.prototype.getInt24 = function() {
          var h = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
          return this.read += 3, h;
        }, e.ByteStringBuffer.prototype.getInt32 = function() {
          var h = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
          return this.read += 4, h;
        }, e.ByteStringBuffer.prototype.getInt16Le = function() {
          var h = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
          return this.read += 2, h;
        }, e.ByteStringBuffer.prototype.getInt24Le = function() {
          var h = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
          return this.read += 3, h;
        }, e.ByteStringBuffer.prototype.getInt32Le = function() {
          var h = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
          return this.read += 4, h;
        }, e.ByteStringBuffer.prototype.getInt = function(h) {
          a(h);
          var k = 0;
          do
            k = (k << 8) + this.data.charCodeAt(this.read++), h -= 8;
          while (h > 0);
          return k;
        }, e.ByteStringBuffer.prototype.getSignedInt = function(h) {
          var k = this.getInt(h), S = 2 << h - 2;
          return k >= S && (k -= S << 1), k;
        }, e.ByteStringBuffer.prototype.getBytes = function(h) {
          var k;
          return h ? (h = Math.min(this.length(), h), k = this.data.slice(this.read, this.read + h), this.read += h) : h === 0 ? k = "" : (k = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), k;
        }, e.ByteStringBuffer.prototype.bytes = function(h) {
          return typeof h > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + h);
        }, e.ByteStringBuffer.prototype.at = function(h) {
          return this.data.charCodeAt(this.read + h);
        }, e.ByteStringBuffer.prototype.setAt = function(h, k) {
          return this.data = this.data.substr(0, this.read + h) + String.fromCharCode(k) + this.data.substr(this.read + h + 1), this;
        }, e.ByteStringBuffer.prototype.last = function() {
          return this.data.charCodeAt(this.data.length - 1);
        }, e.ByteStringBuffer.prototype.copy = function() {
          var h = e.createBuffer(this.data);
          return h.read = this.read, h;
        }, e.ByteStringBuffer.prototype.compact = function() {
          return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this;
        }, e.ByteStringBuffer.prototype.clear = function() {
          return this.data = "", this.read = 0, this;
        }, e.ByteStringBuffer.prototype.truncate = function(h) {
          var k = Math.max(0, this.length() - h);
          return this.data = this.data.substr(this.read, k), this.read = 0, this;
        }, e.ByteStringBuffer.prototype.toHex = function() {
          for (var h = "", k = this.read; k < this.data.length; ++k) {
            var S = this.data.charCodeAt(k);
            S < 16 && (h += "0"), h += S.toString(16);
          }
          return h;
        }, e.ByteStringBuffer.prototype.toString = function() {
          return e.decodeUtf8(this.bytes());
        };
        function c(h, k) {
          k = k || {}, this.read = k.readOffset || 0, this.growSize = k.growSize || 1024;
          var S = e.isArrayBuffer(h), N = e.isArrayBufferView(h);
          if (S || N) {
            S ? this.data = new DataView(h) : this.data = new DataView(h.buffer, h.byteOffset, h.byteLength), this.write = "writeOffset" in k ? k.writeOffset : this.data.byteLength;
            return;
          }
          this.data = new DataView(new ArrayBuffer(0)), this.write = 0, h != null && this.putBytes(h), "writeOffset" in k && (this.write = k.writeOffset);
        }
        e.DataBuffer = c, e.DataBuffer.prototype.length = function() {
          return this.write - this.read;
        }, e.DataBuffer.prototype.isEmpty = function() {
          return this.length() <= 0;
        }, e.DataBuffer.prototype.accommodate = function(h, k) {
          if (this.length() >= h) return this;
          k = Math.max(k || this.growSize, h);
          var S = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength), N = new Uint8Array(this.length() + k);
          return N.set(S), this.data = new DataView(N.buffer), this;
        }, e.DataBuffer.prototype.putByte = function(h) {
          return this.accommodate(1), this.data.setUint8(this.write++, h), this;
        }, e.DataBuffer.prototype.fillWithByte = function(h, k) {
          this.accommodate(k);
          for (var S = 0; S < k; ++S) this.data.setUint8(h);
          return this;
        }, e.DataBuffer.prototype.putBytes = function(h, k) {
          if (e.isArrayBufferView(h)) {
            var S = new Uint8Array(h.buffer, h.byteOffset, h.byteLength), N = S.byteLength - S.byteOffset;
            this.accommodate(N);
            var P = new Uint8Array(this.data.buffer, this.write);
            return P.set(S), this.write += N, this;
          }
          if (e.isArrayBuffer(h)) {
            var S = new Uint8Array(h);
            this.accommodate(S.byteLength);
            var P = new Uint8Array(this.data.buffer);
            return P.set(S, this.write), this.write += S.byteLength, this;
          }
          if (h instanceof e.DataBuffer || typeof h == "object" && typeof h.read == "number" && typeof h.write == "number" && e.isArrayBufferView(h.data)) {
            var S = new Uint8Array(h.data.byteLength, h.read, h.length());
            this.accommodate(S.byteLength);
            var P = new Uint8Array(h.data.byteLength, this.write);
            return P.set(S), this.write += S.byteLength, this;
          }
          if (h instanceof e.ByteStringBuffer && (h = h.data, k = "binary"), k = k || "binary", typeof h == "string") {
            var v;
            if (k === "hex") return this.accommodate(Math.ceil(h.length / 2)), v = new Uint8Array(this.data.buffer, this.write), this.write += e.binary.hex.decode(h, v, this.write), this;
            if (k === "base64") return this.accommodate(Math.ceil(h.length / 4) * 3), v = new Uint8Array(this.data.buffer, this.write), this.write += e.binary.base64.decode(h, v, this.write), this;
            if (k === "utf8" && (h = e.encodeUtf8(h), k = "binary"), k === "binary" || k === "raw") return this.accommodate(h.length), v = new Uint8Array(this.data.buffer, this.write), this.write += e.binary.raw.decode(v), this;
            if (k === "utf16") return this.accommodate(h.length * 2), v = new Uint16Array(this.data.buffer, this.write), this.write += e.text.utf16.encode(v), this;
            throw new Error("Invalid encoding: " + k);
          }
          throw Error("Invalid parameter: " + h);
        }, e.DataBuffer.prototype.putBuffer = function(h) {
          return this.putBytes(h), h.clear(), this;
        }, e.DataBuffer.prototype.putString = function(h) {
          return this.putBytes(h, "utf16");
        }, e.DataBuffer.prototype.putInt16 = function(h) {
          return this.accommodate(2), this.data.setInt16(this.write, h), this.write += 2, this;
        }, e.DataBuffer.prototype.putInt24 = function(h) {
          return this.accommodate(3), this.data.setInt16(this.write, h >> 8 & 65535), this.data.setInt8(this.write, h >> 16 & 255), this.write += 3, this;
        }, e.DataBuffer.prototype.putInt32 = function(h) {
          return this.accommodate(4), this.data.setInt32(this.write, h), this.write += 4, this;
        }, e.DataBuffer.prototype.putInt16Le = function(h) {
          return this.accommodate(2), this.data.setInt16(this.write, h, true), this.write += 2, this;
        }, e.DataBuffer.prototype.putInt24Le = function(h) {
          return this.accommodate(3), this.data.setInt8(this.write, h >> 16 & 255), this.data.setInt16(this.write, h >> 8 & 65535, true), this.write += 3, this;
        }, e.DataBuffer.prototype.putInt32Le = function(h) {
          return this.accommodate(4), this.data.setInt32(this.write, h, true), this.write += 4, this;
        }, e.DataBuffer.prototype.putInt = function(h, k) {
          a(k), this.accommodate(k / 8);
          do
            k -= 8, this.data.setInt8(this.write++, h >> k & 255);
          while (k > 0);
          return this;
        }, e.DataBuffer.prototype.putSignedInt = function(h, k) {
          return a(k), this.accommodate(k / 8), h < 0 && (h += 2 << k - 1), this.putInt(h, k);
        }, e.DataBuffer.prototype.getByte = function() {
          return this.data.getInt8(this.read++);
        }, e.DataBuffer.prototype.getInt16 = function() {
          var h = this.data.getInt16(this.read);
          return this.read += 2, h;
        }, e.DataBuffer.prototype.getInt24 = function() {
          var h = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
          return this.read += 3, h;
        }, e.DataBuffer.prototype.getInt32 = function() {
          var h = this.data.getInt32(this.read);
          return this.read += 4, h;
        }, e.DataBuffer.prototype.getInt16Le = function() {
          var h = this.data.getInt16(this.read, true);
          return this.read += 2, h;
        }, e.DataBuffer.prototype.getInt24Le = function() {
          var h = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
          return this.read += 3, h;
        }, e.DataBuffer.prototype.getInt32Le = function() {
          var h = this.data.getInt32(this.read, true);
          return this.read += 4, h;
        }, e.DataBuffer.prototype.getInt = function(h) {
          a(h);
          var k = 0;
          do
            k = (k << 8) + this.data.getInt8(this.read++), h -= 8;
          while (h > 0);
          return k;
        }, e.DataBuffer.prototype.getSignedInt = function(h) {
          var k = this.getInt(h), S = 2 << h - 2;
          return k >= S && (k -= S << 1), k;
        }, e.DataBuffer.prototype.getBytes = function(h) {
          var k;
          return h ? (h = Math.min(this.length(), h), k = this.data.slice(this.read, this.read + h), this.read += h) : h === 0 ? k = "" : (k = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), k;
        }, e.DataBuffer.prototype.bytes = function(h) {
          return typeof h > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + h);
        }, e.DataBuffer.prototype.at = function(h) {
          return this.data.getUint8(this.read + h);
        }, e.DataBuffer.prototype.setAt = function(h, k) {
          return this.data.setUint8(h, k), this;
        }, e.DataBuffer.prototype.last = function() {
          return this.data.getUint8(this.write - 1);
        }, e.DataBuffer.prototype.copy = function() {
          return new e.DataBuffer(this);
        }, e.DataBuffer.prototype.compact = function() {
          if (this.read > 0) {
            var h = new Uint8Array(this.data.buffer, this.read), k = new Uint8Array(h.byteLength);
            k.set(h), this.data = new DataView(k), this.write -= this.read, this.read = 0;
          }
          return this;
        }, e.DataBuffer.prototype.clear = function() {
          return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this;
        }, e.DataBuffer.prototype.truncate = function(h) {
          return this.write = Math.max(0, this.length() - h), this.read = Math.min(this.read, this.write), this;
        }, e.DataBuffer.prototype.toHex = function() {
          for (var h = "", k = this.read; k < this.data.byteLength; ++k) {
            var S = this.data.getUint8(k);
            S < 16 && (h += "0"), h += S.toString(16);
          }
          return h;
        }, e.DataBuffer.prototype.toString = function(h) {
          var k = new Uint8Array(this.data, this.read, this.length());
          if (h = h || "utf8", h === "binary" || h === "raw") return e.binary.raw.encode(k);
          if (h === "hex") return e.binary.hex.encode(k);
          if (h === "base64") return e.binary.base64.encode(k);
          if (h === "utf8") return e.text.utf8.decode(k);
          if (h === "utf16") return e.text.utf16.decode(k);
          throw new Error("Invalid encoding: " + h);
        }, e.createBuffer = function(h, k) {
          return k = k || "raw", h !== void 0 && k === "utf8" && (h = e.encodeUtf8(h)), new e.ByteBuffer(h);
        }, e.fillString = function(h, k) {
          for (var S = ""; k > 0; ) k & 1 && (S += h), k >>>= 1, k > 0 && (h += h);
          return S;
        }, e.xorBytes = function(h, k, S) {
          for (var N = "", P = "", v = "", g = 0, u = 0; S > 0; --S, ++g) P = h.charCodeAt(g) ^ k.charCodeAt(g), u >= 10 && (N += v, v = "", u = 0), v += String.fromCharCode(P), ++u;
          return N += v, N;
        }, e.hexToBytes = function(h) {
          var k = "", S = 0;
          for (h.length & true && (S = 1, k += String.fromCharCode(parseInt(h[0], 16))); S < h.length; S += 2) k += String.fromCharCode(parseInt(h.substr(S, 2), 16));
          return k;
        }, e.bytesToHex = function(h) {
          return e.createBuffer(h).toHex();
        }, e.int32ToBytes = function(h) {
          return String.fromCharCode(h >> 24 & 255) + String.fromCharCode(h >> 16 & 255) + String.fromCharCode(h >> 8 & 255) + String.fromCharCode(h & 255);
        };
        var s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", p = [
          62,
          -1,
          -1,
          -1,
          63,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          -1,
          -1,
          -1,
          64,
          -1,
          -1,
          -1,
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51
        ], l = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        e.encode64 = function(h, k) {
          for (var S = "", N = "", P, v, g, u = 0; u < h.length; ) P = h.charCodeAt(u++), v = h.charCodeAt(u++), g = h.charCodeAt(u++), S += s.charAt(P >> 2), S += s.charAt((P & 3) << 4 | v >> 4), isNaN(v) ? S += "==" : (S += s.charAt((v & 15) << 2 | g >> 6), S += isNaN(g) ? "=" : s.charAt(g & 63)), k && S.length > k && (N += S.substr(0, k) + `\r
`, S = S.substr(k));
          return N += S, N;
        }, e.decode64 = function(h) {
          h = h.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          for (var k = "", S, N, P, v, g = 0; g < h.length; ) S = p[h.charCodeAt(g++) - 43], N = p[h.charCodeAt(g++) - 43], P = p[h.charCodeAt(g++) - 43], v = p[h.charCodeAt(g++) - 43], k += String.fromCharCode(S << 2 | N >> 4), P !== 64 && (k += String.fromCharCode((N & 15) << 4 | P >> 2), v !== 64 && (k += String.fromCharCode((P & 3) << 6 | v)));
          return k;
        }, e.encodeUtf8 = function(h) {
          return unescape(encodeURIComponent(h));
        }, e.decodeUtf8 = function(h) {
          return decodeURIComponent(escape(h));
        }, e.binary = {
          raw: {},
          hex: {},
          base64: {},
          base58: {},
          baseN: {
            encode: t.encode,
            decode: t.decode
          }
        }, e.binary.raw.encode = function(h) {
          return String.fromCharCode.apply(null, h);
        }, e.binary.raw.decode = function(h, k, S) {
          var N = k;
          N || (N = new Uint8Array(h.length)), S = S || 0;
          for (var P = S, v = 0; v < h.length; ++v) N[P++] = h.charCodeAt(v);
          return k ? P - S : N;
        }, e.binary.hex.encode = e.bytesToHex, e.binary.hex.decode = function(h, k, S) {
          var N = k;
          N || (N = new Uint8Array(Math.ceil(h.length / 2))), S = S || 0;
          var P = 0, v = S;
          for (h.length & 1 && (P = 1, N[v++] = parseInt(h[0], 16)); P < h.length; P += 2) N[v++] = parseInt(h.substr(P, 2), 16);
          return k ? v - S : N;
        }, e.binary.base64.encode = function(h, k) {
          for (var S = "", N = "", P, v, g, u = 0; u < h.byteLength; ) P = h[u++], v = h[u++], g = h[u++], S += s.charAt(P >> 2), S += s.charAt((P & 3) << 4 | v >> 4), isNaN(v) ? S += "==" : (S += s.charAt((v & 15) << 2 | g >> 6), S += isNaN(g) ? "=" : s.charAt(g & 63)), k && S.length > k && (N += S.substr(0, k) + `\r
`, S = S.substr(k));
          return N += S, N;
        }, e.binary.base64.decode = function(h, k, S) {
          var N = k;
          N || (N = new Uint8Array(Math.ceil(h.length / 4) * 3)), h = h.replace(/[^A-Za-z0-9\+\/\=]/g, ""), S = S || 0;
          for (var P, v, g, u, F = 0, z = S; F < h.length; ) P = p[h.charCodeAt(F++) - 43], v = p[h.charCodeAt(F++) - 43], g = p[h.charCodeAt(F++) - 43], u = p[h.charCodeAt(F++) - 43], N[z++] = P << 2 | v >> 4, g !== 64 && (N[z++] = (v & 15) << 4 | g >> 2, u !== 64 && (N[z++] = (g & 3) << 6 | u));
          return k ? z - S : N.subarray(0, z);
        }, e.binary.base58.encode = function(h, k) {
          return e.binary.baseN.encode(h, l, k);
        }, e.binary.base58.decode = function(h, k) {
          return e.binary.baseN.decode(h, l, k);
        }, e.text = {
          utf8: {},
          utf16: {}
        }, e.text.utf8.encode = function(h, k, S) {
          h = e.encodeUtf8(h);
          var N = k;
          N || (N = new Uint8Array(h.length)), S = S || 0;
          for (var P = S, v = 0; v < h.length; ++v) N[P++] = h.charCodeAt(v);
          return k ? P - S : N;
        }, e.text.utf8.decode = function(h) {
          return e.decodeUtf8(String.fromCharCode.apply(null, h));
        }, e.text.utf16.encode = function(h, k, S) {
          var N = k;
          N || (N = new Uint8Array(h.length * 2));
          var P = new Uint16Array(N.buffer);
          S = S || 0;
          for (var v = S, g = S, u = 0; u < h.length; ++u) P[g++] = h.charCodeAt(u), v += 2;
          return k ? v - S : N;
        }, e.text.utf16.decode = function(h) {
          return String.fromCharCode.apply(null, new Uint16Array(h.buffer));
        }, e.deflate = function(h, k, S) {
          if (k = e.decode64(h.deflate(e.encode64(k)).rval), S) {
            var N = 2, P = k.charCodeAt(1);
            P & 32 && (N = 6), k = k.substring(N, k.length - 4);
          }
          return k;
        }, e.inflate = function(h, k, S) {
          var N = h.inflate(e.encode64(k)).rval;
          return N === null ? null : e.decode64(N);
        };
        var y = function(h, k, S) {
          if (!h) throw new Error("WebStorage not available.");
          var N;
          if (S === null ? N = h.removeItem(k) : (S = e.encode64(JSON.stringify(S)), N = h.setItem(k, S)), typeof N < "u" && N.rval !== true) {
            var P = new Error(N.error.message);
            throw P.id = N.error.id, P.name = N.error.name, P;
          }
        }, R = function(h, k) {
          if (!h) throw new Error("WebStorage not available.");
          var S = h.getItem(k);
          if (h.init) if (S.rval === null) {
            if (S.error) {
              var N = new Error(S.error.message);
              throw N.id = S.error.id, N.name = S.error.name, N;
            }
            S = null;
          } else S = S.rval;
          return S !== null && (S = JSON.parse(e.decode64(S))), S;
        }, j = function(h, k, S, N) {
          var P = R(h, k);
          P === null && (P = {}), P[S] = N, y(h, k, P);
        }, b = function(h, k, S) {
          var N = R(h, k);
          return N !== null && (N = S in N ? N[S] : null), N;
        }, C = function(h, k, S) {
          var N = R(h, k);
          if (N !== null && S in N) {
            delete N[S];
            var P = true;
            for (var v in N) {
              P = false;
              break;
            }
            P && (N = null), y(h, k, N);
          }
        }, A = function(h, k) {
          y(h, k, null);
        }, T = function(h, k, S) {
          var N = null;
          typeof S > "u" && (S = [
            "web",
            "flash"
          ]);
          var P, v = false, g = null;
          for (var u in S) {
            P = S[u];
            try {
              if (P === "flash" || P === "both") {
                if (k[0] === null) throw new Error("Flash local storage not available.");
                N = h.apply(this, k), v = P === "flash";
              }
              (P === "web" || P === "both") && (k[0] = localStorage, N = h.apply(this, k), v = true);
            } catch (F) {
              g = F;
            }
            if (v) break;
          }
          if (!v) throw g;
          return N;
        };
        return e.setItem = function(h, k, S, N, P) {
          T(j, arguments, P);
        }, e.getItem = function(h, k, S, N) {
          return T(b, arguments, N);
        }, e.removeItem = function(h, k, S, N) {
          T(C, arguments, N);
        }, e.clearItems = function(h, k, S) {
          T(A, arguments, S);
        }, e.isEmpty = function(h) {
          for (var k in h) if (h.hasOwnProperty(k)) return false;
          return true;
        }, e.format = function(h) {
          for (var k = /%./g, S, N, P = 0, v = [], g = 0; S = k.exec(h); ) {
            N = h.substring(g, k.lastIndex - 2), N.length > 0 && v.push(N), g = k.lastIndex;
            var u = S[0][1];
            switch (u) {
              case "s":
              case "o":
                P < arguments.length ? v.push(arguments[P++ + 1]) : v.push("<?>");
                break;
              case "%":
                v.push("%");
                break;
              default:
                v.push("<%" + u + "?>");
            }
          }
          return v.push(h.substring(g)), v.join("");
        }, e.formatNumber = function(h, k, S, N) {
          var P = h, v = isNaN(k = Math.abs(k)) ? 2 : k, g = S === void 0 ? "," : S, u = N === void 0 ? "." : N, F = P < 0 ? "-" : "", z = parseInt(P = Math.abs(+P || 0).toFixed(v), 10) + "", W = z.length > 3 ? z.length % 3 : 0;
          return F + (W ? z.substr(0, W) + u : "") + z.substr(W).replace(/(\d{3})(?=\d)/g, "$1" + u) + (v ? g + Math.abs(P - z).toFixed(v).slice(2) : "");
        }, e.formatSize = function(h) {
          return h >= 1073741824 ? h = e.formatNumber(h / 1073741824, 2, ".", "") + " GiB" : h >= 1048576 ? h = e.formatNumber(h / 1048576, 2, ".", "") + " MiB" : h >= 1024 ? h = e.formatNumber(h / 1024, 0) + " KiB" : h = e.formatNumber(h, 0) + " bytes", h;
        }, e.bytesFromIP = function(h) {
          return h.indexOf(".") !== -1 ? e.bytesFromIPv4(h) : h.indexOf(":") !== -1 ? e.bytesFromIPv6(h) : null;
        }, e.bytesFromIPv4 = function(h) {
          if (h = h.split("."), h.length !== 4) return null;
          for (var k = e.createBuffer(), S = 0; S < h.length; ++S) {
            var N = parseInt(h[S], 10);
            if (isNaN(N)) return null;
            k.putByte(N);
          }
          return k.getBytes();
        }, e.bytesFromIPv6 = function(h) {
          var k = 0;
          h = h.split(":").filter(function(g) {
            return g.length === 0 && ++k, true;
          });
          for (var S = (8 - h.length + k) * 2, N = e.createBuffer(), P = 0; P < 8; ++P) {
            if (!h[P] || h[P].length === 0) {
              N.fillWithByte(0, S), S = 0;
              continue;
            }
            var v = e.hexToBytes(h[P]);
            v.length < 2 && N.putByte(0), N.putBytes(v);
          }
          return N.getBytes();
        }, e.bytesToIP = function(h) {
          return h.length === 4 ? e.bytesToIPv4(h) : h.length === 16 ? e.bytesToIPv6(h) : null;
        }, e.bytesToIPv4 = function(h) {
          if (h.length !== 4) return null;
          for (var k = [], S = 0; S < h.length; ++S) k.push(h.charCodeAt(S));
          return k.join(".");
        }, e.bytesToIPv6 = function(h) {
          if (h.length !== 16) return null;
          for (var k = [], S = [], N = 0, P = 0; P < h.length; P += 2) {
            for (var v = e.bytesToHex(h[P] + h[P + 1]); v[0] === "0" && v !== "0"; ) v = v.substr(1);
            if (v === "0") {
              var g = S[S.length - 1], u = k.length;
              !g || u !== g.end + 1 ? S.push({
                start: u,
                end: u
              }) : (g.end = u, g.end - g.start > S[N].end - S[N].start && (N = S.length - 1));
            }
            k.push(v);
          }
          if (S.length > 0) {
            var F = S[N];
            F.end - F.start > 0 && (k.splice(F.start, F.end - F.start + 1, ""), F.start === 0 && k.unshift(""), F.end === 7 && k.push(""));
          }
          return k.join(":");
        }, e.estimateCores = function(h, k) {
          if (typeof h == "function" && (k = h, h = {}), h = h || {}, "cores" in e && !h.update) return k(null, e.cores);
          if (typeof navigator < "u" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) return e.cores = navigator.hardwareConcurrency, k(null, e.cores);
          if (typeof Worker > "u") return e.cores = 1, k(null, e.cores);
          if (typeof Blob > "u") return e.cores = 2, k(null, e.cores);
          var S = URL.createObjectURL(new Blob([
            "(",
            (function() {
              self.addEventListener("message", function(g) {
                var u = Date.now(), F = u + 4;
                self.postMessage({
                  st: u,
                  et: F
                });
              });
            }).toString(),
            ")()"
          ], {
            type: "application/javascript"
          }));
          N([], 5, 16);
          function N(g, u, F) {
            if (u === 0) {
              var z = Math.floor(g.reduce(function(W, M) {
                return W + M;
              }, 0) / g.length);
              return e.cores = Math.max(1, z), URL.revokeObjectURL(S), k(null, e.cores);
            }
            P(F, function(W, M) {
              g.push(v(F, M)), N(g, u - 1, F);
            });
          }
          function P(g, u) {
            for (var F = [], z = [], W = 0; W < g; ++W) {
              var M = new Worker(S);
              M.addEventListener("message", function(Y) {
                if (z.push(Y.data), z.length === g) {
                  for (var tt = 0; tt < g; ++tt) F[tt].terminate();
                  u(null, z);
                }
              }), F.push(M);
            }
            for (var W = 0; W < g; ++W) F[W].postMessage(W);
          }
          function v(g, u) {
            for (var F = [], z = 0; z < g; ++z) for (var W = u[z], M = F[z] = [], Y = 0; Y < g; ++Y) if (z !== Y) {
              var tt = u[Y];
              (W.st > tt.st && W.st < tt.et || tt.st > W.st && tt.st < W.et) && M.push(Y);
            }
            return F.reduce(function(Z, ot) {
              return Math.max(Z, ot.length);
            }, 0);
          }
        }, ka.exports;
      }
      var Ea, Bc;
      function vo() {
        if (Bc) return Ea;
        Bc = 1;
        var d = Lt();
        Ut(), Ea = d.cipher = d.cipher || {}, d.cipher.algorithms = d.cipher.algorithms || {}, d.cipher.createCipher = function(e, a) {
          var n = e;
          if (typeof n == "string" && (n = d.cipher.getAlgorithm(n), n && (n = n())), !n) throw new Error("Unsupported algorithm: " + e);
          return new d.cipher.BlockCipher({
            algorithm: n,
            key: a,
            decrypt: false
          });
        }, d.cipher.createDecipher = function(e, a) {
          var n = e;
          if (typeof n == "string" && (n = d.cipher.getAlgorithm(n), n && (n = n())), !n) throw new Error("Unsupported algorithm: " + e);
          return new d.cipher.BlockCipher({
            algorithm: n,
            key: a,
            decrypt: true
          });
        }, d.cipher.registerAlgorithm = function(e, a) {
          e = e.toUpperCase(), d.cipher.algorithms[e] = a;
        }, d.cipher.getAlgorithm = function(e) {
          return e = e.toUpperCase(), e in d.cipher.algorithms ? d.cipher.algorithms[e] : null;
        };
        var t = d.cipher.BlockCipher = function(e) {
          this.algorithm = e.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = false, this._input = null, this.output = null, this._op = e.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = e.decrypt, this.algorithm.initialize(e);
        };
        return t.prototype.start = function(e) {
          e = e || {};
          var a = {};
          for (var n in e) a[n] = e[n];
          a.decrypt = this._decrypt, this._finish = false, this._input = d.util.createBuffer(), this.output = e.output || d.util.createBuffer(), this.mode.start(a);
        }, t.prototype.update = function(e) {
          for (e && this._input.putBuffer(e); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish; ) ;
          this._input.compact();
        }, t.prototype.finish = function(e) {
          e && (this.mode.name === "ECB" || this.mode.name === "CBC") && (this.mode.pad = function(n) {
            return e(this.blockSize, n, false);
          }, this.mode.unpad = function(n) {
            return e(this.blockSize, n, true);
          });
          var a = {};
          return a.decrypt = this._decrypt, a.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, a) || (this._finish = true, this.update(), this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, a)) || this.mode.afterFinish && !this.mode.afterFinish(this.output, a));
        }, Ea;
      }
      var Ca = {
        exports: {}
      }, Rc;
      function Wd() {
        if (Rc) return Ca.exports;
        Rc = 1;
        var d = Lt();
        Ut(), d.cipher = d.cipher || {};
        var t = Ca.exports = d.cipher.modes = d.cipher.modes || {};
        t.ecb = function(_) {
          _ = _ || {}, this.name = "ECB", this.cipher = _.cipher, this.blockSize = _.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
        }, t.ecb.prototype.start = function(_) {
        }, t.ecb.prototype.encrypt = function(_, c, s) {
          if (_.length() < this.blockSize && !(s && _.length() > 0)) return true;
          for (var p = 0; p < this._ints; ++p) this._inBlock[p] = _.getInt32();
          this.cipher.encrypt(this._inBlock, this._outBlock);
          for (var p = 0; p < this._ints; ++p) c.putInt32(this._outBlock[p]);
        }, t.ecb.prototype.decrypt = function(_, c, s) {
          if (_.length() < this.blockSize && !(s && _.length() > 0)) return true;
          for (var p = 0; p < this._ints; ++p) this._inBlock[p] = _.getInt32();
          this.cipher.decrypt(this._inBlock, this._outBlock);
          for (var p = 0; p < this._ints; ++p) c.putInt32(this._outBlock[p]);
        }, t.ecb.prototype.pad = function(_, c) {
          var s = _.length() === this.blockSize ? this.blockSize : this.blockSize - _.length();
          return _.fillWithByte(s, s), true;
        }, t.ecb.prototype.unpad = function(_, c) {
          if (c.overflow > 0) return false;
          var s = _.length(), p = _.at(s - 1);
          return p > this.blockSize << 2 ? false : (_.truncate(p), true);
        }, t.cbc = function(_) {
          _ = _ || {}, this.name = "CBC", this.cipher = _.cipher, this.blockSize = _.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
        }, t.cbc.prototype.start = function(_) {
          if (_.iv === null) {
            if (!this._prev) throw new Error("Invalid IV parameter.");
            this._iv = this._prev.slice(0);
          } else if ("iv" in _) this._iv = e(_.iv, this.blockSize), this._prev = this._iv.slice(0);
          else throw new Error("Invalid IV parameter.");
        }, t.cbc.prototype.encrypt = function(_, c, s) {
          if (_.length() < this.blockSize && !(s && _.length() > 0)) return true;
          for (var p = 0; p < this._ints; ++p) this._inBlock[p] = this._prev[p] ^ _.getInt32();
          this.cipher.encrypt(this._inBlock, this._outBlock);
          for (var p = 0; p < this._ints; ++p) c.putInt32(this._outBlock[p]);
          this._prev = this._outBlock;
        }, t.cbc.prototype.decrypt = function(_, c, s) {
          if (_.length() < this.blockSize && !(s && _.length() > 0)) return true;
          for (var p = 0; p < this._ints; ++p) this._inBlock[p] = _.getInt32();
          this.cipher.decrypt(this._inBlock, this._outBlock);
          for (var p = 0; p < this._ints; ++p) c.putInt32(this._prev[p] ^ this._outBlock[p]);
          this._prev = this._inBlock.slice(0);
        }, t.cbc.prototype.pad = function(_, c) {
          var s = _.length() === this.blockSize ? this.blockSize : this.blockSize - _.length();
          return _.fillWithByte(s, s), true;
        }, t.cbc.prototype.unpad = function(_, c) {
          if (c.overflow > 0) return false;
          var s = _.length(), p = _.at(s - 1);
          return p > this.blockSize << 2 ? false : (_.truncate(p), true);
        }, t.cfb = function(_) {
          _ = _ || {}, this.name = "CFB", this.cipher = _.cipher, this.blockSize = _.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = d.util.createBuffer(), this._partialBytes = 0;
        }, t.cfb.prototype.start = function(_) {
          if (!("iv" in _)) throw new Error("Invalid IV parameter.");
          this._iv = e(_.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
        }, t.cfb.prototype.encrypt = function(_, c, s) {
          var p = _.length();
          if (p === 0) return true;
          if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && p >= this.blockSize) {
            for (var l = 0; l < this._ints; ++l) this._inBlock[l] = _.getInt32() ^ this._outBlock[l], c.putInt32(this._inBlock[l]);
            return;
          }
          var y = (this.blockSize - p) % this.blockSize;
          y > 0 && (y = this.blockSize - y), this._partialOutput.clear();
          for (var l = 0; l < this._ints; ++l) this._partialBlock[l] = _.getInt32() ^ this._outBlock[l], this._partialOutput.putInt32(this._partialBlock[l]);
          if (y > 0) _.read -= this.blockSize;
          else for (var l = 0; l < this._ints; ++l) this._inBlock[l] = this._partialBlock[l];
          if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), y > 0 && !s) return c.putBytes(this._partialOutput.getBytes(y - this._partialBytes)), this._partialBytes = y, true;
          c.putBytes(this._partialOutput.getBytes(p - this._partialBytes)), this._partialBytes = 0;
        }, t.cfb.prototype.decrypt = function(_, c, s) {
          var p = _.length();
          if (p === 0) return true;
          if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && p >= this.blockSize) {
            for (var l = 0; l < this._ints; ++l) this._inBlock[l] = _.getInt32(), c.putInt32(this._inBlock[l] ^ this._outBlock[l]);
            return;
          }
          var y = (this.blockSize - p) % this.blockSize;
          y > 0 && (y = this.blockSize - y), this._partialOutput.clear();
          for (var l = 0; l < this._ints; ++l) this._partialBlock[l] = _.getInt32(), this._partialOutput.putInt32(this._partialBlock[l] ^ this._outBlock[l]);
          if (y > 0) _.read -= this.blockSize;
          else for (var l = 0; l < this._ints; ++l) this._inBlock[l] = this._partialBlock[l];
          if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), y > 0 && !s) return c.putBytes(this._partialOutput.getBytes(y - this._partialBytes)), this._partialBytes = y, true;
          c.putBytes(this._partialOutput.getBytes(p - this._partialBytes)), this._partialBytes = 0;
        }, t.ofb = function(_) {
          _ = _ || {}, this.name = "OFB", this.cipher = _.cipher, this.blockSize = _.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = d.util.createBuffer(), this._partialBytes = 0;
        }, t.ofb.prototype.start = function(_) {
          if (!("iv" in _)) throw new Error("Invalid IV parameter.");
          this._iv = e(_.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
        }, t.ofb.prototype.encrypt = function(_, c, s) {
          var p = _.length();
          if (_.length() === 0) return true;
          if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && p >= this.blockSize) {
            for (var l = 0; l < this._ints; ++l) c.putInt32(_.getInt32() ^ this._outBlock[l]), this._inBlock[l] = this._outBlock[l];
            return;
          }
          var y = (this.blockSize - p) % this.blockSize;
          y > 0 && (y = this.blockSize - y), this._partialOutput.clear();
          for (var l = 0; l < this._ints; ++l) this._partialOutput.putInt32(_.getInt32() ^ this._outBlock[l]);
          if (y > 0) _.read -= this.blockSize;
          else for (var l = 0; l < this._ints; ++l) this._inBlock[l] = this._outBlock[l];
          if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), y > 0 && !s) return c.putBytes(this._partialOutput.getBytes(y - this._partialBytes)), this._partialBytes = y, true;
          c.putBytes(this._partialOutput.getBytes(p - this._partialBytes)), this._partialBytes = 0;
        }, t.ofb.prototype.decrypt = t.ofb.prototype.encrypt, t.ctr = function(_) {
          _ = _ || {}, this.name = "CTR", this.cipher = _.cipher, this.blockSize = _.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = d.util.createBuffer(), this._partialBytes = 0;
        }, t.ctr.prototype.start = function(_) {
          if (!("iv" in _)) throw new Error("Invalid IV parameter.");
          this._iv = e(_.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
        }, t.ctr.prototype.encrypt = function(_, c, s) {
          var p = _.length();
          if (p === 0) return true;
          if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && p >= this.blockSize) for (var l = 0; l < this._ints; ++l) c.putInt32(_.getInt32() ^ this._outBlock[l]);
          else {
            var y = (this.blockSize - p) % this.blockSize;
            y > 0 && (y = this.blockSize - y), this._partialOutput.clear();
            for (var l = 0; l < this._ints; ++l) this._partialOutput.putInt32(_.getInt32() ^ this._outBlock[l]);
            if (y > 0 && (_.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), y > 0 && !s) return c.putBytes(this._partialOutput.getBytes(y - this._partialBytes)), this._partialBytes = y, true;
            c.putBytes(this._partialOutput.getBytes(p - this._partialBytes)), this._partialBytes = 0;
          }
          a(this._inBlock);
        }, t.ctr.prototype.decrypt = t.ctr.prototype.encrypt, t.gcm = function(_) {
          _ = _ || {}, this.name = "GCM", this.cipher = _.cipher, this.blockSize = _.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = d.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600;
        }, t.gcm.prototype.start = function(_) {
          if (!("iv" in _)) throw new Error("Invalid IV parameter.");
          var c = d.util.createBuffer(_.iv);
          this._cipherLength = 0;
          var s;
          if ("additionalData" in _ ? s = d.util.createBuffer(_.additionalData) : s = d.util.createBuffer(), "tagLength" in _ ? this._tagLength = _.tagLength : this._tagLength = 128, this._tag = null, _.decrypt && (this._tag = d.util.createBuffer(_.tag).getBytes(), this._tag.length !== this._tagLength / 8)) throw new Error("Authentication tag does not match tag length.");
          this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([
            0,
            0,
            0,
            0
          ], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
          var p = c.length();
          if (p === 12) this._j0 = [
            c.getInt32(),
            c.getInt32(),
            c.getInt32(),
            1
          ];
          else {
            for (this._j0 = [
              0,
              0,
              0,
              0
            ]; c.length() > 0; ) this._j0 = this.ghash(this._hashSubkey, this._j0, [
              c.getInt32(),
              c.getInt32(),
              c.getInt32(),
              c.getInt32()
            ]);
            this._j0 = this.ghash(this._hashSubkey, this._j0, [
              0,
              0
            ].concat(n(p * 8)));
          }
          this._inBlock = this._j0.slice(0), a(this._inBlock), this._partialBytes = 0, s = d.util.createBuffer(s), this._aDataLength = n(s.length() * 8);
          var l = s.length() % this.blockSize;
          for (l && s.fillWithByte(0, this.blockSize - l), this._s = [
            0,
            0,
            0,
            0
          ]; s.length() > 0; ) this._s = this.ghash(this._hashSubkey, this._s, [
            s.getInt32(),
            s.getInt32(),
            s.getInt32(),
            s.getInt32()
          ]);
        }, t.gcm.prototype.encrypt = function(_, c, s) {
          var p = _.length();
          if (p === 0) return true;
          if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && p >= this.blockSize) {
            for (var l = 0; l < this._ints; ++l) c.putInt32(this._outBlock[l] ^= _.getInt32());
            this._cipherLength += this.blockSize;
          } else {
            var y = (this.blockSize - p) % this.blockSize;
            y > 0 && (y = this.blockSize - y), this._partialOutput.clear();
            for (var l = 0; l < this._ints; ++l) this._partialOutput.putInt32(_.getInt32() ^ this._outBlock[l]);
            if (y <= 0 || s) {
              if (s) {
                var R = p % this.blockSize;
                this._cipherLength += R, this._partialOutput.truncate(this.blockSize - R);
              } else this._cipherLength += this.blockSize;
              for (var l = 0; l < this._ints; ++l) this._outBlock[l] = this._partialOutput.getInt32();
              this._partialOutput.read -= this.blockSize;
            }
            if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), y > 0 && !s) return _.read -= this.blockSize, c.putBytes(this._partialOutput.getBytes(y - this._partialBytes)), this._partialBytes = y, true;
            c.putBytes(this._partialOutput.getBytes(p - this._partialBytes)), this._partialBytes = 0;
          }
          this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), a(this._inBlock);
        }, t.gcm.prototype.decrypt = function(_, c, s) {
          var p = _.length();
          if (p < this.blockSize && !(s && p > 0)) return true;
          this.cipher.encrypt(this._inBlock, this._outBlock), a(this._inBlock), this._hashBlock[0] = _.getInt32(), this._hashBlock[1] = _.getInt32(), this._hashBlock[2] = _.getInt32(), this._hashBlock[3] = _.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
          for (var l = 0; l < this._ints; ++l) c.putInt32(this._outBlock[l] ^ this._hashBlock[l]);
          p < this.blockSize ? this._cipherLength += p % this.blockSize : this._cipherLength += this.blockSize;
        }, t.gcm.prototype.afterFinish = function(_, c) {
          var s = true;
          c.decrypt && c.overflow && _.truncate(this.blockSize - c.overflow), this.tag = d.util.createBuffer();
          var p = this._aDataLength.concat(n(this._cipherLength * 8));
          this._s = this.ghash(this._hashSubkey, this._s, p);
          var l = [];
          this.cipher.encrypt(this._j0, l);
          for (var y = 0; y < this._ints; ++y) this.tag.putInt32(this._s[y] ^ l[y]);
          return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), c.decrypt && this.tag.bytes() !== this._tag && (s = false), s;
        }, t.gcm.prototype.multiply = function(_, c) {
          for (var s = [
            0,
            0,
            0,
            0
          ], p = c.slice(0), l = 0; l < 128; ++l) {
            var y = _[l / 32 | 0] & 1 << 31 - l % 32;
            y && (s[0] ^= p[0], s[1] ^= p[1], s[2] ^= p[2], s[3] ^= p[3]), this.pow(p, p);
          }
          return s;
        }, t.gcm.prototype.pow = function(_, c) {
          for (var s = _[3] & 1, p = 3; p > 0; --p) c[p] = _[p] >>> 1 | (_[p - 1] & 1) << 31;
          c[0] = _[0] >>> 1, s && (c[0] ^= this._R);
        }, t.gcm.prototype.tableMultiply = function(_) {
          for (var c = [
            0,
            0,
            0,
            0
          ], s = 0; s < 32; ++s) {
            var p = s / 8 | 0, l = _[p] >>> (7 - s % 8) * 4 & 15, y = this._m[s][l];
            c[0] ^= y[0], c[1] ^= y[1], c[2] ^= y[2], c[3] ^= y[3];
          }
          return c;
        }, t.gcm.prototype.ghash = function(_, c, s) {
          return c[0] ^= s[0], c[1] ^= s[1], c[2] ^= s[2], c[3] ^= s[3], this.tableMultiply(c);
        }, t.gcm.prototype.generateHashTable = function(_, c) {
          for (var s = 8 / c, p = 4 * s, l = 16 * s, y = new Array(l), R = 0; R < l; ++R) {
            var j = [
              0,
              0,
              0,
              0
            ], b = R / p | 0, C = (p - 1 - R % p) * c;
            j[b] = 1 << c - 1 << C, y[R] = this.generateSubHashTable(this.multiply(j, _), c);
          }
          return y;
        }, t.gcm.prototype.generateSubHashTable = function(_, c) {
          var s = 1 << c, p = s >>> 1, l = new Array(s);
          l[p] = _.slice(0);
          for (var y = p >>> 1; y > 0; ) this.pow(l[2 * y], l[y] = []), y >>= 1;
          for (y = 2; y < p; ) {
            for (var R = 1; R < y; ++R) {
              var j = l[y], b = l[R];
              l[y + R] = [
                j[0] ^ b[0],
                j[1] ^ b[1],
                j[2] ^ b[2],
                j[3] ^ b[3]
              ];
            }
            y *= 2;
          }
          for (l[0] = [
            0,
            0,
            0,
            0
          ], y = p + 1; y < s; ++y) {
            var C = l[y ^ p];
            l[y] = [
              _[0] ^ C[0],
              _[1] ^ C[1],
              _[2] ^ C[2],
              _[3] ^ C[3]
            ];
          }
          return l;
        };
        function e(_, c) {
          if (typeof _ == "string" && (_ = d.util.createBuffer(_)), d.util.isArray(_) && _.length > 4) {
            var s = _;
            _ = d.util.createBuffer();
            for (var p = 0; p < s.length; ++p) _.putByte(s[p]);
          }
          if (_.length() < c) throw new Error("Invalid IV length; got " + _.length() + " bytes and expected " + c + " bytes.");
          if (!d.util.isArray(_)) {
            for (var l = [], y = c / 4, p = 0; p < y; ++p) l.push(_.getInt32());
            _ = l;
          }
          return _;
        }
        function a(_) {
          _[_.length - 1] = _[_.length - 1] + 1 & 4294967295;
        }
        function n(_) {
          return [
            _ / 4294967296 | 0,
            _ & 4294967295
          ];
        }
        return Ca.exports;
      }
      var Sa, Nc;
      function fn() {
        if (Nc) return Sa;
        Nc = 1;
        var d = Lt();
        vo(), Wd(), Ut(), Sa = d.aes = d.aes || {}, d.aes.startEncrypting = function(b, C, A, T) {
          var h = j({
            key: b,
            output: A,
            decrypt: false,
            mode: T
          });
          return h.start(C), h;
        }, d.aes.createEncryptionCipher = function(b, C) {
          return j({
            key: b,
            output: null,
            decrypt: false,
            mode: C
          });
        }, d.aes.startDecrypting = function(b, C, A, T) {
          var h = j({
            key: b,
            output: A,
            decrypt: true,
            mode: T
          });
          return h.start(C), h;
        }, d.aes.createDecryptionCipher = function(b, C) {
          return j({
            key: b,
            output: null,
            decrypt: true,
            mode: C
          });
        }, d.aes.Algorithm = function(b, C) {
          e || l();
          var A = this;
          A.name = b, A.mode = new C({
            blockSize: 16,
            cipher: {
              encrypt: function(T, h) {
                return R(A._w, T, h, false);
              },
              decrypt: function(T, h) {
                return R(A._w, T, h, true);
              }
            }
          }), A._init = false;
        }, d.aes.Algorithm.prototype.initialize = function(b) {
          if (!this._init) {
            var C = b.key, A;
            if (typeof C == "string" && (C.length === 16 || C.length === 24 || C.length === 32)) C = d.util.createBuffer(C);
            else if (d.util.isArray(C) && (C.length === 16 || C.length === 24 || C.length === 32)) {
              A = C, C = d.util.createBuffer();
              for (var T = 0; T < A.length; ++T) C.putByte(A[T]);
            }
            if (!d.util.isArray(C)) {
              A = C, C = [];
              var h = A.length();
              if (h === 16 || h === 24 || h === 32) {
                h = h >>> 2;
                for (var T = 0; T < h; ++T) C.push(A.getInt32());
              }
            }
            if (!d.util.isArray(C) || !(C.length === 4 || C.length === 6 || C.length === 8)) throw new Error("Invalid key parameter.");
            var k = this.mode.name, S = [
              "CFB",
              "OFB",
              "CTR",
              "GCM"
            ].indexOf(k) !== -1;
            this._w = y(C, b.decrypt && !S), this._init = true;
          }
        }, d.aes._expandKey = function(b, C) {
          return e || l(), y(b, C);
        }, d.aes._updateBlock = R, t("AES-ECB", d.cipher.modes.ecb), t("AES-CBC", d.cipher.modes.cbc), t("AES-CFB", d.cipher.modes.cfb), t("AES-OFB", d.cipher.modes.ofb), t("AES-CTR", d.cipher.modes.ctr), t("AES-GCM", d.cipher.modes.gcm);
        function t(b, C) {
          var A = function() {
            return new d.aes.Algorithm(b, C);
          };
          d.cipher.registerAlgorithm(b, A);
        }
        var e = false, a = 4, n, _, c, s, p;
        function l() {
          e = true, c = [
            0,
            1,
            2,
            4,
            8,
            16,
            32,
            64,
            128,
            27,
            54
          ];
          for (var b = new Array(256), C = 0; C < 128; ++C) b[C] = C << 1, b[C + 128] = C + 128 << 1 ^ 283;
          n = new Array(256), _ = new Array(256), s = new Array(4), p = new Array(4);
          for (var C = 0; C < 4; ++C) s[C] = new Array(256), p[C] = new Array(256);
          for (var A = 0, T = 0, h, k, S, N, P, v, g, C = 0; C < 256; ++C) {
            N = T ^ T << 1 ^ T << 2 ^ T << 3 ^ T << 4, N = N >> 8 ^ N & 255 ^ 99, n[A] = N, _[N] = A, P = b[N], h = b[A], k = b[h], S = b[k], v = P << 24 ^ N << 16 ^ N << 8 ^ (N ^ P), g = (h ^ k ^ S) << 24 ^ (A ^ S) << 16 ^ (A ^ k ^ S) << 8 ^ (A ^ h ^ S);
            for (var u = 0; u < 4; ++u) s[u][A] = v, p[u][N] = g, v = v << 24 | v >>> 8, g = g << 24 | g >>> 8;
            A === 0 ? A = T = 1 : (A = h ^ b[b[b[h ^ S]]], T ^= b[b[T]]);
          }
        }
        function y(b, C) {
          for (var A = b.slice(0), T, h = 1, k = A.length, S = k + 6 + 1, N = a * S, P = k; P < N; ++P) T = A[P - 1], P % k === 0 ? (T = n[T >>> 16 & 255] << 24 ^ n[T >>> 8 & 255] << 16 ^ n[T & 255] << 8 ^ n[T >>> 24] ^ c[h] << 24, h++) : k > 6 && P % k === 4 && (T = n[T >>> 24] << 24 ^ n[T >>> 16 & 255] << 16 ^ n[T >>> 8 & 255] << 8 ^ n[T & 255]), A[P] = A[P - k] ^ T;
          if (C) {
            var v, g = p[0], u = p[1], F = p[2], z = p[3], W = A.slice(0);
            N = A.length;
            for (var P = 0, M = N - a; P < N; P += a, M -= a) if (P === 0 || P === N - a) W[P] = A[M], W[P + 1] = A[M + 3], W[P + 2] = A[M + 2], W[P + 3] = A[M + 1];
            else for (var Y = 0; Y < a; ++Y) v = A[M + Y], W[P + (3 & -Y)] = g[n[v >>> 24]] ^ u[n[v >>> 16 & 255]] ^ F[n[v >>> 8 & 255]] ^ z[n[v & 255]];
            A = W;
          }
          return A;
        }
        function R(b, C, A, T) {
          var h = b.length / 4 - 1, k, S, N, P, v;
          T ? (k = p[0], S = p[1], N = p[2], P = p[3], v = _) : (k = s[0], S = s[1], N = s[2], P = s[3], v = n);
          var g, u, F, z, W, M, Y;
          g = C[0] ^ b[0], u = C[T ? 3 : 1] ^ b[1], F = C[2] ^ b[2], z = C[T ? 1 : 3] ^ b[3];
          for (var tt = 3, Z = 1; Z < h; ++Z) W = k[g >>> 24] ^ S[u >>> 16 & 255] ^ N[F >>> 8 & 255] ^ P[z & 255] ^ b[++tt], M = k[u >>> 24] ^ S[F >>> 16 & 255] ^ N[z >>> 8 & 255] ^ P[g & 255] ^ b[++tt], Y = k[F >>> 24] ^ S[z >>> 16 & 255] ^ N[g >>> 8 & 255] ^ P[u & 255] ^ b[++tt], z = k[z >>> 24] ^ S[g >>> 16 & 255] ^ N[u >>> 8 & 255] ^ P[F & 255] ^ b[++tt], g = W, u = M, F = Y;
          A[0] = v[g >>> 24] << 24 ^ v[u >>> 16 & 255] << 16 ^ v[F >>> 8 & 255] << 8 ^ v[z & 255] ^ b[++tt], A[T ? 3 : 1] = v[u >>> 24] << 24 ^ v[F >>> 16 & 255] << 16 ^ v[z >>> 8 & 255] << 8 ^ v[g & 255] ^ b[++tt], A[2] = v[F >>> 24] << 24 ^ v[z >>> 16 & 255] << 16 ^ v[g >>> 8 & 255] << 8 ^ v[u & 255] ^ b[++tt], A[T ? 1 : 3] = v[z >>> 24] << 24 ^ v[g >>> 16 & 255] << 16 ^ v[u >>> 8 & 255] << 8 ^ v[F & 255] ^ b[++tt];
        }
        function j(b) {
          b = b || {};
          var C = (b.mode || "CBC").toUpperCase(), A = "AES-" + C, T;
          b.decrypt ? T = d.cipher.createDecipher(A, b.key) : T = d.cipher.createCipher(A, b.key);
          var h = T.start;
          return T.start = function(k, S) {
            var N = null;
            S instanceof d.util.ByteBuffer && (N = S, S = {}), S = S || {}, S.output = N, S.iv = k, h.call(T, S);
          }, T;
        }
        return Sa;
      }
      var Ta = {
        exports: {}
      }, ja = {
        exports: {}
      }, Aa = {
        exports: {}
      }, Lc;
      function gn() {
        if (Lc) return Aa.exports;
        Lc = 1;
        var d = Lt();
        d.pki = d.pki || {};
        var t = Aa.exports = d.pki.oids = d.oids = d.oids || {};
        function e(n, _) {
          t[n] = _, t[_] = n;
        }
        function a(n, _) {
          t[n] = _;
        }
        return e("1.2.840.113549.1.1.1", "rsaEncryption"), e("1.2.840.113549.1.1.4", "md5WithRSAEncryption"), e("1.2.840.113549.1.1.5", "sha1WithRSAEncryption"), e("1.2.840.113549.1.1.7", "RSAES-OAEP"), e("1.2.840.113549.1.1.8", "mgf1"), e("1.2.840.113549.1.1.9", "pSpecified"), e("1.2.840.113549.1.1.10", "RSASSA-PSS"), e("1.2.840.113549.1.1.11", "sha256WithRSAEncryption"), e("1.2.840.113549.1.1.12", "sha384WithRSAEncryption"), e("1.2.840.113549.1.1.13", "sha512WithRSAEncryption"), e("1.3.101.112", "EdDSA25519"), e("1.2.840.10040.4.3", "dsa-with-sha1"), e("1.3.14.3.2.7", "desCBC"), e("1.3.14.3.2.26", "sha1"), e("1.3.14.3.2.29", "sha1WithRSASignature"), e("2.16.840.1.101.3.4.2.1", "sha256"), e("2.16.840.1.101.3.4.2.2", "sha384"), e("2.16.840.1.101.3.4.2.3", "sha512"), e("2.16.840.1.101.3.4.2.4", "sha224"), e("2.16.840.1.101.3.4.2.5", "sha512-224"), e("2.16.840.1.101.3.4.2.6", "sha512-256"), e("1.2.840.113549.2.2", "md2"), e("1.2.840.113549.2.5", "md5"), e("1.2.840.113549.1.7.1", "data"), e("1.2.840.113549.1.7.2", "signedData"), e("1.2.840.113549.1.7.3", "envelopedData"), e("1.2.840.113549.1.7.4", "signedAndEnvelopedData"), e("1.2.840.113549.1.7.5", "digestedData"), e("1.2.840.113549.1.7.6", "encryptedData"), e("1.2.840.113549.1.9.1", "emailAddress"), e("1.2.840.113549.1.9.2", "unstructuredName"), e("1.2.840.113549.1.9.3", "contentType"), e("1.2.840.113549.1.9.4", "messageDigest"), e("1.2.840.113549.1.9.5", "signingTime"), e("1.2.840.113549.1.9.6", "counterSignature"), e("1.2.840.113549.1.9.7", "challengePassword"), e("1.2.840.113549.1.9.8", "unstructuredAddress"), e("1.2.840.113549.1.9.14", "extensionRequest"), e("1.2.840.113549.1.9.20", "friendlyName"), e("1.2.840.113549.1.9.21", "localKeyId"), e("1.2.840.113549.1.9.22.1", "x509Certificate"), e("1.2.840.113549.1.12.10.1.1", "keyBag"), e("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag"), e("1.2.840.113549.1.12.10.1.3", "certBag"), e("1.2.840.113549.1.12.10.1.4", "crlBag"), e("1.2.840.113549.1.12.10.1.5", "secretBag"), e("1.2.840.113549.1.12.10.1.6", "safeContentsBag"), e("1.2.840.113549.1.5.13", "pkcs5PBES2"), e("1.2.840.113549.1.5.12", "pkcs5PBKDF2"), e("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4"), e("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4"), e("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC"), e("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC"), e("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC"), e("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC"), e("1.2.840.113549.2.7", "hmacWithSHA1"), e("1.2.840.113549.2.8", "hmacWithSHA224"), e("1.2.840.113549.2.9", "hmacWithSHA256"), e("1.2.840.113549.2.10", "hmacWithSHA384"), e("1.2.840.113549.2.11", "hmacWithSHA512"), e("1.2.840.113549.3.7", "des-EDE3-CBC"), e("2.16.840.1.101.3.4.1.2", "aes128-CBC"), e("2.16.840.1.101.3.4.1.22", "aes192-CBC"), e("2.16.840.1.101.3.4.1.42", "aes256-CBC"), e("2.5.4.3", "commonName"), e("2.5.4.4", "surname"), e("2.5.4.5", "serialNumber"), e("2.5.4.6", "countryName"), e("2.5.4.7", "localityName"), e("2.5.4.8", "stateOrProvinceName"), e("2.5.4.9", "streetAddress"), e("2.5.4.10", "organizationName"), e("2.5.4.11", "organizationalUnitName"), e("2.5.4.12", "title"), e("2.5.4.13", "description"), e("2.5.4.15", "businessCategory"), e("2.5.4.17", "postalCode"), e("2.5.4.42", "givenName"), e("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName"), e("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName"), e("2.16.840.1.113730.1.1", "nsCertType"), e("2.16.840.1.113730.1.13", "nsComment"), a("2.5.29.1", "authorityKeyIdentifier"), a("2.5.29.2", "keyAttributes"), a("2.5.29.3", "certificatePolicies"), a("2.5.29.4", "keyUsageRestriction"), a("2.5.29.5", "policyMapping"), a("2.5.29.6", "subtreesConstraint"), a("2.5.29.7", "subjectAltName"), a("2.5.29.8", "issuerAltName"), a("2.5.29.9", "subjectDirectoryAttributes"), a("2.5.29.10", "basicConstraints"), a("2.5.29.11", "nameConstraints"), a("2.5.29.12", "policyConstraints"), a("2.5.29.13", "basicConstraints"), e("2.5.29.14", "subjectKeyIdentifier"), e("2.5.29.15", "keyUsage"), a("2.5.29.16", "privateKeyUsagePeriod"), e("2.5.29.17", "subjectAltName"), e("2.5.29.18", "issuerAltName"), e("2.5.29.19", "basicConstraints"), a("2.5.29.20", "cRLNumber"), a("2.5.29.21", "cRLReason"), a("2.5.29.22", "expirationDate"), a("2.5.29.23", "instructionCode"), a("2.5.29.24", "invalidityDate"), a("2.5.29.25", "cRLDistributionPoints"), a("2.5.29.26", "issuingDistributionPoint"), a("2.5.29.27", "deltaCRLIndicator"), a("2.5.29.28", "issuingDistributionPoint"), a("2.5.29.29", "certificateIssuer"), a("2.5.29.30", "nameConstraints"), e("2.5.29.31", "cRLDistributionPoints"), e("2.5.29.32", "certificatePolicies"), a("2.5.29.33", "policyMappings"), a("2.5.29.34", "policyConstraints"), e("2.5.29.35", "authorityKeyIdentifier"), a("2.5.29.36", "policyConstraints"), e("2.5.29.37", "extKeyUsage"), a("2.5.29.46", "freshestCRL"), a("2.5.29.54", "inhibitAnyPolicy"), e("1.3.6.1.4.1.11129.2.4.2", "timestampList"), e("1.3.6.1.5.5.7.1.1", "authorityInfoAccess"), e("1.3.6.1.5.5.7.3.1", "serverAuth"), e("1.3.6.1.5.5.7.3.2", "clientAuth"), e("1.3.6.1.5.5.7.3.3", "codeSigning"), e("1.3.6.1.5.5.7.3.4", "emailProtection"), e("1.3.6.1.5.5.7.3.8", "timeStamping"), Aa.exports;
      }
      var Fc;
      function gr() {
        if (Fc) return ja.exports;
        Fc = 1;
        var d = Lt();
        Ut(), gn();
        var t = ja.exports = d.asn1 = d.asn1 || {};
        t.Class = {
          UNIVERSAL: 0,
          APPLICATION: 64,
          CONTEXT_SPECIFIC: 128,
          PRIVATE: 192
        }, t.Type = {
          NONE: 0,
          BOOLEAN: 1,
          INTEGER: 2,
          BITSTRING: 3,
          OCTETSTRING: 4,
          NULL: 5,
          OID: 6,
          ODESC: 7,
          EXTERNAL: 8,
          REAL: 9,
          ENUMERATED: 10,
          EMBEDDED: 11,
          UTF8: 12,
          ROID: 13,
          SEQUENCE: 16,
          SET: 17,
          PRINTABLESTRING: 19,
          IA5STRING: 22,
          UTCTIME: 23,
          GENERALIZEDTIME: 24,
          BMPSTRING: 30
        }, t.create = function(c, s, p, l, y) {
          if (d.util.isArray(l)) {
            for (var R = [], j = 0; j < l.length; ++j) l[j] !== void 0 && R.push(l[j]);
            l = R;
          }
          var b = {
            tagClass: c,
            type: s,
            constructed: p,
            composed: p || d.util.isArray(l),
            value: l
          };
          return y && "bitStringContents" in y && (b.bitStringContents = y.bitStringContents, b.original = t.copy(b)), b;
        }, t.copy = function(c, s) {
          var p;
          if (d.util.isArray(c)) {
            p = [];
            for (var l = 0; l < c.length; ++l) p.push(t.copy(c[l], s));
            return p;
          }
          return typeof c == "string" ? c : (p = {
            tagClass: c.tagClass,
            type: c.type,
            constructed: c.constructed,
            composed: c.composed,
            value: t.copy(c.value, s)
          }, s && !s.excludeBitStringContents && (p.bitStringContents = c.bitStringContents), p);
        }, t.equals = function(c, s, p) {
          if (d.util.isArray(c)) {
            if (!d.util.isArray(s) || c.length !== s.length) return false;
            for (var l = 0; l < c.length; ++l) if (!t.equals(c[l], s[l])) return false;
            return true;
          }
          if (typeof c != typeof s) return false;
          if (typeof c == "string") return c === s;
          var y = c.tagClass === s.tagClass && c.type === s.type && c.constructed === s.constructed && c.composed === s.composed && t.equals(c.value, s.value);
          return p && p.includeBitStringContents && (y = y && c.bitStringContents === s.bitStringContents), y;
        }, t.getBerValueLength = function(c) {
          var s = c.getByte();
          if (s !== 128) {
            var p, l = s & 128;
            return l ? p = c.getInt((s & 127) << 3) : p = s, p;
          }
        };
        function e(c, s, p) {
          if (p > s) {
            var l = new Error("Too few bytes to parse DER.");
            throw l.available = c.length(), l.remaining = s, l.requested = p, l;
          }
        }
        var a = function(c, s) {
          var p = c.getByte();
          if (s--, p !== 128) {
            var l, y = p & 128;
            if (!y) l = p;
            else {
              var R = p & 127;
              e(c, s, R), l = c.getInt(R << 3);
            }
            if (l < 0) throw new Error("Negative length: " + l);
            return l;
          }
        };
        t.fromDer = function(c, s) {
          s === void 0 && (s = {
            strict: true,
            parseAllBytes: true,
            decodeBitStrings: true
          }), typeof s == "boolean" && (s = {
            strict: s,
            parseAllBytes: true,
            decodeBitStrings: true
          }), "strict" in s || (s.strict = true), "parseAllBytes" in s || (s.parseAllBytes = true), "decodeBitStrings" in s || (s.decodeBitStrings = true), typeof c == "string" && (c = d.util.createBuffer(c));
          var p = c.length(), l = n(c, c.length(), 0, s);
          if (s.parseAllBytes && c.length() !== 0) {
            var y = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
            throw y.byteCount = p, y.remaining = c.length(), y;
          }
          return l;
        };
        function n(c, s, p, l) {
          var y;
          e(c, s, 2);
          var R = c.getByte();
          s--;
          var j = R & 192, b = R & 31;
          y = c.length();
          var C = a(c, s);
          if (s -= y - c.length(), C !== void 0 && C > s) {
            if (l.strict) {
              var A = new Error("Too few bytes to read ASN.1 value.");
              throw A.available = c.length(), A.remaining = s, A.requested = C, A;
            }
            C = s;
          }
          var T, h, k = (R & 32) === 32;
          if (k) if (T = [], C === void 0) for (; ; ) {
            if (e(c, s, 2), c.bytes(2) === "\0\0") {
              c.getBytes(2), s -= 2;
              break;
            }
            y = c.length(), T.push(n(c, s, p + 1, l)), s -= y - c.length();
          }
          else for (; C > 0; ) y = c.length(), T.push(n(c, C, p + 1, l)), s -= y - c.length(), C -= y - c.length();
          if (T === void 0 && j === t.Class.UNIVERSAL && b === t.Type.BITSTRING && (h = c.bytes(C)), T === void 0 && l.decodeBitStrings && j === t.Class.UNIVERSAL && b === t.Type.BITSTRING && C > 1) {
            var S = c.read, N = s, P = 0;
            if (b === t.Type.BITSTRING && (e(c, s, 1), P = c.getByte(), s--), P === 0) try {
              y = c.length();
              var v = {
                strict: true,
                decodeBitStrings: true
              }, g = n(c, s, p + 1, v), u = y - c.length();
              s -= u, b == t.Type.BITSTRING && u++;
              var F = g.tagClass;
              u === C && (F === t.Class.UNIVERSAL || F === t.Class.CONTEXT_SPECIFIC) && (T = [
                g
              ]);
            } catch {
            }
            T === void 0 && (c.read = S, s = N);
          }
          if (T === void 0) {
            if (C === void 0) {
              if (l.strict) throw new Error("Non-constructed ASN.1 object of indefinite length.");
              C = s;
            }
            if (b === t.Type.BMPSTRING) for (T = ""; C > 0; C -= 2) e(c, s, 2), T += String.fromCharCode(c.getInt16()), s -= 2;
            else T = c.getBytes(C), s -= C;
          }
          var z = h === void 0 ? null : {
            bitStringContents: h
          };
          return t.create(j, b, k, T, z);
        }
        t.toDer = function(c) {
          var s = d.util.createBuffer(), p = c.tagClass | c.type, l = d.util.createBuffer(), y = false;
          if ("bitStringContents" in c && (y = true, c.original && (y = t.equals(c, c.original))), y) l.putBytes(c.bitStringContents);
          else if (c.composed) {
            c.constructed ? p |= 32 : l.putByte(0);
            for (var R = 0; R < c.value.length; ++R) c.value[R] !== void 0 && l.putBuffer(t.toDer(c.value[R]));
          } else if (c.type === t.Type.BMPSTRING) for (var R = 0; R < c.value.length; ++R) l.putInt16(c.value.charCodeAt(R));
          else c.type === t.Type.INTEGER && c.value.length > 1 && (c.value.charCodeAt(0) === 0 && (c.value.charCodeAt(1) & 128) === 0 || c.value.charCodeAt(0) === 255 && (c.value.charCodeAt(1) & 128) === 128) ? l.putBytes(c.value.substr(1)) : l.putBytes(c.value);
          if (s.putByte(p), l.length() <= 127) s.putByte(l.length() & 127);
          else {
            var j = l.length(), b = "";
            do
              b += String.fromCharCode(j & 255), j = j >>> 8;
            while (j > 0);
            s.putByte(b.length | 128);
            for (var R = b.length - 1; R >= 0; --R) s.putByte(b.charCodeAt(R));
          }
          return s.putBuffer(l), s;
        }, t.oidToDer = function(c) {
          var s = c.split("."), p = d.util.createBuffer();
          p.putByte(40 * parseInt(s[0], 10) + parseInt(s[1], 10));
          for (var l, y, R, j, b = 2; b < s.length; ++b) {
            l = true, y = [], R = parseInt(s[b], 10);
            do
              j = R & 127, R = R >>> 7, l || (j |= 128), y.push(j), l = false;
            while (R > 0);
            for (var C = y.length - 1; C >= 0; --C) p.putByte(y[C]);
          }
          return p;
        }, t.derToOid = function(c) {
          var s;
          typeof c == "string" && (c = d.util.createBuffer(c));
          var p = c.getByte();
          s = Math.floor(p / 40) + "." + p % 40;
          for (var l = 0; c.length() > 0; ) p = c.getByte(), l = l << 7, p & 128 ? l += p & 127 : (s += "." + (l + p), l = 0);
          return s;
        }, t.utcTimeToDate = function(c) {
          var s = /* @__PURE__ */ new Date(), p = parseInt(c.substr(0, 2), 10);
          p = p >= 50 ? 1900 + p : 2e3 + p;
          var l = parseInt(c.substr(2, 2), 10) - 1, y = parseInt(c.substr(4, 2), 10), R = parseInt(c.substr(6, 2), 10), j = parseInt(c.substr(8, 2), 10), b = 0;
          if (c.length > 11) {
            var C = c.charAt(10), A = 10;
            C !== "+" && C !== "-" && (b = parseInt(c.substr(10, 2), 10), A += 2);
          }
          if (s.setUTCFullYear(p, l, y), s.setUTCHours(R, j, b, 0), A && (C = c.charAt(A), C === "+" || C === "-")) {
            var T = parseInt(c.substr(A + 1, 2), 10), h = parseInt(c.substr(A + 4, 2), 10), k = T * 60 + h;
            k *= 6e4, C === "+" ? s.setTime(+s - k) : s.setTime(+s + k);
          }
          return s;
        }, t.generalizedTimeToDate = function(c) {
          var s = /* @__PURE__ */ new Date(), p = parseInt(c.substr(0, 4), 10), l = parseInt(c.substr(4, 2), 10) - 1, y = parseInt(c.substr(6, 2), 10), R = parseInt(c.substr(8, 2), 10), j = parseInt(c.substr(10, 2), 10), b = parseInt(c.substr(12, 2), 10), C = 0, A = 0, T = false;
          c.charAt(c.length - 1) === "Z" && (T = true);
          var h = c.length - 5, k = c.charAt(h);
          if (k === "+" || k === "-") {
            var S = parseInt(c.substr(h + 1, 2), 10), N = parseInt(c.substr(h + 4, 2), 10);
            A = S * 60 + N, A *= 6e4, k === "+" && (A *= -1), T = true;
          }
          return c.charAt(14) === "." && (C = parseFloat(c.substr(14), 10) * 1e3), T ? (s.setUTCFullYear(p, l, y), s.setUTCHours(R, j, b, C), s.setTime(+s + A)) : (s.setFullYear(p, l, y), s.setHours(R, j, b, C)), s;
        }, t.dateToUtcTime = function(c) {
          if (typeof c == "string") return c;
          var s = "", p = [];
          p.push(("" + c.getUTCFullYear()).substr(2)), p.push("" + (c.getUTCMonth() + 1)), p.push("" + c.getUTCDate()), p.push("" + c.getUTCHours()), p.push("" + c.getUTCMinutes()), p.push("" + c.getUTCSeconds());
          for (var l = 0; l < p.length; ++l) p[l].length < 2 && (s += "0"), s += p[l];
          return s += "Z", s;
        }, t.dateToGeneralizedTime = function(c) {
          if (typeof c == "string") return c;
          var s = "", p = [];
          p.push("" + c.getUTCFullYear()), p.push("" + (c.getUTCMonth() + 1)), p.push("" + c.getUTCDate()), p.push("" + c.getUTCHours()), p.push("" + c.getUTCMinutes()), p.push("" + c.getUTCSeconds());
          for (var l = 0; l < p.length; ++l) p[l].length < 2 && (s += "0"), s += p[l];
          return s += "Z", s;
        }, t.integerToDer = function(c) {
          var s = d.util.createBuffer();
          if (c >= -128 && c < 128) return s.putSignedInt(c, 8);
          if (c >= -32768 && c < 32768) return s.putSignedInt(c, 16);
          if (c >= -8388608 && c < 8388608) return s.putSignedInt(c, 24);
          if (c >= -2147483648 && c < 2147483648) return s.putSignedInt(c, 32);
          var p = new Error("Integer too large; max is 32-bits.");
          throw p.integer = c, p;
        }, t.derToInteger = function(c) {
          typeof c == "string" && (c = d.util.createBuffer(c));
          var s = c.length() * 8;
          if (s > 32) throw new Error("Integer too large; max is 32-bits.");
          return c.getSignedInt(s);
        }, t.validate = function(c, s, p, l) {
          var y = false;
          if ((c.tagClass === s.tagClass || typeof s.tagClass > "u") && (c.type === s.type || typeof s.type > "u")) if (c.constructed === s.constructed || typeof s.constructed > "u") {
            if (y = true, s.value && d.util.isArray(s.value)) for (var R = 0, j = 0; y && j < s.value.length; ++j) y = s.value[j].optional || false, c.value[R] && (y = t.validate(c.value[R], s.value[j], p, l), y ? ++R : s.value[j].optional && (y = true)), !y && l && l.push("[" + s.name + '] Tag class "' + s.tagClass + '", type "' + s.type + '" expected value length "' + s.value.length + '", got "' + c.value.length + '"');
            if (y && p && (s.capture && (p[s.capture] = c.value), s.captureAsn1 && (p[s.captureAsn1] = c), s.captureBitStringContents && "bitStringContents" in c && (p[s.captureBitStringContents] = c.bitStringContents), s.captureBitStringValue && "bitStringContents" in c)) if (c.bitStringContents.length < 2) p[s.captureBitStringValue] = "";
            else {
              var b = c.bitStringContents.charCodeAt(0);
              if (b !== 0) throw new Error("captureBitStringValue only supported for zero unused bits");
              p[s.captureBitStringValue] = c.bitStringContents.slice(1);
            }
          } else l && l.push("[" + s.name + '] Expected constructed "' + s.constructed + '", got "' + c.constructed + '"');
          else l && (c.tagClass !== s.tagClass && l.push("[" + s.name + '] Expected tag class "' + s.tagClass + '", got "' + c.tagClass + '"'), c.type !== s.type && l.push("[" + s.name + '] Expected type "' + s.type + '", got "' + c.type + '"'));
          return y;
        };
        var _ = /[^\\u0000-\\u00ff]/;
        return t.prettyPrint = function(c, s, p) {
          var l = "";
          s = s || 0, p = p || 2, s > 0 && (l += `
`);
          for (var y = "", R = 0; R < s * p; ++R) y += " ";
          switch (l += y + "Tag: ", c.tagClass) {
            case t.Class.UNIVERSAL:
              l += "Universal:";
              break;
            case t.Class.APPLICATION:
              l += "Application:";
              break;
            case t.Class.CONTEXT_SPECIFIC:
              l += "Context-Specific:";
              break;
            case t.Class.PRIVATE:
              l += "Private:";
              break;
          }
          if (c.tagClass === t.Class.UNIVERSAL) switch (l += c.type, c.type) {
            case t.Type.NONE:
              l += " (None)";
              break;
            case t.Type.BOOLEAN:
              l += " (Boolean)";
              break;
            case t.Type.INTEGER:
              l += " (Integer)";
              break;
            case t.Type.BITSTRING:
              l += " (Bit string)";
              break;
            case t.Type.OCTETSTRING:
              l += " (Octet string)";
              break;
            case t.Type.NULL:
              l += " (Null)";
              break;
            case t.Type.OID:
              l += " (Object Identifier)";
              break;
            case t.Type.ODESC:
              l += " (Object Descriptor)";
              break;
            case t.Type.EXTERNAL:
              l += " (External or Instance of)";
              break;
            case t.Type.REAL:
              l += " (Real)";
              break;
            case t.Type.ENUMERATED:
              l += " (Enumerated)";
              break;
            case t.Type.EMBEDDED:
              l += " (Embedded PDV)";
              break;
            case t.Type.UTF8:
              l += " (UTF8)";
              break;
            case t.Type.ROID:
              l += " (Relative Object Identifier)";
              break;
            case t.Type.SEQUENCE:
              l += " (Sequence)";
              break;
            case t.Type.SET:
              l += " (Set)";
              break;
            case t.Type.PRINTABLESTRING:
              l += " (Printable String)";
              break;
            case t.Type.IA5String:
              l += " (IA5String (ASCII))";
              break;
            case t.Type.UTCTIME:
              l += " (UTC time)";
              break;
            case t.Type.GENERALIZEDTIME:
              l += " (Generalized time)";
              break;
            case t.Type.BMPSTRING:
              l += " (BMP String)";
              break;
          }
          else l += c.type;
          if (l += `
`, l += y + "Constructed: " + c.constructed + `
`, c.composed) {
            for (var j = 0, b = "", R = 0; R < c.value.length; ++R) c.value[R] !== void 0 && (j += 1, b += t.prettyPrint(c.value[R], s + 1, p), R + 1 < c.value.length && (b += ","));
            l += y + "Sub values: " + j + b;
          } else {
            if (l += y + "Value: ", c.type === t.Type.OID) {
              var C = t.derToOid(c.value);
              l += C, d.pki && d.pki.oids && C in d.pki.oids && (l += " (" + d.pki.oids[C] + ") ");
            }
            if (c.type === t.Type.INTEGER) try {
              l += t.derToInteger(c.value);
            } catch {
              l += "0x" + d.util.bytesToHex(c.value);
            }
            else if (c.type === t.Type.BITSTRING) {
              if (c.value.length > 1 ? l += "0x" + d.util.bytesToHex(c.value.slice(1)) : l += "(none)", c.value.length > 0) {
                var A = c.value.charCodeAt(0);
                A == 1 ? l += " (1 unused bit shown)" : A > 1 && (l += " (" + A + " unused bits shown)");
              }
            } else if (c.type === t.Type.OCTETSTRING) _.test(c.value) || (l += "(" + c.value + ") "), l += "0x" + d.util.bytesToHex(c.value);
            else if (c.type === t.Type.UTF8) try {
              l += d.util.decodeUtf8(c.value);
            } catch (T) {
              if (T.message === "URI malformed") l += "0x" + d.util.bytesToHex(c.value) + " (malformed UTF8)";
              else throw T;
            }
            else c.type === t.Type.PRINTABLESTRING || c.type === t.Type.IA5String ? l += c.value : _.test(c.value) ? l += "0x" + d.util.bytesToHex(c.value) : c.value.length === 0 ? l += "[null]" : l += c.value;
          }
          return l;
        }, ja.exports;
      }
      var Ia = {
        exports: {}
      }, Ba, Oc;
      function $r() {
        if (Oc) return Ba;
        Oc = 1;
        var d = Lt();
        return Ba = d.md = d.md || {}, d.md.algorithms = d.md.algorithms || {}, Ba;
      }
      var Uc;
      function Dn() {
        if (Uc) return Ia.exports;
        Uc = 1;
        var d = Lt();
        $r(), Ut();
        var t = Ia.exports = d.hmac = d.hmac || {};
        return t.create = function() {
          var e = null, a = null, n = null, _ = null, c = {};
          return c.start = function(s, p) {
            if (s !== null) if (typeof s == "string") if (s = s.toLowerCase(), s in d.md.algorithms) a = d.md.algorithms[s].create();
            else throw new Error('Unknown hash algorithm "' + s + '"');
            else a = s;
            if (p === null) p = e;
            else {
              if (typeof p == "string") p = d.util.createBuffer(p);
              else if (d.util.isArray(p)) {
                var l = p;
                p = d.util.createBuffer();
                for (var y = 0; y < l.length; ++y) p.putByte(l[y]);
              }
              var R = p.length();
              R > a.blockLength && (a.start(), a.update(p.bytes()), p = a.digest()), n = d.util.createBuffer(), _ = d.util.createBuffer(), R = p.length();
              for (var y = 0; y < R; ++y) {
                var l = p.at(y);
                n.putByte(54 ^ l), _.putByte(92 ^ l);
              }
              if (R < a.blockLength) for (var l = a.blockLength - R, y = 0; y < l; ++y) n.putByte(54), _.putByte(92);
              e = p, n = n.bytes(), _ = _.bytes();
            }
            a.start(), a.update(n);
          }, c.update = function(s) {
            a.update(s);
          }, c.getMac = function() {
            var s = a.digest().bytes();
            return a.start(), a.update(_), a.update(s), a.digest();
          }, c.digest = c.getMac, c;
        }, Ia.exports;
      }
      var Ra = {
        exports: {}
      }, zc;
      function mo() {
        if (zc) return Ra.exports;
        zc = 1;
        var d = Lt();
        $r(), Ut();
        var t = Ra.exports = d.md5 = d.md5 || {};
        d.md.md5 = d.md.algorithms.md5 = t, t.create = function() {
          c || s();
          var l = null, y = d.util.createBuffer(), R = new Array(16), j = {
            algorithm: "md5",
            blockLength: 64,
            digestLength: 16,
            messageLength: 0,
            fullMessageLength: null,
            messageLengthSize: 8
          };
          return j.start = function() {
            j.messageLength = 0, j.fullMessageLength = j.messageLength64 = [];
            for (var b = j.messageLengthSize / 4, C = 0; C < b; ++C) j.fullMessageLength.push(0);
            return y = d.util.createBuffer(), l = {
              h0: 1732584193,
              h1: 4023233417,
              h2: 2562383102,
              h3: 271733878
            }, j;
          }, j.start(), j.update = function(b, C) {
            C === "utf8" && (b = d.util.encodeUtf8(b));
            var A = b.length;
            j.messageLength += A, A = [
              A / 4294967296 >>> 0,
              A >>> 0
            ];
            for (var T = j.fullMessageLength.length - 1; T >= 0; --T) j.fullMessageLength[T] += A[1], A[1] = A[0] + (j.fullMessageLength[T] / 4294967296 >>> 0), j.fullMessageLength[T] = j.fullMessageLength[T] >>> 0, A[0] = A[1] / 4294967296 >>> 0;
            return y.putBytes(b), p(l, R, y), (y.read > 2048 || y.length() === 0) && y.compact(), j;
          }, j.digest = function() {
            var b = d.util.createBuffer();
            b.putBytes(y.bytes());
            var C = j.fullMessageLength[j.fullMessageLength.length - 1] + j.messageLengthSize, A = C & j.blockLength - 1;
            b.putBytes(e.substr(0, j.blockLength - A));
            for (var T, h = 0, k = j.fullMessageLength.length - 1; k >= 0; --k) T = j.fullMessageLength[k] * 8 + h, h = T / 4294967296 >>> 0, b.putInt32Le(T >>> 0);
            var S = {
              h0: l.h0,
              h1: l.h1,
              h2: l.h2,
              h3: l.h3
            };
            p(S, R, b);
            var N = d.util.createBuffer();
            return N.putInt32Le(S.h0), N.putInt32Le(S.h1), N.putInt32Le(S.h2), N.putInt32Le(S.h3), N;
          }, j;
        };
        var e = null, a = null, n = null, _ = null, c = false;
        function s() {
          e = "\x80", e += d.util.fillString("\0", 64), a = [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            1,
            6,
            11,
            0,
            5,
            10,
            15,
            4,
            9,
            14,
            3,
            8,
            13,
            2,
            7,
            12,
            5,
            8,
            11,
            14,
            1,
            4,
            7,
            10,
            13,
            0,
            3,
            6,
            9,
            12,
            15,
            2,
            0,
            7,
            14,
            5,
            12,
            3,
            10,
            1,
            8,
            15,
            6,
            13,
            4,
            11,
            2,
            9
          ], n = [
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21
          ], _ = new Array(64);
          for (var l = 0; l < 64; ++l) _[l] = Math.floor(Math.abs(Math.sin(l + 1)) * 4294967296);
          c = true;
        }
        function p(l, y, R) {
          for (var j, b, C, A, T, h, k, S, N = R.length(); N >= 64; ) {
            for (b = l.h0, C = l.h1, A = l.h2, T = l.h3, S = 0; S < 16; ++S) y[S] = R.getInt32Le(), h = T ^ C & (A ^ T), j = b + h + _[S] + y[S], k = n[S], b = T, T = A, A = C, C += j << k | j >>> 32 - k;
            for (; S < 32; ++S) h = A ^ T & (C ^ A), j = b + h + _[S] + y[a[S]], k = n[S], b = T, T = A, A = C, C += j << k | j >>> 32 - k;
            for (; S < 48; ++S) h = C ^ A ^ T, j = b + h + _[S] + y[a[S]], k = n[S], b = T, T = A, A = C, C += j << k | j >>> 32 - k;
            for (; S < 64; ++S) h = A ^ (C | ~T), j = b + h + _[S] + y[a[S]], k = n[S], b = T, T = A, A = C, C += j << k | j >>> 32 - k;
            l.h0 = l.h0 + b | 0, l.h1 = l.h1 + C | 0, l.h2 = l.h2 + A | 0, l.h3 = l.h3 + T | 0, N -= 64;
          }
        }
        return Ra.exports;
      }
      var Na = {
        exports: {}
      }, Dc;
      function Cn() {
        if (Dc) return Na.exports;
        Dc = 1;
        var d = Lt();
        Ut();
        var t = Na.exports = d.pem = d.pem || {};
        t.encode = function(n, _) {
          _ = _ || {};
          var c = "-----BEGIN " + n.type + `-----\r
`, s;
          if (n.procType && (s = {
            name: "Proc-Type",
            values: [
              String(n.procType.version),
              n.procType.type
            ]
          }, c += e(s)), n.contentDomain && (s = {
            name: "Content-Domain",
            values: [
              n.contentDomain
            ]
          }, c += e(s)), n.dekInfo && (s = {
            name: "DEK-Info",
            values: [
              n.dekInfo.algorithm
            ]
          }, n.dekInfo.parameters && s.values.push(n.dekInfo.parameters), c += e(s)), n.headers) for (var p = 0; p < n.headers.length; ++p) c += e(n.headers[p]);
          return n.procType && (c += `\r
`), c += d.util.encode64(n.body, _.maxline || 64) + `\r
`, c += "-----END " + n.type + `-----\r
`, c;
        }, t.decode = function(n) {
          for (var _ = [], c = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, s = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, p = /\r?\n/, l; l = c.exec(n), !!l; ) {
            var y = l[1];
            y === "NEW CERTIFICATE REQUEST" && (y = "CERTIFICATE REQUEST");
            var R = {
              type: y,
              procType: null,
              contentDomain: null,
              dekInfo: null,
              headers: [],
              body: d.util.decode64(l[3])
            };
            if (_.push(R), !!l[2]) {
              for (var j = l[2].split(p), b = 0; l && b < j.length; ) {
                for (var C = j[b].replace(/\s+$/, ""), A = b + 1; A < j.length; ++A) {
                  var T = j[A];
                  if (!/\s/.test(T[0])) break;
                  C += T, b = A;
                }
                if (l = C.match(s), l) {
                  for (var h = {
                    name: l[1],
                    values: []
                  }, k = l[2].split(","), S = 0; S < k.length; ++S) h.values.push(a(k[S]));
                  if (R.procType) if (!R.contentDomain && h.name === "Content-Domain") R.contentDomain = k[0] || "";
                  else if (!R.dekInfo && h.name === "DEK-Info") {
                    if (h.values.length === 0) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                    R.dekInfo = {
                      algorithm: k[0],
                      parameters: k[1] || null
                    };
                  } else R.headers.push(h);
                  else {
                    if (h.name !== "Proc-Type") throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
                    if (h.values.length !== 2) throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
                    R.procType = {
                      version: k[0],
                      type: k[1]
                    };
                  }
                }
                ++b;
              }
              if (R.procType === "ENCRYPTED" && !R.dekInfo) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
            }
          }
          if (_.length === 0) throw new Error("Invalid PEM formatted message.");
          return _;
        };
        function e(n) {
          for (var _ = n.name + ": ", c = [], s = function(j, b) {
            return " " + b;
          }, p = 0; p < n.values.length; ++p) c.push(n.values[p].replace(/^(\S+\r\n)/, s));
          _ += c.join(",") + `\r
`;
          for (var l = 0, y = -1, p = 0; p < _.length; ++p, ++l) if (l > 65 && y !== -1) {
            var R = _[y];
            R === "," ? (++y, _ = _.substr(0, y) + `\r
 ` + _.substr(y)) : _ = _.substr(0, y) + `\r
` + R + _.substr(y + 1), l = p - y - 1, y = -1, ++p;
          } else (_[p] === " " || _[p] === "	" || _[p] === ",") && (y = p);
          return _;
        }
        function a(n) {
          return n.replace(/^\s+/, "");
        }
        return Na.exports;
      }
      var La = {
        exports: {}
      }, Fa, Pc;
      function pa() {
        if (Pc) return Fa;
        Pc = 1;
        var d = Lt();
        vo(), Wd(), Ut(), Fa = d.des = d.des || {}, d.des.startEncrypting = function(b, C, A, T) {
          var h = j({
            key: b,
            output: A,
            decrypt: false,
            mode: T || (C === null ? "ECB" : "CBC")
          });
          return h.start(C), h;
        }, d.des.createEncryptionCipher = function(b, C) {
          return j({
            key: b,
            output: null,
            decrypt: false,
            mode: C
          });
        }, d.des.startDecrypting = function(b, C, A, T) {
          var h = j({
            key: b,
            output: A,
            decrypt: true,
            mode: T || (C === null ? "ECB" : "CBC")
          });
          return h.start(C), h;
        }, d.des.createDecryptionCipher = function(b, C) {
          return j({
            key: b,
            output: null,
            decrypt: true,
            mode: C
          });
        }, d.des.Algorithm = function(b, C) {
          var A = this;
          A.name = b, A.mode = new C({
            blockSize: 8,
            cipher: {
              encrypt: function(T, h) {
                return R(A._keys, T, h, false);
              },
              decrypt: function(T, h) {
                return R(A._keys, T, h, true);
              }
            }
          }), A._init = false;
        }, d.des.Algorithm.prototype.initialize = function(b) {
          if (!this._init) {
            var C = d.util.createBuffer(b.key);
            if (this.name.indexOf("3DES") === 0 && C.length() !== 24) throw new Error("Invalid Triple-DES key size: " + C.length() * 8);
            this._keys = y(C), this._init = true;
          }
        }, t("DES-ECB", d.cipher.modes.ecb), t("DES-CBC", d.cipher.modes.cbc), t("DES-CFB", d.cipher.modes.cfb), t("DES-OFB", d.cipher.modes.ofb), t("DES-CTR", d.cipher.modes.ctr), t("3DES-ECB", d.cipher.modes.ecb), t("3DES-CBC", d.cipher.modes.cbc), t("3DES-CFB", d.cipher.modes.cfb), t("3DES-OFB", d.cipher.modes.ofb), t("3DES-CTR", d.cipher.modes.ctr);
        function t(b, C) {
          var A = function() {
            return new d.des.Algorithm(b, C);
          };
          d.cipher.registerAlgorithm(b, A);
        }
        var e = [
          16843776,
          0,
          65536,
          16843780,
          16842756,
          66564,
          4,
          65536,
          1024,
          16843776,
          16843780,
          1024,
          16778244,
          16842756,
          16777216,
          4,
          1028,
          16778240,
          16778240,
          66560,
          66560,
          16842752,
          16842752,
          16778244,
          65540,
          16777220,
          16777220,
          65540,
          0,
          1028,
          66564,
          16777216,
          65536,
          16843780,
          4,
          16842752,
          16843776,
          16777216,
          16777216,
          1024,
          16842756,
          65536,
          66560,
          16777220,
          1024,
          4,
          16778244,
          66564,
          16843780,
          65540,
          16842752,
          16778244,
          16777220,
          1028,
          66564,
          16843776,
          1028,
          16778240,
          16778240,
          0,
          65540,
          66560,
          0,
          16842756
        ], a = [
          -2146402272,
          -2147450880,
          32768,
          1081376,
          1048576,
          32,
          -2146435040,
          -2147450848,
          -2147483616,
          -2146402272,
          -2146402304,
          -2147483648,
          -2147450880,
          1048576,
          32,
          -2146435040,
          1081344,
          1048608,
          -2147450848,
          0,
          -2147483648,
          32768,
          1081376,
          -2146435072,
          1048608,
          -2147483616,
          0,
          1081344,
          32800,
          -2146402304,
          -2146435072,
          32800,
          0,
          1081376,
          -2146435040,
          1048576,
          -2147450848,
          -2146435072,
          -2146402304,
          32768,
          -2146435072,
          -2147450880,
          32,
          -2146402272,
          1081376,
          32,
          32768,
          -2147483648,
          32800,
          -2146402304,
          1048576,
          -2147483616,
          1048608,
          -2147450848,
          -2147483616,
          1048608,
          1081344,
          0,
          -2147450880,
          32800,
          -2147483648,
          -2146435040,
          -2146402272,
          1081344
        ], n = [
          520,
          134349312,
          0,
          134348808,
          134218240,
          0,
          131592,
          134218240,
          131080,
          134217736,
          134217736,
          131072,
          134349320,
          131080,
          134348800,
          520,
          134217728,
          8,
          134349312,
          512,
          131584,
          134348800,
          134348808,
          131592,
          134218248,
          131584,
          131072,
          134218248,
          8,
          134349320,
          512,
          134217728,
          134349312,
          134217728,
          131080,
          520,
          131072,
          134349312,
          134218240,
          0,
          512,
          131080,
          134349320,
          134218240,
          134217736,
          512,
          0,
          134348808,
          134218248,
          131072,
          134217728,
          134349320,
          8,
          131592,
          131584,
          134217736,
          134348800,
          134218248,
          520,
          134348800,
          131592,
          8,
          134348808,
          131584
        ], _ = [
          8396801,
          8321,
          8321,
          128,
          8396928,
          8388737,
          8388609,
          8193,
          0,
          8396800,
          8396800,
          8396929,
          129,
          0,
          8388736,
          8388609,
          1,
          8192,
          8388608,
          8396801,
          128,
          8388608,
          8193,
          8320,
          8388737,
          1,
          8320,
          8388736,
          8192,
          8396928,
          8396929,
          129,
          8388736,
          8388609,
          8396800,
          8396929,
          129,
          0,
          0,
          8396800,
          8320,
          8388736,
          8388737,
          1,
          8396801,
          8321,
          8321,
          128,
          8396929,
          129,
          1,
          8192,
          8388609,
          8193,
          8396928,
          8388737,
          8193,
          8320,
          8388608,
          8396801,
          128,
          8388608,
          8192,
          8396928
        ], c = [
          256,
          34078976,
          34078720,
          1107296512,
          524288,
          256,
          1073741824,
          34078720,
          1074266368,
          524288,
          33554688,
          1074266368,
          1107296512,
          1107820544,
          524544,
          1073741824,
          33554432,
          1074266112,
          1074266112,
          0,
          1073742080,
          1107820800,
          1107820800,
          33554688,
          1107820544,
          1073742080,
          0,
          1107296256,
          34078976,
          33554432,
          1107296256,
          524544,
          524288,
          1107296512,
          256,
          33554432,
          1073741824,
          34078720,
          1107296512,
          1074266368,
          33554688,
          1073741824,
          1107820544,
          34078976,
          1074266368,
          256,
          33554432,
          1107820544,
          1107820800,
          524544,
          1107296256,
          1107820800,
          34078720,
          0,
          1074266112,
          1107296256,
          524544,
          33554688,
          1073742080,
          524288,
          0,
          1074266112,
          34078976,
          1073742080
        ], s = [
          536870928,
          541065216,
          16384,
          541081616,
          541065216,
          16,
          541081616,
          4194304,
          536887296,
          4210704,
          4194304,
          536870928,
          4194320,
          536887296,
          536870912,
          16400,
          0,
          4194320,
          536887312,
          16384,
          4210688,
          536887312,
          16,
          541065232,
          541065232,
          0,
          4210704,
          541081600,
          16400,
          4210688,
          541081600,
          536870912,
          536887296,
          16,
          541065232,
          4210688,
          541081616,
          4194304,
          16400,
          536870928,
          4194304,
          536887296,
          536870912,
          16400,
          536870928,
          541081616,
          4210688,
          541065216,
          4210704,
          541081600,
          0,
          541065232,
          16,
          16384,
          541065216,
          4210704,
          16384,
          4194320,
          536887312,
          0,
          541081600,
          536870912,
          4194320,
          536887312
        ], p = [
          2097152,
          69206018,
          67110914,
          0,
          2048,
          67110914,
          2099202,
          69208064,
          69208066,
          2097152,
          0,
          67108866,
          2,
          67108864,
          69206018,
          2050,
          67110912,
          2099202,
          2097154,
          67110912,
          67108866,
          69206016,
          69208064,
          2097154,
          69206016,
          2048,
          2050,
          69208066,
          2099200,
          2,
          67108864,
          2099200,
          67108864,
          2099200,
          2097152,
          67110914,
          67110914,
          69206018,
          69206018,
          2,
          2097154,
          67108864,
          67110912,
          2097152,
          69208064,
          2050,
          2099202,
          69208064,
          2050,
          67108866,
          69208066,
          69206016,
          2099200,
          0,
          2,
          69208066,
          0,
          2099202,
          69206016,
          2048,
          67108866,
          67110912,
          2048,
          2097154
        ], l = [
          268439616,
          4096,
          262144,
          268701760,
          268435456,
          268439616,
          64,
          268435456,
          262208,
          268697600,
          268701760,
          266240,
          268701696,
          266304,
          4096,
          64,
          268697600,
          268435520,
          268439552,
          4160,
          266240,
          262208,
          268697664,
          268701696,
          4160,
          0,
          0,
          268697664,
          268435520,
          268439552,
          266304,
          262144,
          266304,
          262144,
          268701696,
          4096,
          64,
          268697664,
          4096,
          266304,
          268439552,
          64,
          268435520,
          268697600,
          268697664,
          268435456,
          262144,
          268439616,
          0,
          268701760,
          262208,
          268435520,
          268697600,
          268439552,
          268439616,
          0,
          268701760,
          266240,
          266240,
          4160,
          4160,
          262208,
          268435456,
          268701696
        ];
        function y(b) {
          for (var C = [
            0,
            4,
            536870912,
            536870916,
            65536,
            65540,
            536936448,
            536936452,
            512,
            516,
            536871424,
            536871428,
            66048,
            66052,
            536936960,
            536936964
          ], A = [
            0,
            1,
            1048576,
            1048577,
            67108864,
            67108865,
            68157440,
            68157441,
            256,
            257,
            1048832,
            1048833,
            67109120,
            67109121,
            68157696,
            68157697
          ], T = [
            0,
            8,
            2048,
            2056,
            16777216,
            16777224,
            16779264,
            16779272,
            0,
            8,
            2048,
            2056,
            16777216,
            16777224,
            16779264,
            16779272
          ], h = [
            0,
            2097152,
            134217728,
            136314880,
            8192,
            2105344,
            134225920,
            136323072,
            131072,
            2228224,
            134348800,
            136445952,
            139264,
            2236416,
            134356992,
            136454144
          ], k = [
            0,
            262144,
            16,
            262160,
            0,
            262144,
            16,
            262160,
            4096,
            266240,
            4112,
            266256,
            4096,
            266240,
            4112,
            266256
          ], S = [
            0,
            1024,
            32,
            1056,
            0,
            1024,
            32,
            1056,
            33554432,
            33555456,
            33554464,
            33555488,
            33554432,
            33555456,
            33554464,
            33555488
          ], N = [
            0,
            268435456,
            524288,
            268959744,
            2,
            268435458,
            524290,
            268959746,
            0,
            268435456,
            524288,
            268959744,
            2,
            268435458,
            524290,
            268959746
          ], P = [
            0,
            65536,
            2048,
            67584,
            536870912,
            536936448,
            536872960,
            536938496,
            131072,
            196608,
            133120,
            198656,
            537001984,
            537067520,
            537004032,
            537069568
          ], v = [
            0,
            262144,
            0,
            262144,
            2,
            262146,
            2,
            262146,
            33554432,
            33816576,
            33554432,
            33816576,
            33554434,
            33816578,
            33554434,
            33816578
          ], g = [
            0,
            268435456,
            8,
            268435464,
            0,
            268435456,
            8,
            268435464,
            1024,
            268436480,
            1032,
            268436488,
            1024,
            268436480,
            1032,
            268436488
          ], u = [
            0,
            32,
            0,
            32,
            1048576,
            1048608,
            1048576,
            1048608,
            8192,
            8224,
            8192,
            8224,
            1056768,
            1056800,
            1056768,
            1056800
          ], F = [
            0,
            16777216,
            512,
            16777728,
            2097152,
            18874368,
            2097664,
            18874880,
            67108864,
            83886080,
            67109376,
            83886592,
            69206016,
            85983232,
            69206528,
            85983744
          ], z = [
            0,
            4096,
            134217728,
            134221824,
            524288,
            528384,
            134742016,
            134746112,
            16,
            4112,
            134217744,
            134221840,
            524304,
            528400,
            134742032,
            134746128
          ], W = [
            0,
            4,
            256,
            260,
            0,
            4,
            256,
            260,
            1,
            5,
            257,
            261,
            1,
            5,
            257,
            261
          ], M = b.length() > 8 ? 3 : 1, Y = [], tt = [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
          ], Z = 0, ot, ct = 0; ct < M; ct++) {
            var pt = b.getInt32(), wt = b.getInt32();
            ot = (pt >>> 4 ^ wt) & 252645135, wt ^= ot, pt ^= ot << 4, ot = (wt >>> -16 ^ pt) & 65535, pt ^= ot, wt ^= ot << -16, ot = (pt >>> 2 ^ wt) & 858993459, wt ^= ot, pt ^= ot << 2, ot = (wt >>> -16 ^ pt) & 65535, pt ^= ot, wt ^= ot << -16, ot = (pt >>> 1 ^ wt) & 1431655765, wt ^= ot, pt ^= ot << 1, ot = (wt >>> 8 ^ pt) & 16711935, pt ^= ot, wt ^= ot << 8, ot = (pt >>> 1 ^ wt) & 1431655765, wt ^= ot, pt ^= ot << 1, ot = pt << 8 | wt >>> 20 & 240, pt = wt << 24 | wt << 8 & 16711680 | wt >>> 8 & 65280 | wt >>> 24 & 240, wt = ot;
            for (var yt = 0; yt < tt.length; ++yt) {
              tt[yt] ? (pt = pt << 2 | pt >>> 26, wt = wt << 2 | wt >>> 26) : (pt = pt << 1 | pt >>> 27, wt = wt << 1 | wt >>> 27), pt &= -15, wt &= -15;
              var St = C[pt >>> 28] | A[pt >>> 24 & 15] | T[pt >>> 20 & 15] | h[pt >>> 16 & 15] | k[pt >>> 12 & 15] | S[pt >>> 8 & 15] | N[pt >>> 4 & 15], Bt = P[wt >>> 28] | v[wt >>> 24 & 15] | g[wt >>> 20 & 15] | u[wt >>> 16 & 15] | F[wt >>> 12 & 15] | z[wt >>> 8 & 15] | W[wt >>> 4 & 15];
              ot = (Bt >>> 16 ^ St) & 65535, Y[Z++] = St ^ ot, Y[Z++] = Bt ^ ot << 16;
            }
          }
          return Y;
        }
        function R(b, C, A, T) {
          var h = b.length === 32 ? 3 : 9, k;
          h === 3 ? k = T ? [
            30,
            -2,
            -2
          ] : [
            0,
            32,
            2
          ] : k = T ? [
            94,
            62,
            -2,
            32,
            64,
            2,
            30,
            -2,
            -2
          ] : [
            0,
            32,
            2,
            62,
            30,
            -2,
            64,
            96,
            2
          ];
          var S, N = C[0], P = C[1];
          S = (N >>> 4 ^ P) & 252645135, P ^= S, N ^= S << 4, S = (N >>> 16 ^ P) & 65535, P ^= S, N ^= S << 16, S = (P >>> 2 ^ N) & 858993459, N ^= S, P ^= S << 2, S = (P >>> 8 ^ N) & 16711935, N ^= S, P ^= S << 8, S = (N >>> 1 ^ P) & 1431655765, P ^= S, N ^= S << 1, N = N << 1 | N >>> 31, P = P << 1 | P >>> 31;
          for (var v = 0; v < h; v += 3) {
            for (var g = k[v + 1], u = k[v + 2], F = k[v]; F != g; F += u) {
              var z = P ^ b[F], W = (P >>> 4 | P << 28) ^ b[F + 1];
              S = N, N = P, P = S ^ (a[z >>> 24 & 63] | _[z >>> 16 & 63] | s[z >>> 8 & 63] | l[z & 63] | e[W >>> 24 & 63] | n[W >>> 16 & 63] | c[W >>> 8 & 63] | p[W & 63]);
            }
            S = N, N = P, P = S;
          }
          N = N >>> 1 | N << 31, P = P >>> 1 | P << 31, S = (N >>> 1 ^ P) & 1431655765, P ^= S, N ^= S << 1, S = (P >>> 8 ^ N) & 16711935, N ^= S, P ^= S << 8, S = (P >>> 2 ^ N) & 858993459, N ^= S, P ^= S << 2, S = (N >>> 16 ^ P) & 65535, P ^= S, N ^= S << 16, S = (N >>> 4 ^ P) & 252645135, P ^= S, N ^= S << 4, A[0] = N, A[1] = P;
        }
        function j(b) {
          b = b || {};
          var C = (b.mode || "CBC").toUpperCase(), A = "DES-" + C, T;
          b.decrypt ? T = d.cipher.createDecipher(A, b.key) : T = d.cipher.createCipher(A, b.key);
          var h = T.start;
          return T.start = function(k, S) {
            var N = null;
            S instanceof d.util.ByteBuffer && (N = S, S = {}), S = S || {}, S.output = N, S.iv = k, h.call(T, S);
          }, T;
        }
        return Fa;
      }
      const l$ = {}, p$ = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: l$
      }, Symbol.toStringTag, {
        value: "Module"
      })), ko = t$(p$);
      var Oa, Vc;
      function xo() {
        if (Vc) return Oa;
        Vc = 1;
        var d = Lt();
        Dn(), $r(), Ut();
        var t = d.pkcs5 = d.pkcs5 || {}, e;
        return d.util.isNodejs && !d.options.usePureJavaScript && (e = ko), Oa = d.pbkdf2 = t.pbkdf2 = function(a, n, _, c, s, p) {
          if (typeof s == "function" && (p = s, s = null), d.util.isNodejs && !d.options.usePureJavaScript && e.pbkdf2 && (s === null || typeof s != "object") && (e.pbkdf2Sync.length > 4 || !s || s === "sha1")) return typeof s != "string" && (s = "sha1"), a = Buffer.from(a, "binary"), n = Buffer.from(n, "binary"), p ? e.pbkdf2Sync.length === 4 ? e.pbkdf2(a, n, _, c, function(v, g) {
            if (v) return p(v);
            p(null, g.toString("binary"));
          }) : e.pbkdf2(a, n, _, c, s, function(v, g) {
            if (v) return p(v);
            p(null, g.toString("binary"));
          }) : e.pbkdf2Sync.length === 4 ? e.pbkdf2Sync(a, n, _, c).toString("binary") : e.pbkdf2Sync(a, n, _, c, s).toString("binary");
          if ((typeof s > "u" || s === null) && (s = "sha1"), typeof s == "string") {
            if (!(s in d.md.algorithms)) throw new Error("Unknown hash algorithm: " + s);
            s = d.md[s].create();
          }
          var l = s.digestLength;
          if (c > 4294967295 * l) {
            var y = new Error("Derived key is too long.");
            if (p) return p(y);
            throw y;
          }
          var R = Math.ceil(c / l), j = c - (R - 1) * l, b = d.hmac.create();
          b.start(s, a);
          var C = "", A, T, h;
          if (!p) {
            for (var k = 1; k <= R; ++k) {
              b.start(null, null), b.update(n), b.update(d.util.int32ToBytes(k)), A = h = b.digest().getBytes();
              for (var S = 2; S <= _; ++S) b.start(null, null), b.update(h), T = b.digest().getBytes(), A = d.util.xorBytes(A, T, l), h = T;
              C += k < R ? A : A.substr(0, j);
            }
            return C;
          }
          var k = 1, S;
          function N() {
            if (k > R) return p(null, C);
            b.start(null, null), b.update(n), b.update(d.util.int32ToBytes(k)), A = h = b.digest().getBytes(), S = 2, P();
          }
          function P() {
            if (S <= _) return b.start(null, null), b.update(h), T = b.digest().getBytes(), A = d.util.xorBytes(A, T, l), h = T, ++S, d.util.setImmediate(P);
            C += k < R ? A : A.substr(0, j), ++k, N();
          }
          N();
        }, Oa;
      }
      var Gn = {
        exports: {}
      }, Ua = {
        exports: {}
      }, Mc;
      function Qd() {
        if (Mc) return Ua.exports;
        Mc = 1;
        var d = Lt();
        $r(), Ut();
        var t = Ua.exports = d.sha256 = d.sha256 || {};
        d.md.sha256 = d.md.algorithms.sha256 = t, t.create = function() {
          a || _();
          var s = null, p = d.util.createBuffer(), l = new Array(64), y = {
            algorithm: "sha256",
            blockLength: 64,
            digestLength: 32,
            messageLength: 0,
            fullMessageLength: null,
            messageLengthSize: 8
          };
          return y.start = function() {
            y.messageLength = 0, y.fullMessageLength = y.messageLength64 = [];
            for (var R = y.messageLengthSize / 4, j = 0; j < R; ++j) y.fullMessageLength.push(0);
            return p = d.util.createBuffer(), s = {
              h0: 1779033703,
              h1: 3144134277,
              h2: 1013904242,
              h3: 2773480762,
              h4: 1359893119,
              h5: 2600822924,
              h6: 528734635,
              h7: 1541459225
            }, y;
          }, y.start(), y.update = function(R, j) {
            j === "utf8" && (R = d.util.encodeUtf8(R));
            var b = R.length;
            y.messageLength += b, b = [
              b / 4294967296 >>> 0,
              b >>> 0
            ];
            for (var C = y.fullMessageLength.length - 1; C >= 0; --C) y.fullMessageLength[C] += b[1], b[1] = b[0] + (y.fullMessageLength[C] / 4294967296 >>> 0), y.fullMessageLength[C] = y.fullMessageLength[C] >>> 0, b[0] = b[1] / 4294967296 >>> 0;
            return p.putBytes(R), c(s, l, p), (p.read > 2048 || p.length() === 0) && p.compact(), y;
          }, y.digest = function() {
            var R = d.util.createBuffer();
            R.putBytes(p.bytes());
            var j = y.fullMessageLength[y.fullMessageLength.length - 1] + y.messageLengthSize, b = j & y.blockLength - 1;
            R.putBytes(e.substr(0, y.blockLength - b));
            for (var C, A, T = y.fullMessageLength[0] * 8, h = 0; h < y.fullMessageLength.length - 1; ++h) C = y.fullMessageLength[h + 1] * 8, A = C / 4294967296 >>> 0, T += A, R.putInt32(T >>> 0), T = C >>> 0;
            R.putInt32(T);
            var k = {
              h0: s.h0,
              h1: s.h1,
              h2: s.h2,
              h3: s.h3,
              h4: s.h4,
              h5: s.h5,
              h6: s.h6,
              h7: s.h7
            };
            c(k, l, R);
            var S = d.util.createBuffer();
            return S.putInt32(k.h0), S.putInt32(k.h1), S.putInt32(k.h2), S.putInt32(k.h3), S.putInt32(k.h4), S.putInt32(k.h5), S.putInt32(k.h6), S.putInt32(k.h7), S;
          }, y;
        };
        var e = null, a = false, n = null;
        function _() {
          e = "\x80", e += d.util.fillString("\0", 64), n = [
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
          ], a = true;
        }
        function c(s, p, l) {
          for (var y, R, j, b, C, A, T, h, k, S, N, P, v, g, u, F = l.length(); F >= 64; ) {
            for (T = 0; T < 16; ++T) p[T] = l.getInt32();
            for (; T < 64; ++T) y = p[T - 2], y = (y >>> 17 | y << 15) ^ (y >>> 19 | y << 13) ^ y >>> 10, R = p[T - 15], R = (R >>> 7 | R << 25) ^ (R >>> 18 | R << 14) ^ R >>> 3, p[T] = y + p[T - 7] + R + p[T - 16] | 0;
            for (h = s.h0, k = s.h1, S = s.h2, N = s.h3, P = s.h4, v = s.h5, g = s.h6, u = s.h7, T = 0; T < 64; ++T) b = (P >>> 6 | P << 26) ^ (P >>> 11 | P << 21) ^ (P >>> 25 | P << 7), C = g ^ P & (v ^ g), j = (h >>> 2 | h << 30) ^ (h >>> 13 | h << 19) ^ (h >>> 22 | h << 10), A = h & k | S & (h ^ k), y = u + b + C + n[T] + p[T], R = j + A, u = g, g = v, v = P, P = N + y >>> 0, N = S, S = k, k = h, h = y + R >>> 0;
            s.h0 = s.h0 + h | 0, s.h1 = s.h1 + k | 0, s.h2 = s.h2 + S | 0, s.h3 = s.h3 + N | 0, s.h4 = s.h4 + P | 0, s.h5 = s.h5 + v | 0, s.h6 = s.h6 + g | 0, s.h7 = s.h7 + u | 0, F -= 64;
          }
        }
        return Ua.exports;
      }
      var za = {
        exports: {}
      }, Kc;
      function $d() {
        if (Kc) return za.exports;
        Kc = 1;
        var d = Lt();
        Ut();
        var t = null;
        d.util.isNodejs && !d.options.usePureJavaScript && !process.versions["node-webkit"] && (t = ko);
        var e = za.exports = d.prng = d.prng || {};
        return e.create = function(a) {
          for (var n = {
            plugin: a,
            key: null,
            seed: null,
            time: null,
            reseeds: 0,
            generated: 0,
            keyBytes: ""
          }, _ = a.md, c = new Array(32), s = 0; s < 32; ++s) c[s] = _.create();
          n.pools = c, n.pool = 0, n.generate = function(j, b) {
            if (!b) return n.generateSync(j);
            var C = n.plugin.cipher, A = n.plugin.increment, T = n.plugin.formatKey, h = n.plugin.formatSeed, k = d.util.createBuffer();
            n.key = null, S();
            function S(N) {
              if (N) return b(N);
              if (k.length() >= j) return b(null, k.getBytes(j));
              if (n.generated > 1048575 && (n.key = null), n.key === null) return d.util.nextTick(function() {
                p(S);
              });
              var P = C(n.key, n.seed);
              n.generated += P.length, k.putBytes(P), n.key = T(C(n.key, A(n.seed))), n.seed = h(C(n.key, n.seed)), d.util.setImmediate(S);
            }
          }, n.generateSync = function(j) {
            var b = n.plugin.cipher, C = n.plugin.increment, A = n.plugin.formatKey, T = n.plugin.formatSeed;
            n.key = null;
            for (var h = d.util.createBuffer(); h.length() < j; ) {
              n.generated > 1048575 && (n.key = null), n.key === null && l();
              var k = b(n.key, n.seed);
              n.generated += k.length, h.putBytes(k), n.key = A(b(n.key, C(n.seed))), n.seed = T(b(n.key, n.seed));
            }
            return h.getBytes(j);
          };
          function p(j) {
            if (n.pools[0].messageLength >= 32) return y(), j();
            var b = 32 - n.pools[0].messageLength << 5;
            n.seedFile(b, function(C, A) {
              if (C) return j(C);
              n.collect(A), y(), j();
            });
          }
          function l() {
            if (n.pools[0].messageLength >= 32) return y();
            var j = 32 - n.pools[0].messageLength << 5;
            n.collect(n.seedFileSync(j)), y();
          }
          function y() {
            n.reseeds = n.reseeds === 4294967295 ? 0 : n.reseeds + 1;
            var j = n.plugin.md.create();
            j.update(n.keyBytes);
            for (var b = 1, C = 0; C < 32; ++C) n.reseeds % b === 0 && (j.update(n.pools[C].digest().getBytes()), n.pools[C].start()), b = b << 1;
            n.keyBytes = j.digest().getBytes(), j.start(), j.update(n.keyBytes);
            var A = j.digest().getBytes();
            n.key = n.plugin.formatKey(n.keyBytes), n.seed = n.plugin.formatSeed(A), n.generated = 0;
          }
          function R(j) {
            var b = null, C = d.util.globalScope, A = C.crypto || C.msCrypto;
            A && A.getRandomValues && (b = function(u) {
              return A.getRandomValues(u);
            });
            var T = d.util.createBuffer();
            if (b) for (; T.length() < j; ) {
              var h = Math.max(1, Math.min(j - T.length(), 65536) / 4), k = new Uint32Array(Math.floor(h));
              try {
                b(k);
                for (var S = 0; S < k.length; ++S) T.putInt32(k[S]);
              } catch (u) {
                if (!(typeof QuotaExceededError < "u" && u instanceof QuotaExceededError)) throw u;
              }
            }
            if (T.length() < j) for (var N, P, v, g = Math.floor(Math.random() * 65536); T.length() < j; ) {
              P = 16807 * (g & 65535), N = 16807 * (g >> 16), P += (N & 32767) << 16, P += N >> 15, P = (P & 2147483647) + (P >> 31), g = P & 4294967295;
              for (var S = 0; S < 3; ++S) v = g >>> (S << 3), v ^= Math.floor(Math.random() * 256), T.putByte(v & 255);
            }
            return T.getBytes(j);
          }
          return t ? (n.seedFile = function(j, b) {
            t.randomBytes(j, function(C, A) {
              if (C) return b(C);
              b(null, A.toString());
            });
          }, n.seedFileSync = function(j) {
            return t.randomBytes(j).toString();
          }) : (n.seedFile = function(j, b) {
            try {
              b(null, R(j));
            } catch (C) {
              b(C);
            }
          }, n.seedFileSync = R), n.collect = function(j) {
            for (var b = j.length, C = 0; C < b; ++C) n.pools[n.pool].update(j.substr(C, 1)), n.pool = n.pool === 31 ? 0 : n.pool + 1;
          }, n.collectInt = function(j, b) {
            for (var C = "", A = 0; A < b; A += 8) C += String.fromCharCode(j >> A & 255);
            n.collect(C);
          }, n.registerWorker = function(j) {
            if (j === self) n.seedFile = function(C, A) {
              function T(h) {
                var k = h.data;
                k.forge && k.forge.prng && (self.removeEventListener("message", T), A(k.forge.prng.err, k.forge.prng.bytes));
              }
              self.addEventListener("message", T), self.postMessage({
                forge: {
                  prng: {
                    needed: C
                  }
                }
              });
            };
            else {
              var b = function(C) {
                var A = C.data;
                A.forge && A.forge.prng && n.seedFile(A.forge.prng.needed, function(T, h) {
                  j.postMessage({
                    forge: {
                      prng: {
                        err: T,
                        bytes: h
                      }
                    }
                  });
                });
              };
              j.addEventListener("message", b);
            }
          }, n;
        }, za.exports;
      }
      var qc;
      function ar() {
        if (qc) return Gn.exports;
        qc = 1;
        var d = Lt();
        return fn(), Qd(), $d(), Ut(), (function() {
          if (d.random && d.random.getBytes) {
            Gn.exports = d.random;
            return;
          }
          (function(t) {
            var e = {}, a = new Array(4), n = d.util.createBuffer();
            e.formatKey = function(j) {
              var b = d.util.createBuffer(j);
              return j = new Array(4), j[0] = b.getInt32(), j[1] = b.getInt32(), j[2] = b.getInt32(), j[3] = b.getInt32(), d.aes._expandKey(j, false);
            }, e.formatSeed = function(j) {
              var b = d.util.createBuffer(j);
              return j = new Array(4), j[0] = b.getInt32(), j[1] = b.getInt32(), j[2] = b.getInt32(), j[3] = b.getInt32(), j;
            }, e.cipher = function(j, b) {
              return d.aes._updateBlock(j, b, a, false), n.putInt32(a[0]), n.putInt32(a[1]), n.putInt32(a[2]), n.putInt32(a[3]), n.getBytes();
            }, e.increment = function(j) {
              return ++j[3], j;
            }, e.md = d.md.sha256;
            function _() {
              var j = d.prng.create(e);
              return j.getBytes = function(b, C) {
                return j.generate(b, C);
              }, j.getBytesSync = function(b) {
                return j.generate(b);
              }, j;
            }
            var c = _(), s = null, p = d.util.globalScope, l = p.crypto || p.msCrypto;
            if (l && l.getRandomValues && (s = function(j) {
              return l.getRandomValues(j);
            }), d.options.usePureJavaScript || !d.util.isNodejs && !s) {
              if (c.collectInt(+/* @__PURE__ */ new Date(), 32), typeof navigator < "u") {
                var y = "";
                for (var R in navigator) try {
                  typeof navigator[R] == "string" && (y += navigator[R]);
                } catch {
                }
                c.collect(y), y = null;
              }
              t && (t().mousemove(function(j) {
                c.collectInt(j.clientX, 16), c.collectInt(j.clientY, 16);
              }), t().keypress(function(j) {
                c.collectInt(j.charCode, 8);
              }));
            }
            if (!d.random) d.random = c;
            else for (var R in c) d.random[R] = c[R];
            d.random.createInstance = _, Gn.exports = d.random;
          })(typeof jQuery < "u" ? jQuery : null);
        })(), Gn.exports;
      }
      var Da, Hc;
      function Yd() {
        if (Hc) return Da;
        Hc = 1;
        var d = Lt();
        Ut();
        var t = [
          217,
          120,
          249,
          196,
          25,
          221,
          181,
          237,
          40,
          233,
          253,
          121,
          74,
          160,
          216,
          157,
          198,
          126,
          55,
          131,
          43,
          118,
          83,
          142,
          98,
          76,
          100,
          136,
          68,
          139,
          251,
          162,
          23,
          154,
          89,
          245,
          135,
          179,
          79,
          19,
          97,
          69,
          109,
          141,
          9,
          129,
          125,
          50,
          189,
          143,
          64,
          235,
          134,
          183,
          123,
          11,
          240,
          149,
          33,
          34,
          92,
          107,
          78,
          130,
          84,
          214,
          101,
          147,
          206,
          96,
          178,
          28,
          115,
          86,
          192,
          20,
          167,
          140,
          241,
          220,
          18,
          117,
          202,
          31,
          59,
          190,
          228,
          209,
          66,
          61,
          212,
          48,
          163,
          60,
          182,
          38,
          111,
          191,
          14,
          218,
          70,
          105,
          7,
          87,
          39,
          242,
          29,
          155,
          188,
          148,
          67,
          3,
          248,
          17,
          199,
          246,
          144,
          239,
          62,
          231,
          6,
          195,
          213,
          47,
          200,
          102,
          30,
          215,
          8,
          232,
          234,
          222,
          128,
          82,
          238,
          247,
          132,
          170,
          114,
          172,
          53,
          77,
          106,
          42,
          150,
          26,
          210,
          113,
          90,
          21,
          73,
          116,
          75,
          159,
          208,
          94,
          4,
          24,
          164,
          236,
          194,
          224,
          65,
          110,
          15,
          81,
          203,
          204,
          36,
          145,
          175,
          80,
          161,
          244,
          112,
          57,
          153,
          124,
          58,
          133,
          35,
          184,
          180,
          122,
          252,
          2,
          54,
          91,
          37,
          85,
          151,
          49,
          45,
          93,
          250,
          152,
          227,
          138,
          146,
          174,
          5,
          223,
          41,
          16,
          103,
          108,
          186,
          201,
          211,
          0,
          230,
          207,
          225,
          158,
          168,
          44,
          99,
          22,
          1,
          63,
          88,
          226,
          137,
          169,
          13,
          56,
          52,
          27,
          171,
          51,
          255,
          176,
          187,
          72,
          12,
          95,
          185,
          177,
          205,
          46,
          197,
          243,
          219,
          71,
          229,
          165,
          156,
          119,
          10,
          166,
          32,
          104,
          254,
          127,
          193,
          173
        ], e = [
          1,
          2,
          3,
          5
        ], a = function(c, s) {
          return c << s & 65535 | (c & 65535) >> 16 - s;
        }, n = function(c, s) {
          return (c & 65535) >> s | c << 16 - s & 65535;
        };
        Da = d.rc2 = d.rc2 || {}, d.rc2.expandKey = function(c, s) {
          typeof c == "string" && (c = d.util.createBuffer(c)), s = s || 128;
          var p = c, l = c.length(), y = s, R = Math.ceil(y / 8), j = 255 >> (y & 7), b;
          for (b = l; b < 128; b++) p.putByte(t[p.at(b - 1) + p.at(b - l) & 255]);
          for (p.setAt(128 - R, t[p.at(128 - R) & j]), b = 127 - R; b >= 0; b--) p.setAt(b, t[p.at(b + 1) ^ p.at(b + R)]);
          return p;
        };
        var _ = function(c, s, p) {
          var l = false, y = null, R = null, j = null, b, C, A, T, h = [];
          for (c = d.rc2.expandKey(c, s), A = 0; A < 64; A++) h.push(c.getInt16Le());
          p ? (b = function(N) {
            for (A = 0; A < 4; A++) N[A] += h[T] + (N[(A + 3) % 4] & N[(A + 2) % 4]) + (~N[(A + 3) % 4] & N[(A + 1) % 4]), N[A] = a(N[A], e[A]), T++;
          }, C = function(N) {
            for (A = 0; A < 4; A++) N[A] += h[N[(A + 3) % 4] & 63];
          }) : (b = function(N) {
            for (A = 3; A >= 0; A--) N[A] = n(N[A], e[A]), N[A] -= h[T] + (N[(A + 3) % 4] & N[(A + 2) % 4]) + (~N[(A + 3) % 4] & N[(A + 1) % 4]), T--;
          }, C = function(N) {
            for (A = 3; A >= 0; A--) N[A] -= h[N[(A + 3) % 4] & 63];
          });
          var k = function(N) {
            var P = [];
            for (A = 0; A < 4; A++) {
              var v = y.getInt16Le();
              j !== null && (p ? v ^= j.getInt16Le() : j.putInt16Le(v)), P.push(v & 65535);
            }
            T = p ? 0 : 63;
            for (var g = 0; g < N.length; g++) for (var u = 0; u < N[g][0]; u++) N[g][1](P);
            for (A = 0; A < 4; A++) j !== null && (p ? j.putInt16Le(P[A]) : P[A] ^= j.getInt16Le()), R.putInt16Le(P[A]);
          }, S = null;
          return S = {
            start: function(N, P) {
              N && typeof N == "string" && (N = d.util.createBuffer(N)), l = false, y = d.util.createBuffer(), R = P || new d.util.createBuffer(), j = N, S.output = R;
            },
            update: function(N) {
              for (l || y.putBuffer(N); y.length() >= 8; ) k([
                [
                  5,
                  b
                ],
                [
                  1,
                  C
                ],
                [
                  6,
                  b
                ],
                [
                  1,
                  C
                ],
                [
                  5,
                  b
                ]
              ]);
            },
            finish: function(N) {
              var P = true;
              if (p) if (N) P = N(8, y, !p);
              else {
                var v = y.length() === 8 ? 8 : 8 - y.length();
                y.fillWithByte(v, v);
              }
              if (P && (l = true, S.update()), !p && (P = y.length() === 0, P)) if (N) P = N(8, R, !p);
              else {
                var g = R.length(), u = R.at(g - 1);
                u > g ? P = false : R.truncate(u);
              }
              return P;
            }
          }, S;
        };
        return d.rc2.startEncrypting = function(c, s, p) {
          var l = d.rc2.createEncryptionCipher(c, 128);
          return l.start(s, p), l;
        }, d.rc2.createEncryptionCipher = function(c, s) {
          return _(c, s, true);
        }, d.rc2.startDecrypting = function(c, s, p) {
          var l = d.rc2.createDecryptionCipher(c, 128);
          return l.start(s, p), l;
        }, d.rc2.createDecryptionCipher = function(c, s) {
          return _(c, s, false);
        }, Da;
      }
      var Pa, Gc;
      function ua() {
        if (Gc) return Pa;
        Gc = 1;
        var d = Lt();
        Pa = d.jsbn = d.jsbn || {};
        var t;
        function e(O, V, K) {
          this.data = [], O != null && (typeof O == "number" ? this.fromNumber(O, V, K) : V == null && typeof O != "string" ? this.fromString(O, 256) : this.fromString(O, V));
        }
        d.jsbn.BigInteger = e;
        function a() {
          return new e(null);
        }
        function n(O, V, K, et, dt, lt) {
          for (; --lt >= 0; ) {
            var bt = V * this.data[O++] + K.data[et] + dt;
            dt = Math.floor(bt / 67108864), K.data[et++] = bt & 67108863;
          }
          return dt;
        }
        function _(O, V, K, et, dt, lt) {
          for (var bt = V & 32767, ht = V >> 15; --lt >= 0; ) {
            var Vt = this.data[O] & 32767, xe = this.data[O++] >> 15, Me = ht * Vt + xe * bt;
            Vt = bt * Vt + ((Me & 32767) << 15) + K.data[et] + (dt & 1073741823), dt = (Vt >>> 30) + (Me >>> 15) + ht * xe + (dt >>> 30), K.data[et++] = Vt & 1073741823;
          }
          return dt;
        }
        function c(O, V, K, et, dt, lt) {
          for (var bt = V & 16383, ht = V >> 14; --lt >= 0; ) {
            var Vt = this.data[O] & 16383, xe = this.data[O++] >> 14, Me = ht * Vt + xe * bt;
            Vt = bt * Vt + ((Me & 16383) << 14) + K.data[et] + dt, dt = (Vt >> 28) + (Me >> 14) + ht * xe, K.data[et++] = Vt & 268435455;
          }
          return dt;
        }
        typeof navigator > "u" ? (e.prototype.am = c, t = 28) : navigator.appName == "Microsoft Internet Explorer" ? (e.prototype.am = _, t = 30) : navigator.appName != "Netscape" ? (e.prototype.am = n, t = 26) : (e.prototype.am = c, t = 28), e.prototype.DB = t, e.prototype.DM = (1 << t) - 1, e.prototype.DV = 1 << t;
        var s = 52;
        e.prototype.FV = Math.pow(2, s), e.prototype.F1 = s - t, e.prototype.F2 = 2 * t - s;
        var p = "0123456789abcdefghijklmnopqrstuvwxyz", l = new Array(), y, R;
        for (y = 48, R = 0; R <= 9; ++R) l[y++] = R;
        for (y = 97, R = 10; R < 36; ++R) l[y++] = R;
        for (y = 65, R = 10; R < 36; ++R) l[y++] = R;
        function j(O) {
          return p.charAt(O);
        }
        function b(O, V) {
          var K = l[O.charCodeAt(V)];
          return K ?? -1;
        }
        function C(O) {
          for (var V = this.t - 1; V >= 0; --V) O.data[V] = this.data[V];
          O.t = this.t, O.s = this.s;
        }
        function A(O) {
          this.t = 1, this.s = O < 0 ? -1 : 0, O > 0 ? this.data[0] = O : O < -1 ? this.data[0] = O + this.DV : this.t = 0;
        }
        function T(O) {
          var V = a();
          return V.fromInt(O), V;
        }
        function h(O, V) {
          var K;
          if (V == 16) K = 4;
          else if (V == 8) K = 3;
          else if (V == 256) K = 8;
          else if (V == 2) K = 1;
          else if (V == 32) K = 5;
          else if (V == 4) K = 2;
          else {
            this.fromRadix(O, V);
            return;
          }
          this.t = 0, this.s = 0;
          for (var et = O.length, dt = false, lt = 0; --et >= 0; ) {
            var bt = K == 8 ? O[et] & 255 : b(O, et);
            if (bt < 0) {
              O.charAt(et) == "-" && (dt = true);
              continue;
            }
            dt = false, lt == 0 ? this.data[this.t++] = bt : lt + K > this.DB ? (this.data[this.t - 1] |= (bt & (1 << this.DB - lt) - 1) << lt, this.data[this.t++] = bt >> this.DB - lt) : this.data[this.t - 1] |= bt << lt, lt += K, lt >= this.DB && (lt -= this.DB);
          }
          K == 8 && (O[0] & 128) != 0 && (this.s = -1, lt > 0 && (this.data[this.t - 1] |= (1 << this.DB - lt) - 1 << lt)), this.clamp(), dt && e.ZERO.subTo(this, this);
        }
        function k() {
          for (var O = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == O; ) --this.t;
        }
        function S(O) {
          if (this.s < 0) return "-" + this.negate().toString(O);
          var V;
          if (O == 16) V = 4;
          else if (O == 8) V = 3;
          else if (O == 2) V = 1;
          else if (O == 32) V = 5;
          else if (O == 4) V = 2;
          else return this.toRadix(O);
          var K = (1 << V) - 1, et, dt = false, lt = "", bt = this.t, ht = this.DB - bt * this.DB % V;
          if (bt-- > 0) for (ht < this.DB && (et = this.data[bt] >> ht) > 0 && (dt = true, lt = j(et)); bt >= 0; ) ht < V ? (et = (this.data[bt] & (1 << ht) - 1) << V - ht, et |= this.data[--bt] >> (ht += this.DB - V)) : (et = this.data[bt] >> (ht -= V) & K, ht <= 0 && (ht += this.DB, --bt)), et > 0 && (dt = true), dt && (lt += j(et));
          return dt ? lt : "0";
        }
        function N() {
          var O = a();
          return e.ZERO.subTo(this, O), O;
        }
        function P() {
          return this.s < 0 ? this.negate() : this;
        }
        function v(O) {
          var V = this.s - O.s;
          if (V != 0) return V;
          var K = this.t;
          if (V = K - O.t, V != 0) return this.s < 0 ? -V : V;
          for (; --K >= 0; ) if ((V = this.data[K] - O.data[K]) != 0) return V;
          return 0;
        }
        function g(O) {
          var V = 1, K;
          return (K = O >>> 16) != 0 && (O = K, V += 16), (K = O >> 8) != 0 && (O = K, V += 8), (K = O >> 4) != 0 && (O = K, V += 4), (K = O >> 2) != 0 && (O = K, V += 2), (K = O >> 1) != 0 && (O = K, V += 1), V;
        }
        function u() {
          return this.t <= 0 ? 0 : this.DB * (this.t - 1) + g(this.data[this.t - 1] ^ this.s & this.DM);
        }
        function F(O, V) {
          var K;
          for (K = this.t - 1; K >= 0; --K) V.data[K + O] = this.data[K];
          for (K = O - 1; K >= 0; --K) V.data[K] = 0;
          V.t = this.t + O, V.s = this.s;
        }
        function z(O, V) {
          for (var K = O; K < this.t; ++K) V.data[K - O] = this.data[K];
          V.t = Math.max(this.t - O, 0), V.s = this.s;
        }
        function W(O, V) {
          var K = O % this.DB, et = this.DB - K, dt = (1 << et) - 1, lt = Math.floor(O / this.DB), bt = this.s << K & this.DM, ht;
          for (ht = this.t - 1; ht >= 0; --ht) V.data[ht + lt + 1] = this.data[ht] >> et | bt, bt = (this.data[ht] & dt) << K;
          for (ht = lt - 1; ht >= 0; --ht) V.data[ht] = 0;
          V.data[lt] = bt, V.t = this.t + lt + 1, V.s = this.s, V.clamp();
        }
        function M(O, V) {
          V.s = this.s;
          var K = Math.floor(O / this.DB);
          if (K >= this.t) {
            V.t = 0;
            return;
          }
          var et = O % this.DB, dt = this.DB - et, lt = (1 << et) - 1;
          V.data[0] = this.data[K] >> et;
          for (var bt = K + 1; bt < this.t; ++bt) V.data[bt - K - 1] |= (this.data[bt] & lt) << dt, V.data[bt - K] = this.data[bt] >> et;
          et > 0 && (V.data[this.t - K - 1] |= (this.s & lt) << dt), V.t = this.t - K, V.clamp();
        }
        function Y(O, V) {
          for (var K = 0, et = 0, dt = Math.min(O.t, this.t); K < dt; ) et += this.data[K] - O.data[K], V.data[K++] = et & this.DM, et >>= this.DB;
          if (O.t < this.t) {
            for (et -= O.s; K < this.t; ) et += this.data[K], V.data[K++] = et & this.DM, et >>= this.DB;
            et += this.s;
          } else {
            for (et += this.s; K < O.t; ) et -= O.data[K], V.data[K++] = et & this.DM, et >>= this.DB;
            et -= O.s;
          }
          V.s = et < 0 ? -1 : 0, et < -1 ? V.data[K++] = this.DV + et : et > 0 && (V.data[K++] = et), V.t = K, V.clamp();
        }
        function tt(O, V) {
          var K = this.abs(), et = O.abs(), dt = K.t;
          for (V.t = dt + et.t; --dt >= 0; ) V.data[dt] = 0;
          for (dt = 0; dt < et.t; ++dt) V.data[dt + K.t] = K.am(0, et.data[dt], V, dt, 0, K.t);
          V.s = 0, V.clamp(), this.s != O.s && e.ZERO.subTo(V, V);
        }
        function Z(O) {
          for (var V = this.abs(), K = O.t = 2 * V.t; --K >= 0; ) O.data[K] = 0;
          for (K = 0; K < V.t - 1; ++K) {
            var et = V.am(K, V.data[K], O, 2 * K, 0, 1);
            (O.data[K + V.t] += V.am(K + 1, 2 * V.data[K], O, 2 * K + 1, et, V.t - K - 1)) >= V.DV && (O.data[K + V.t] -= V.DV, O.data[K + V.t + 1] = 1);
          }
          O.t > 0 && (O.data[O.t - 1] += V.am(K, V.data[K], O, 2 * K, 0, 1)), O.s = 0, O.clamp();
        }
        function ot(O, V, K) {
          var et = O.abs();
          if (!(et.t <= 0)) {
            var dt = this.abs();
            if (dt.t < et.t) {
              V == null ? void 0 : V.fromInt(0), K != null && this.copyTo(K);
              return;
            }
            K == null && (K = a());
            var lt = a(), bt = this.s, ht = O.s, Vt = this.DB - g(et.data[et.t - 1]);
            Vt > 0 ? (et.lShiftTo(Vt, lt), dt.lShiftTo(Vt, K)) : (et.copyTo(lt), dt.copyTo(K));
            var xe = lt.t, Me = lt.data[xe - 1];
            if (Me != 0) {
              var ze = Me * (1 << this.F1) + (xe > 1 ? lt.data[xe - 2] >> this.F2 : 0), hr = this.FV / ze, Mn = (1 << this.F1) / ze, Qe = 1 << this.F2, $e = K.t, Kn = $e - xe, Xr = V ?? a();
              for (lt.dlShiftTo(Kn, Xr), K.compareTo(Xr) >= 0 && (K.data[K.t++] = 1, K.subTo(Xr, K)), e.ONE.dlShiftTo(xe, Xr), Xr.subTo(lt, lt); lt.t < xe; ) lt.data[lt.t++] = 0;
              for (; --Kn >= 0; ) {
                var ga = K.data[--$e] == Me ? this.DM : Math.floor(K.data[$e] * hr + (K.data[$e - 1] + Qe) * Mn);
                if ((K.data[$e] += lt.am(0, ga, K, Kn, 0, xe)) < ga) for (lt.dlShiftTo(Kn, Xr), K.subTo(Xr, K); K.data[$e] < --ga; ) K.subTo(Xr, K);
              }
              V != null && (K.drShiftTo(xe, V), bt != ht && e.ZERO.subTo(V, V)), K.t = xe, K.clamp(), Vt > 0 && K.rShiftTo(Vt, K), bt < 0 && e.ZERO.subTo(K, K);
            }
          }
        }
        function ct(O) {
          var V = a();
          return this.abs().divRemTo(O, null, V), this.s < 0 && V.compareTo(e.ZERO) > 0 && O.subTo(V, V), V;
        }
        function pt(O) {
          this.m = O;
        }
        function wt(O) {
          return O.s < 0 || O.compareTo(this.m) >= 0 ? O.mod(this.m) : O;
        }
        function yt(O) {
          return O;
        }
        function St(O) {
          O.divRemTo(this.m, null, O);
        }
        function Bt(O, V, K) {
          O.multiplyTo(V, K), this.reduce(K);
        }
        function Kt(O, V) {
          O.squareTo(V), this.reduce(V);
        }
        pt.prototype.convert = wt, pt.prototype.revert = yt, pt.prototype.reduce = St, pt.prototype.mulTo = Bt, pt.prototype.sqrTo = Kt;
        function rt() {
          if (this.t < 1) return 0;
          var O = this.data[0];
          if ((O & 1) == 0) return 0;
          var V = O & 3;
          return V = V * (2 - (O & 15) * V) & 15, V = V * (2 - (O & 255) * V) & 255, V = V * (2 - ((O & 65535) * V & 65535)) & 65535, V = V * (2 - O * V % this.DV) % this.DV, V > 0 ? this.DV - V : -V;
        }
        function Tt(O) {
          this.m = O, this.mp = O.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << O.DB - 15) - 1, this.mt2 = 2 * O.t;
        }
        function gt(O) {
          var V = a();
          return O.abs().dlShiftTo(this.m.t, V), V.divRemTo(this.m, null, V), O.s < 0 && V.compareTo(e.ZERO) > 0 && this.m.subTo(V, V), V;
        }
        function ae(O) {
          var V = a();
          return O.copyTo(V), this.reduce(V), V;
        }
        function Ct(O) {
          for (; O.t <= this.mt2; ) O.data[O.t++] = 0;
          for (var V = 0; V < this.m.t; ++V) {
            var K = O.data[V] & 32767, et = K * this.mpl + ((K * this.mph + (O.data[V] >> 15) * this.mpl & this.um) << 15) & O.DM;
            for (K = V + this.m.t, O.data[K] += this.m.am(0, et, O, V, 0, this.m.t); O.data[K] >= O.DV; ) O.data[K] -= O.DV, O.data[++K]++;
          }
          O.clamp(), O.drShiftTo(this.m.t, O), O.compareTo(this.m) >= 0 && O.subTo(this.m, O);
        }
        function x(O, V) {
          O.squareTo(V), this.reduce(V);
        }
        function m(O, V, K) {
          O.multiplyTo(V, K), this.reduce(K);
        }
        Tt.prototype.convert = gt, Tt.prototype.revert = ae, Tt.prototype.reduce = Ct, Tt.prototype.mulTo = m, Tt.prototype.sqrTo = x;
        function E() {
          return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
        }
        function f(O, V) {
          if (O > 4294967295 || O < 1) return e.ONE;
          var K = a(), et = a(), dt = V.convert(this), lt = g(O) - 1;
          for (dt.copyTo(K); --lt >= 0; ) if (V.sqrTo(K, et), (O & 1 << lt) > 0) V.mulTo(et, dt, K);
          else {
            var bt = K;
            K = et, et = bt;
          }
          return V.revert(K);
        }
        function I(O, V) {
          var K;
          return O < 256 || V.isEven() ? K = new pt(V) : K = new Tt(V), this.exp(O, K);
        }
        e.prototype.copyTo = C, e.prototype.fromInt = A, e.prototype.fromString = h, e.prototype.clamp = k, e.prototype.dlShiftTo = F, e.prototype.drShiftTo = z, e.prototype.lShiftTo = W, e.prototype.rShiftTo = M, e.prototype.subTo = Y, e.prototype.multiplyTo = tt, e.prototype.squareTo = Z, e.prototype.divRemTo = ot, e.prototype.invDigit = rt, e.prototype.isEven = E, e.prototype.exp = f, e.prototype.toString = S, e.prototype.negate = N, e.prototype.abs = P, e.prototype.compareTo = v, e.prototype.bitLength = u, e.prototype.mod = ct, e.prototype.modPowInt = I, e.ZERO = T(0), e.ONE = T(1);
        function D() {
          var O = a();
          return this.copyTo(O), O;
        }
        function L() {
          if (this.s < 0) {
            if (this.t == 1) return this.data[0] - this.DV;
            if (this.t == 0) return -1;
          } else {
            if (this.t == 1) return this.data[0];
            if (this.t == 0) return 0;
          }
          return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
        }
        function $() {
          return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
        }
        function Q() {
          return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
        }
        function X(O) {
          return Math.floor(Math.LN2 * this.DB / Math.log(O));
        }
        function G() {
          return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1;
        }
        function J(O) {
          if (O == null && (O = 10), this.signum() == 0 || O < 2 || O > 36) return "0";
          var V = this.chunkSize(O), K = Math.pow(O, V), et = T(K), dt = a(), lt = a(), bt = "";
          for (this.divRemTo(et, dt, lt); dt.signum() > 0; ) bt = (K + lt.intValue()).toString(O).substr(1) + bt, dt.divRemTo(et, dt, lt);
          return lt.intValue().toString(O) + bt;
        }
        function at(O, V) {
          this.fromInt(0), V == null && (V = 10);
          for (var K = this.chunkSize(V), et = Math.pow(V, K), dt = false, lt = 0, bt = 0, ht = 0; ht < O.length; ++ht) {
            var Vt = b(O, ht);
            if (Vt < 0) {
              O.charAt(ht) == "-" && this.signum() == 0 && (dt = true);
              continue;
            }
            bt = V * bt + Vt, ++lt >= K && (this.dMultiply(et), this.dAddOffset(bt, 0), lt = 0, bt = 0);
          }
          lt > 0 && (this.dMultiply(Math.pow(V, lt)), this.dAddOffset(bt, 0)), dt && e.ZERO.subTo(this, this);
        }
        function ft(O, V, K) {
          if (typeof V == "number") if (O < 2) this.fromInt(1);
          else for (this.fromNumber(O, K), this.testBit(O - 1) || this.bitwiseTo(e.ONE.shiftLeft(O - 1), Qt, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(V); ) this.dAddOffset(2, 0), this.bitLength() > O && this.subTo(e.ONE.shiftLeft(O - 1), this);
          else {
            var et = new Array(), dt = O & 7;
            et.length = (O >> 3) + 1, V.nextBytes(et), dt > 0 ? et[0] &= (1 << dt) - 1 : et[0] = 0, this.fromString(et, 256);
          }
        }
        function ut() {
          var O = this.t, V = new Array();
          V[0] = this.s;
          var K = this.DB - O * this.DB % 8, et, dt = 0;
          if (O-- > 0) for (K < this.DB && (et = this.data[O] >> K) != (this.s & this.DM) >> K && (V[dt++] = et | this.s << this.DB - K); O >= 0; ) K < 8 ? (et = (this.data[O] & (1 << K) - 1) << 8 - K, et |= this.data[--O] >> (K += this.DB - 8)) : (et = this.data[O] >> (K -= 8) & 255, K <= 0 && (K += this.DB, --O)), (et & 128) != 0 && (et |= -256), dt == 0 && (this.s & 128) != (et & 128) && ++dt, (dt > 0 || et != this.s) && (V[dt++] = et);
          return V;
        }
        function kt(O) {
          return this.compareTo(O) == 0;
        }
        function jt(O) {
          return this.compareTo(O) < 0 ? this : O;
        }
        function Rt(O) {
          return this.compareTo(O) > 0 ? this : O;
        }
        function mt(O, V, K) {
          var et, dt, lt = Math.min(O.t, this.t);
          for (et = 0; et < lt; ++et) K.data[et] = V(this.data[et], O.data[et]);
          if (O.t < this.t) {
            for (dt = O.s & this.DM, et = lt; et < this.t; ++et) K.data[et] = V(this.data[et], dt);
            K.t = this.t;
          } else {
            for (dt = this.s & this.DM, et = lt; et < O.t; ++et) K.data[et] = V(dt, O.data[et]);
            K.t = O.t;
          }
          K.s = V(this.s, O.s), K.clamp();
        }
        function Et(O, V) {
          return O & V;
        }
        function Nt(O) {
          var V = a();
          return this.bitwiseTo(O, Et, V), V;
        }
        function Qt(O, V) {
          return O | V;
        }
        function Zt(O) {
          var V = a();
          return this.bitwiseTo(O, Qt, V), V;
        }
        function te(O, V) {
          return O ^ V;
        }
        function qt(O) {
          var V = a();
          return this.bitwiseTo(O, te, V), V;
        }
        function ee(O, V) {
          return O & ~V;
        }
        function Ht(O) {
          var V = a();
          return this.bitwiseTo(O, ee, V), V;
        }
        function Pt() {
          for (var O = a(), V = 0; V < this.t; ++V) O.data[V] = this.DM & ~this.data[V];
          return O.t = this.t, O.s = ~this.s, O;
        }
        function Ft(O) {
          var V = a();
          return O < 0 ? this.rShiftTo(-O, V) : this.lShiftTo(O, V), V;
        }
        function or(O) {
          var V = a();
          return O < 0 ? this.lShiftTo(-O, V) : this.rShiftTo(O, V), V;
        }
        function wr(O) {
          if (O == 0) return -1;
          var V = 0;
          return (O & 65535) == 0 && (O >>= 16, V += 16), (O & 255) == 0 && (O >>= 8, V += 8), (O & 15) == 0 && (O >>= 4, V += 4), (O & 3) == 0 && (O >>= 2, V += 2), (O & 1) == 0 && ++V, V;
        }
        function Yr() {
          for (var O = 0; O < this.t; ++O) if (this.data[O] != 0) return O * this.DB + wr(this.data[O]);
          return this.s < 0 ? this.t * this.DB : -1;
        }
        function $_(O) {
          for (var V = 0; O != 0; ) O &= O - 1, ++V;
          return V;
        }
        function wn() {
          for (var O = 0, V = this.s & this.DM, K = 0; K < this.t; ++K) O += $_(this.data[K] ^ V);
          return O;
        }
        function Sn(O) {
          var V = Math.floor(O / this.DB);
          return V >= this.t ? this.s != 0 : (this.data[V] & 1 << O % this.DB) != 0;
        }
        function Vn(O, V) {
          var K = e.ONE.shiftLeft(O);
          return this.bitwiseTo(K, V, K), K;
        }
        function ce(O) {
          return this.changeBit(O, Qt);
        }
        function de(O) {
          return this.changeBit(O, ee);
        }
        function le(O) {
          return this.changeBit(O, te);
        }
        function pe(O, V) {
          for (var K = 0, et = 0, dt = Math.min(O.t, this.t); K < dt; ) et += this.data[K] + O.data[K], V.data[K++] = et & this.DM, et >>= this.DB;
          if (O.t < this.t) {
            for (et += O.s; K < this.t; ) et += this.data[K], V.data[K++] = et & this.DM, et >>= this.DB;
            et += this.s;
          } else {
            for (et += this.s; K < O.t; ) et += O.data[K], V.data[K++] = et & this.DM, et >>= this.DB;
            et += O.s;
          }
          V.s = et < 0 ? -1 : 0, et > 0 ? V.data[K++] = et : et < -1 && (V.data[K++] = this.DV + et), V.t = K, V.clamp();
        }
        function ue(O) {
          var V = a();
          return this.addTo(O, V), V;
        }
        function fe(O) {
          var V = a();
          return this.subTo(O, V), V;
        }
        function ge(O) {
          var V = a();
          return this.multiplyTo(O, V), V;
        }
        function we(O) {
          var V = a();
          return this.divRemTo(O, V, null), V;
        }
        function he(O) {
          var V = a();
          return this.divRemTo(O, null, V), V;
        }
        function be(O) {
          var V = a(), K = a();
          return this.divRemTo(O, V, K), new Array(V, K);
        }
        function ye(O) {
          this.data[this.t] = this.am(0, O - 1, this, 0, 0, this.t), ++this.t, this.clamp();
        }
        function ve(O, V) {
          if (O != 0) {
            for (; this.t <= V; ) this.data[this.t++] = 0;
            for (this.data[V] += O; this.data[V] >= this.DV; ) this.data[V] -= this.DV, ++V >= this.t && (this.data[this.t++] = 0), ++this.data[V];
          }
        }
        function Xt() {
        }
        function oe(O) {
          return O;
        }
        function me(O, V, K) {
          O.multiplyTo(V, K);
        }
        function ke(O, V) {
          O.squareTo(V);
        }
        Xt.prototype.convert = oe, Xt.prototype.revert = oe, Xt.prototype.mulTo = me, Xt.prototype.sqrTo = ke;
        function sl(O) {
          return this.exp(O, new Xt());
        }
        function il(O, V, K) {
          var et = Math.min(this.t + O.t, V);
          for (K.s = 0, K.t = et; et > 0; ) K.data[--et] = 0;
          var dt;
          for (dt = K.t - this.t; et < dt; ++et) K.data[et + this.t] = this.am(0, O.data[et], K, et, 0, this.t);
          for (dt = Math.min(O.t, V); et < dt; ++et) this.am(0, O.data[et], K, et, 0, V - et);
          K.clamp();
        }
        function cl(O, V, K) {
          --V;
          var et = K.t = this.t + O.t - V;
          for (K.s = 0; --et >= 0; ) K.data[et] = 0;
          for (et = Math.max(V - this.t, 0); et < O.t; ++et) K.data[this.t + et - V] = this.am(V - et, O.data[et], K, 0, 0, this.t + et - V);
          K.clamp(), K.drShiftTo(1, K);
        }
        function hn(O) {
          this.r2 = a(), this.q3 = a(), e.ONE.dlShiftTo(2 * O.t, this.r2), this.mu = this.r2.divide(O), this.m = O;
        }
        function dl(O) {
          if (O.s < 0 || O.t > 2 * this.m.t) return O.mod(this.m);
          if (O.compareTo(this.m) < 0) return O;
          var V = a();
          return O.copyTo(V), this.reduce(V), V;
        }
        function ll(O) {
          return O;
        }
        function pl(O) {
          for (O.drShiftTo(this.m.t - 1, this.r2), O.t > this.m.t + 1 && (O.t = this.m.t + 1, O.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); O.compareTo(this.r2) < 0; ) O.dAddOffset(1, this.m.t + 1);
          for (O.subTo(this.r2, O); O.compareTo(this.m) >= 0; ) O.subTo(this.m, O);
        }
        function ul(O, V) {
          O.squareTo(V), this.reduce(V);
        }
        function fl(O, V, K) {
          O.multiplyTo(V, K), this.reduce(K);
        }
        hn.prototype.convert = dl, hn.prototype.revert = ll, hn.prototype.reduce = pl, hn.prototype.mulTo = fl, hn.prototype.sqrTo = ul;
        function gl(O, V) {
          var K = O.bitLength(), et, dt = T(1), lt;
          if (K <= 0) return dt;
          K < 18 ? et = 1 : K < 48 ? et = 3 : K < 144 ? et = 4 : K < 768 ? et = 5 : et = 6, K < 8 ? lt = new pt(V) : V.isEven() ? lt = new hn(V) : lt = new Tt(V);
          var bt = new Array(), ht = 3, Vt = et - 1, xe = (1 << et) - 1;
          if (bt[1] = lt.convert(this), et > 1) {
            var Me = a();
            for (lt.sqrTo(bt[1], Me); ht <= xe; ) bt[ht] = a(), lt.mulTo(Me, bt[ht - 2], bt[ht]), ht += 2;
          }
          var ze = O.t - 1, hr, Mn = true, Qe = a(), $e;
          for (K = g(O.data[ze]) - 1; ze >= 0; ) {
            for (K >= Vt ? hr = O.data[ze] >> K - Vt & xe : (hr = (O.data[ze] & (1 << K + 1) - 1) << Vt - K, ze > 0 && (hr |= O.data[ze - 1] >> this.DB + K - Vt)), ht = et; (hr & 1) == 0; ) hr >>= 1, --ht;
            if ((K -= ht) < 0 && (K += this.DB, --ze), Mn) bt[hr].copyTo(dt), Mn = false;
            else {
              for (; ht > 1; ) lt.sqrTo(dt, Qe), lt.sqrTo(Qe, dt), ht -= 2;
              ht > 0 ? lt.sqrTo(dt, Qe) : ($e = dt, dt = Qe, Qe = $e), lt.mulTo(Qe, bt[hr], dt);
            }
            for (; ze >= 0 && (O.data[ze] & 1 << K) == 0; ) lt.sqrTo(dt, Qe), $e = dt, dt = Qe, Qe = $e, --K < 0 && (K = this.DB - 1, --ze);
          }
          return lt.revert(dt);
        }
        function wl(O) {
          var V = this.s < 0 ? this.negate() : this.clone(), K = O.s < 0 ? O.negate() : O.clone();
          if (V.compareTo(K) < 0) {
            var et = V;
            V = K, K = et;
          }
          var dt = V.getLowestSetBit(), lt = K.getLowestSetBit();
          if (lt < 0) return V;
          for (dt < lt && (lt = dt), lt > 0 && (V.rShiftTo(lt, V), K.rShiftTo(lt, K)); V.signum() > 0; ) (dt = V.getLowestSetBit()) > 0 && V.rShiftTo(dt, V), (dt = K.getLowestSetBit()) > 0 && K.rShiftTo(dt, K), V.compareTo(K) >= 0 ? (V.subTo(K, V), V.rShiftTo(1, V)) : (K.subTo(V, K), K.rShiftTo(1, K));
          return lt > 0 && K.lShiftTo(lt, K), K;
        }
        function hl(O) {
          if (O <= 0) return 0;
          var V = this.DV % O, K = this.s < 0 ? O - 1 : 0;
          if (this.t > 0) if (V == 0) K = this.data[0] % O;
          else for (var et = this.t - 1; et >= 0; --et) K = (V * K + this.data[et]) % O;
          return K;
        }
        function bl(O) {
          var V = O.isEven();
          if (this.isEven() && V || O.signum() == 0) return e.ZERO;
          for (var K = O.clone(), et = this.clone(), dt = T(1), lt = T(0), bt = T(0), ht = T(1); K.signum() != 0; ) {
            for (; K.isEven(); ) K.rShiftTo(1, K), V ? ((!dt.isEven() || !lt.isEven()) && (dt.addTo(this, dt), lt.subTo(O, lt)), dt.rShiftTo(1, dt)) : lt.isEven() || lt.subTo(O, lt), lt.rShiftTo(1, lt);
            for (; et.isEven(); ) et.rShiftTo(1, et), V ? ((!bt.isEven() || !ht.isEven()) && (bt.addTo(this, bt), ht.subTo(O, ht)), bt.rShiftTo(1, bt)) : ht.isEven() || ht.subTo(O, ht), ht.rShiftTo(1, ht);
            K.compareTo(et) >= 0 ? (K.subTo(et, K), V && dt.subTo(bt, dt), lt.subTo(ht, lt)) : (et.subTo(K, et), V && bt.subTo(dt, bt), ht.subTo(lt, ht));
          }
          if (et.compareTo(e.ONE) != 0) return e.ZERO;
          if (ht.compareTo(O) >= 0) return ht.subtract(O);
          if (ht.signum() < 0) ht.addTo(O, ht);
          else return ht;
          return ht.signum() < 0 ? ht.add(O) : ht;
        }
        var We = [
          2,
          3,
          5,
          7,
          11,
          13,
          17,
          19,
          23,
          29,
          31,
          37,
          41,
          43,
          47,
          53,
          59,
          61,
          67,
          71,
          73,
          79,
          83,
          89,
          97,
          101,
          103,
          107,
          109,
          113,
          127,
          131,
          137,
          139,
          149,
          151,
          157,
          163,
          167,
          173,
          179,
          181,
          191,
          193,
          197,
          199,
          211,
          223,
          227,
          229,
          233,
          239,
          241,
          251,
          257,
          263,
          269,
          271,
          277,
          281,
          283,
          293,
          307,
          311,
          313,
          317,
          331,
          337,
          347,
          349,
          353,
          359,
          367,
          373,
          379,
          383,
          389,
          397,
          401,
          409,
          419,
          421,
          431,
          433,
          439,
          443,
          449,
          457,
          461,
          463,
          467,
          479,
          487,
          491,
          499,
          503,
          509
        ], yl = (1 << 26) / We[We.length - 1];
        function vl(O) {
          var V, K = this.abs();
          if (K.t == 1 && K.data[0] <= We[We.length - 1]) {
            for (V = 0; V < We.length; ++V) if (K.data[0] == We[V]) return true;
            return false;
          }
          if (K.isEven()) return false;
          for (V = 1; V < We.length; ) {
            for (var et = We[V], dt = V + 1; dt < We.length && et < yl; ) et *= We[dt++];
            for (et = K.modInt(et); V < dt; ) if (et % We[V++] == 0) return false;
          }
          return K.millerRabin(O);
        }
        function ml(O) {
          var V = this.subtract(e.ONE), K = V.getLowestSetBit();
          if (K <= 0) return false;
          for (var et = V.shiftRight(K), dt = kl(), lt, bt = 0; bt < O; ++bt) {
            do
              lt = new e(this.bitLength(), dt);
            while (lt.compareTo(e.ONE) <= 0 || lt.compareTo(V) >= 0);
            var ht = lt.modPow(et, this);
            if (ht.compareTo(e.ONE) != 0 && ht.compareTo(V) != 0) {
              for (var Vt = 1; Vt++ < K && ht.compareTo(V) != 0; ) if (ht = ht.modPowInt(2, this), ht.compareTo(e.ONE) == 0) return false;
              if (ht.compareTo(V) != 0) return false;
            }
          }
          return true;
        }
        function kl() {
          return {
            nextBytes: function(O) {
              for (var V = 0; V < O.length; ++V) O[V] = Math.floor(Math.random() * 256);
            }
          };
        }
        return e.prototype.chunkSize = X, e.prototype.toRadix = J, e.prototype.fromRadix = at, e.prototype.fromNumber = ft, e.prototype.bitwiseTo = mt, e.prototype.changeBit = Vn, e.prototype.addTo = pe, e.prototype.dMultiply = ye, e.prototype.dAddOffset = ve, e.prototype.multiplyLowerTo = il, e.prototype.multiplyUpperTo = cl, e.prototype.modInt = hl, e.prototype.millerRabin = ml, e.prototype.clone = D, e.prototype.intValue = L, e.prototype.byteValue = $, e.prototype.shortValue = Q, e.prototype.signum = G, e.prototype.toByteArray = ut, e.prototype.equals = kt, e.prototype.min = jt, e.prototype.max = Rt, e.prototype.and = Nt, e.prototype.or = Zt, e.prototype.xor = qt, e.prototype.andNot = Ht, e.prototype.not = Pt, e.prototype.shiftLeft = Ft, e.prototype.shiftRight = or, e.prototype.getLowestSetBit = Yr, e.prototype.bitCount = wn, e.prototype.testBit = Sn, e.prototype.setBit = ce, e.prototype.clearBit = de, e.prototype.flipBit = le, e.prototype.add = ue, e.prototype.subtract = fe, e.prototype.multiply = ge, e.prototype.divide = we, e.prototype.remainder = he, e.prototype.divideAndRemainder = be, e.prototype.modPow = gl, e.prototype.modInverse = bl, e.prototype.pow = sl, e.prototype.gcd = wl, e.prototype.isProbablePrime = vl, Pa;
      }
      var Va = {
        exports: {}
      }, Ma = {
        exports: {}
      }, Wc;
      function Pn() {
        if (Wc) return Ma.exports;
        Wc = 1;
        var d = Lt();
        $r(), Ut();
        var t = Ma.exports = d.sha1 = d.sha1 || {};
        d.md.sha1 = d.md.algorithms.sha1 = t, t.create = function() {
          a || n();
          var c = null, s = d.util.createBuffer(), p = new Array(80), l = {
            algorithm: "sha1",
            blockLength: 64,
            digestLength: 20,
            messageLength: 0,
            fullMessageLength: null,
            messageLengthSize: 8
          };
          return l.start = function() {
            l.messageLength = 0, l.fullMessageLength = l.messageLength64 = [];
            for (var y = l.messageLengthSize / 4, R = 0; R < y; ++R) l.fullMessageLength.push(0);
            return s = d.util.createBuffer(), c = {
              h0: 1732584193,
              h1: 4023233417,
              h2: 2562383102,
              h3: 271733878,
              h4: 3285377520
            }, l;
          }, l.start(), l.update = function(y, R) {
            R === "utf8" && (y = d.util.encodeUtf8(y));
            var j = y.length;
            l.messageLength += j, j = [
              j / 4294967296 >>> 0,
              j >>> 0
            ];
            for (var b = l.fullMessageLength.length - 1; b >= 0; --b) l.fullMessageLength[b] += j[1], j[1] = j[0] + (l.fullMessageLength[b] / 4294967296 >>> 0), l.fullMessageLength[b] = l.fullMessageLength[b] >>> 0, j[0] = j[1] / 4294967296 >>> 0;
            return s.putBytes(y), _(c, p, s), (s.read > 2048 || s.length() === 0) && s.compact(), l;
          }, l.digest = function() {
            var y = d.util.createBuffer();
            y.putBytes(s.bytes());
            var R = l.fullMessageLength[l.fullMessageLength.length - 1] + l.messageLengthSize, j = R & l.blockLength - 1;
            y.putBytes(e.substr(0, l.blockLength - j));
            for (var b, C, A = l.fullMessageLength[0] * 8, T = 0; T < l.fullMessageLength.length - 1; ++T) b = l.fullMessageLength[T + 1] * 8, C = b / 4294967296 >>> 0, A += C, y.putInt32(A >>> 0), A = b >>> 0;
            y.putInt32(A);
            var h = {
              h0: c.h0,
              h1: c.h1,
              h2: c.h2,
              h3: c.h3,
              h4: c.h4
            };
            _(h, p, y);
            var k = d.util.createBuffer();
            return k.putInt32(h.h0), k.putInt32(h.h1), k.putInt32(h.h2), k.putInt32(h.h3), k.putInt32(h.h4), k;
          }, l;
        };
        var e = null, a = false;
        function n() {
          e = "\x80", e += d.util.fillString("\0", 64), a = true;
        }
        function _(c, s, p) {
          for (var l, y, R, j, b, C, A, T, h = p.length(); h >= 64; ) {
            for (y = c.h0, R = c.h1, j = c.h2, b = c.h3, C = c.h4, T = 0; T < 16; ++T) l = p.getInt32(), s[T] = l, A = b ^ R & (j ^ b), l = (y << 5 | y >>> 27) + A + C + 1518500249 + l, C = b, b = j, j = (R << 30 | R >>> 2) >>> 0, R = y, y = l;
            for (; T < 20; ++T) l = s[T - 3] ^ s[T - 8] ^ s[T - 14] ^ s[T - 16], l = l << 1 | l >>> 31, s[T] = l, A = b ^ R & (j ^ b), l = (y << 5 | y >>> 27) + A + C + 1518500249 + l, C = b, b = j, j = (R << 30 | R >>> 2) >>> 0, R = y, y = l;
            for (; T < 32; ++T) l = s[T - 3] ^ s[T - 8] ^ s[T - 14] ^ s[T - 16], l = l << 1 | l >>> 31, s[T] = l, A = R ^ j ^ b, l = (y << 5 | y >>> 27) + A + C + 1859775393 + l, C = b, b = j, j = (R << 30 | R >>> 2) >>> 0, R = y, y = l;
            for (; T < 40; ++T) l = s[T - 6] ^ s[T - 16] ^ s[T - 28] ^ s[T - 32], l = l << 2 | l >>> 30, s[T] = l, A = R ^ j ^ b, l = (y << 5 | y >>> 27) + A + C + 1859775393 + l, C = b, b = j, j = (R << 30 | R >>> 2) >>> 0, R = y, y = l;
            for (; T < 60; ++T) l = s[T - 6] ^ s[T - 16] ^ s[T - 28] ^ s[T - 32], l = l << 2 | l >>> 30, s[T] = l, A = R & j | b & (R ^ j), l = (y << 5 | y >>> 27) + A + C + 2400959708 + l, C = b, b = j, j = (R << 30 | R >>> 2) >>> 0, R = y, y = l;
            for (; T < 80; ++T) l = s[T - 6] ^ s[T - 16] ^ s[T - 28] ^ s[T - 32], l = l << 2 | l >>> 30, s[T] = l, A = R ^ j ^ b, l = (y << 5 | y >>> 27) + A + C + 3395469782 + l, C = b, b = j, j = (R << 30 | R >>> 2) >>> 0, R = y, y = l;
            c.h0 = c.h0 + y | 0, c.h1 = c.h1 + R | 0, c.h2 = c.h2 + j | 0, c.h3 = c.h3 + b | 0, c.h4 = c.h4 + C | 0, h -= 64;
          }
        }
        return Ma.exports;
      }
      var Qc;
      function Xd() {
        if (Qc) return Va.exports;
        Qc = 1;
        var d = Lt();
        Ut(), ar(), Pn();
        var t = Va.exports = d.pkcs1 = d.pkcs1 || {};
        t.encode_rsa_oaep = function(a, n, _) {
          var c, s, p, l;
          typeof _ == "string" ? (c = _, s = arguments[3] || void 0, p = arguments[4] || void 0) : _ && (c = _.label || void 0, s = _.seed || void 0, p = _.md || void 0, _.mgf1 && _.mgf1.md && (l = _.mgf1.md)), p ? p.start() : p = d.md.sha1.create(), l || (l = p);
          var y = Math.ceil(a.n.bitLength() / 8), R = y - 2 * p.digestLength - 2;
          if (n.length > R) {
            var j = new Error("RSAES-OAEP input message length is too long.");
            throw j.length = n.length, j.maxLength = R, j;
          }
          c || (c = ""), p.update(c, "raw");
          for (var b = p.digest(), C = "", A = R - n.length, T = 0; T < A; T++) C += "\0";
          var h = b.getBytes() + C + "" + n;
          if (!s) s = d.random.getBytes(p.digestLength);
          else if (s.length !== p.digestLength) {
            var j = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
            throw j.seedLength = s.length, j.digestLength = p.digestLength, j;
          }
          var k = e(s, y - p.digestLength - 1, l), S = d.util.xorBytes(h, k, h.length), N = e(S, p.digestLength, l), P = d.util.xorBytes(s, N, s.length);
          return "\0" + P + S;
        }, t.decode_rsa_oaep = function(a, n, _) {
          var c, s, p;
          typeof _ == "string" ? (c = _, s = arguments[3] || void 0) : _ && (c = _.label || void 0, s = _.md || void 0, _.mgf1 && _.mgf1.md && (p = _.mgf1.md));
          var l = Math.ceil(a.n.bitLength() / 8);
          if (n.length !== l) {
            var S = new Error("RSAES-OAEP encoded message length is invalid.");
            throw S.length = n.length, S.expectedLength = l, S;
          }
          if (s === void 0 ? s = d.md.sha1.create() : s.start(), p || (p = s), l < 2 * s.digestLength + 2) throw new Error("RSAES-OAEP key is too short for the hash function.");
          c || (c = ""), s.update(c, "raw");
          for (var y = s.digest().getBytes(), R = n.charAt(0), j = n.substring(1, s.digestLength + 1), b = n.substring(1 + s.digestLength), C = e(b, s.digestLength, p), A = d.util.xorBytes(j, C, j.length), T = e(A, l - s.digestLength - 1, p), h = d.util.xorBytes(b, T, b.length), k = h.substring(0, s.digestLength), S = R !== "\0", N = 0; N < s.digestLength; ++N) S |= y.charAt(N) !== k.charAt(N);
          for (var P = 1, v = s.digestLength, g = s.digestLength; g < h.length; g++) {
            var u = h.charCodeAt(g), F = u & 1 ^ 1, z = P ? 65534 : 0;
            S |= u & z, P = P & F, v += P;
          }
          if (S || h.charCodeAt(v) !== 1) throw new Error("Invalid RSAES-OAEP padding.");
          return h.substring(v + 1);
        };
        function e(a, n, _) {
          _ || (_ = d.md.sha1.create());
          for (var c = "", s = Math.ceil(n / _.digestLength), p = 0; p < s; ++p) {
            var l = String.fromCharCode(p >> 24 & 255, p >> 16 & 255, p >> 8 & 255, p & 255);
            _.start(), _.update(a + l), c += _.digest().getBytes();
          }
          return c.substring(0, n);
        }
        return Va.exports;
      }
      var Wn = {
        exports: {}
      }, $c;
      function Jd() {
        if ($c) return Wn.exports;
        $c = 1;
        var d = Lt();
        return Ut(), ua(), ar(), (function() {
          if (d.prime) {
            Wn.exports = d.prime;
            return;
          }
          var t = Wn.exports = d.prime = d.prime || {}, e = d.jsbn.BigInteger, a = [
            6,
            4,
            2,
            4,
            2,
            4,
            6,
            2
          ], n = new e(null);
          n.fromInt(30);
          var _ = function(j, b) {
            return j | b;
          };
          t.generateProbablePrime = function(j, b, C) {
            typeof b == "function" && (C = b, b = {}), b = b || {};
            var A = b.algorithm || "PRIMEINC";
            typeof A == "string" && (A = {
              name: A
            }), A.options = A.options || {};
            var T = b.prng || d.random, h = {
              nextBytes: function(k) {
                for (var S = T.getBytesSync(k.length), N = 0; N < k.length; ++N) k[N] = S.charCodeAt(N);
              }
            };
            if (A.name === "PRIMEINC") return c(j, h, A.options, C);
            throw new Error("Invalid prime generation algorithm: " + A.name);
          };
          function c(j, b, C, A) {
            return "workers" in C ? l(j, b, C, A) : s(j, b, C, A);
          }
          function s(j, b, C, A) {
            var T = y(j, b), h = 0, k = R(T.bitLength());
            "millerRabinTests" in C && (k = C.millerRabinTests);
            var S = 10;
            "maxBlockTime" in C && (S = C.maxBlockTime), p(T, j, b, h, k, S, A);
          }
          function p(j, b, C, A, T, h, k) {
            var S = +/* @__PURE__ */ new Date();
            do {
              if (j.bitLength() > b && (j = y(b, C)), j.isProbablePrime(T)) return k(null, j);
              j.dAddOffset(a[A++ % 8], 0);
            } while (h < 0 || +/* @__PURE__ */ new Date() - S < h);
            d.util.setImmediate(function() {
              p(j, b, C, A, T, h, k);
            });
          }
          function l(j, b, C, A) {
            if (typeof Worker > "u") return s(j, b, C, A);
            var T = y(j, b), h = C.workers, k = C.workLoad || 100, S = k * 30 / 8, N = C.workerScript || "forge/prime.worker.js";
            if (h === -1) return d.util.estimateCores(function(v, g) {
              v && (g = 2), h = g - 1, P();
            });
            P();
            function P() {
              h = Math.max(1, h);
              for (var v = [], g = 0; g < h; ++g) v[g] = new Worker(N);
              for (var g = 0; g < h; ++g) v[g].addEventListener("message", F);
              var u = false;
              function F(z) {
                if (!u) {
                  var W = z.data;
                  if (W.found) {
                    for (var M = 0; M < v.length; ++M) v[M].terminate();
                    return u = true, A(null, new e(W.prime, 16));
                  }
                  T.bitLength() > j && (T = y(j, b));
                  var Y = T.toString(16);
                  z.target.postMessage({
                    hex: Y,
                    workLoad: k
                  }), T.dAddOffset(S, 0);
                }
              }
            }
          }
          function y(j, b) {
            var C = new e(j, b), A = j - 1;
            return C.testBit(A) || C.bitwiseTo(e.ONE.shiftLeft(A), _, C), C.dAddOffset(31 - C.mod(n).byteValue(), 0), C;
          }
          function R(j) {
            return j <= 100 ? 27 : j <= 150 ? 18 : j <= 200 ? 15 : j <= 250 ? 12 : j <= 300 ? 9 : j <= 350 ? 8 : j <= 400 ? 7 : j <= 500 ? 6 : j <= 600 ? 5 : j <= 800 ? 4 : j <= 1250 ? 3 : 2;
          }
        })(), Wn.exports;
      }
      var Ka, Yc;
      function fa() {
        if (Yc) return Ka;
        Yc = 1;
        var d = Lt();
        if (gr(), ua(), gn(), Xd(), Jd(), ar(), Ut(), typeof t > "u") var t = d.jsbn.BigInteger;
        var e = d.util.isNodejs ? ko : null, a = d.asn1, n = d.util;
        d.pki = d.pki || {}, Ka = d.pki.rsa = d.rsa = d.rsa || {};
        var _ = d.pki, c = [
          6,
          4,
          2,
          4,
          2,
          4,
          6,
          2
        ], s = {
          name: "PrivateKeyInfo",
          tagClass: a.Class.UNIVERSAL,
          type: a.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "PrivateKeyInfo.version",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.INTEGER,
              constructed: false,
              capture: "privateKeyVersion"
            },
            {
              name: "PrivateKeyInfo.privateKeyAlgorithm",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "AlgorithmIdentifier.algorithm",
                  tagClass: a.Class.UNIVERSAL,
                  type: a.Type.OID,
                  constructed: false,
                  capture: "privateKeyOid"
                }
              ]
            },
            {
              name: "PrivateKeyInfo",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.OCTETSTRING,
              constructed: false,
              capture: "privateKey"
            }
          ]
        }, p = {
          name: "RSAPrivateKey",
          tagClass: a.Class.UNIVERSAL,
          type: a.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "RSAPrivateKey.version",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.INTEGER,
              constructed: false,
              capture: "privateKeyVersion"
            },
            {
              name: "RSAPrivateKey.modulus",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.INTEGER,
              constructed: false,
              capture: "privateKeyModulus"
            },
            {
              name: "RSAPrivateKey.publicExponent",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.INTEGER,
              constructed: false,
              capture: "privateKeyPublicExponent"
            },
            {
              name: "RSAPrivateKey.privateExponent",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.INTEGER,
              constructed: false,
              capture: "privateKeyPrivateExponent"
            },
            {
              name: "RSAPrivateKey.prime1",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.INTEGER,
              constructed: false,
              capture: "privateKeyPrime1"
            },
            {
              name: "RSAPrivateKey.prime2",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.INTEGER,
              constructed: false,
              capture: "privateKeyPrime2"
            },
            {
              name: "RSAPrivateKey.exponent1",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.INTEGER,
              constructed: false,
              capture: "privateKeyExponent1"
            },
            {
              name: "RSAPrivateKey.exponent2",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.INTEGER,
              constructed: false,
              capture: "privateKeyExponent2"
            },
            {
              name: "RSAPrivateKey.coefficient",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.INTEGER,
              constructed: false,
              capture: "privateKeyCoefficient"
            }
          ]
        }, l = {
          name: "RSAPublicKey",
          tagClass: a.Class.UNIVERSAL,
          type: a.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "RSAPublicKey.modulus",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.INTEGER,
              constructed: false,
              capture: "publicKeyModulus"
            },
            {
              name: "RSAPublicKey.exponent",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.INTEGER,
              constructed: false,
              capture: "publicKeyExponent"
            }
          ]
        }, y = d.pki.rsa.publicKeyValidator = {
          name: "SubjectPublicKeyInfo",
          tagClass: a.Class.UNIVERSAL,
          type: a.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "subjectPublicKeyInfo",
          value: [
            {
              name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "AlgorithmIdentifier.algorithm",
                  tagClass: a.Class.UNIVERSAL,
                  type: a.Type.OID,
                  constructed: false,
                  capture: "publicKeyOid"
                }
              ]
            },
            {
              name: "SubjectPublicKeyInfo.subjectPublicKey",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.BITSTRING,
              constructed: false,
              value: [
                {
                  name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
                  tagClass: a.Class.UNIVERSAL,
                  type: a.Type.SEQUENCE,
                  constructed: true,
                  optional: true,
                  captureAsn1: "rsaPublicKey"
                }
              ]
            }
          ]
        }, R = {
          name: "DigestInfo",
          tagClass: a.Class.UNIVERSAL,
          type: a.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "DigestInfo.DigestAlgorithm",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
                  tagClass: a.Class.UNIVERSAL,
                  type: a.Type.OID,
                  constructed: false,
                  capture: "algorithmIdentifier"
                },
                {
                  name: "DigestInfo.DigestAlgorithm.parameters",
                  tagClass: a.Class.UNIVERSAL,
                  type: a.Type.NULL,
                  capture: "parameters",
                  optional: true,
                  constructed: false
                }
              ]
            },
            {
              name: "DigestInfo.digest",
              tagClass: a.Class.UNIVERSAL,
              type: a.Type.OCTETSTRING,
              constructed: false,
              capture: "digest"
            }
          ]
        }, j = function(g) {
          var u;
          if (g.algorithm in _.oids) u = _.oids[g.algorithm];
          else {
            var F = new Error("Unknown message digest algorithm.");
            throw F.algorithm = g.algorithm, F;
          }
          var z = a.oidToDer(u).getBytes(), W = a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, true, []), M = a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, true, []);
          M.value.push(a.create(a.Class.UNIVERSAL, a.Type.OID, false, z)), M.value.push(a.create(a.Class.UNIVERSAL, a.Type.NULL, false, ""));
          var Y = a.create(a.Class.UNIVERSAL, a.Type.OCTETSTRING, false, g.digest().getBytes());
          return W.value.push(M), W.value.push(Y), a.toDer(W).getBytes();
        }, b = function(g, u, F) {
          if (F) return g.modPow(u.e, u.n);
          if (!u.p || !u.q) return g.modPow(u.d, u.n);
          u.dP || (u.dP = u.d.mod(u.p.subtract(t.ONE))), u.dQ || (u.dQ = u.d.mod(u.q.subtract(t.ONE))), u.qInv || (u.qInv = u.q.modInverse(u.p));
          var z;
          do
            z = new t(d.util.bytesToHex(d.random.getBytes(u.n.bitLength() / 8)), 16);
          while (z.compareTo(u.n) >= 0 || !z.gcd(u.n).equals(t.ONE));
          g = g.multiply(z.modPow(u.e, u.n)).mod(u.n);
          for (var W = g.mod(u.p).modPow(u.dP, u.p), M = g.mod(u.q).modPow(u.dQ, u.q); W.compareTo(M) < 0; ) W = W.add(u.p);
          var Y = W.subtract(M).multiply(u.qInv).mod(u.p).multiply(u.q).add(M);
          return Y = Y.multiply(z.modInverse(u.n)).mod(u.n), Y;
        };
        _.rsa.encrypt = function(g, u, F) {
          var z = F, W, M = Math.ceil(u.n.bitLength() / 8);
          F !== false && F !== true ? (z = F === 2, W = C(g, u, F)) : (W = d.util.createBuffer(), W.putBytes(g));
          for (var Y = new t(W.toHex(), 16), tt = b(Y, u, z), Z = tt.toString(16), ot = d.util.createBuffer(), ct = M - Math.ceil(Z.length / 2); ct > 0; ) ot.putByte(0), --ct;
          return ot.putBytes(d.util.hexToBytes(Z)), ot.getBytes();
        }, _.rsa.decrypt = function(g, u, F, z) {
          var W = Math.ceil(u.n.bitLength() / 8);
          if (g.length !== W) {
            var M = new Error("Encrypted message length is invalid.");
            throw M.length = g.length, M.expected = W, M;
          }
          var Y = new t(d.util.createBuffer(g).toHex(), 16);
          if (Y.compareTo(u.n) >= 0) throw new Error("Encrypted message is invalid.");
          for (var tt = b(Y, u, F), Z = tt.toString(16), ot = d.util.createBuffer(), ct = W - Math.ceil(Z.length / 2); ct > 0; ) ot.putByte(0), --ct;
          return ot.putBytes(d.util.hexToBytes(Z)), z !== false ? A(ot.getBytes(), u, F) : ot.getBytes();
        }, _.rsa.createKeyPairGenerationState = function(g, u, F) {
          typeof g == "string" && (g = parseInt(g, 10)), g = g || 2048, F = F || {};
          var z = F.prng || d.random, W = {
            nextBytes: function(tt) {
              for (var Z = z.getBytesSync(tt.length), ot = 0; ot < tt.length; ++ot) tt[ot] = Z.charCodeAt(ot);
            }
          }, M = F.algorithm || "PRIMEINC", Y;
          if (M === "PRIMEINC") Y = {
            algorithm: M,
            state: 0,
            bits: g,
            rng: W,
            eInt: u || 65537,
            e: new t(null),
            p: null,
            q: null,
            qBits: g >> 1,
            pBits: g - (g >> 1),
            pqState: 0,
            num: null,
            keys: null
          }, Y.e.fromInt(Y.eInt);
          else throw new Error("Invalid key generation algorithm: " + M);
          return Y;
        }, _.rsa.stepKeyPairGenerationState = function(g, u) {
          "algorithm" in g || (g.algorithm = "PRIMEINC");
          var F = new t(null);
          F.fromInt(30);
          for (var z = 0, W = function(pt, wt) {
            return pt | wt;
          }, M = +/* @__PURE__ */ new Date(), Y, tt = 0; g.keys === null && (u <= 0 || tt < u); ) {
            if (g.state === 0) {
              var Z = g.p === null ? g.pBits : g.qBits, ot = Z - 1;
              g.pqState === 0 ? (g.num = new t(Z, g.rng), g.num.testBit(ot) || g.num.bitwiseTo(t.ONE.shiftLeft(ot), W, g.num), g.num.dAddOffset(31 - g.num.mod(F).byteValue(), 0), z = 0, ++g.pqState) : g.pqState === 1 ? g.num.bitLength() > Z ? g.pqState = 0 : g.num.isProbablePrime(k(g.num.bitLength())) ? ++g.pqState : g.num.dAddOffset(c[z++ % 8], 0) : g.pqState === 2 ? g.pqState = g.num.subtract(t.ONE).gcd(g.e).compareTo(t.ONE) === 0 ? 3 : 0 : g.pqState === 3 && (g.pqState = 0, g.p === null ? g.p = g.num : g.q = g.num, g.p !== null && g.q !== null && ++g.state, g.num = null);
            } else if (g.state === 1) g.p.compareTo(g.q) < 0 && (g.num = g.p, g.p = g.q, g.q = g.num), ++g.state;
            else if (g.state === 2) g.p1 = g.p.subtract(t.ONE), g.q1 = g.q.subtract(t.ONE), g.phi = g.p1.multiply(g.q1), ++g.state;
            else if (g.state === 3) g.phi.gcd(g.e).compareTo(t.ONE) === 0 ? ++g.state : (g.p = null, g.q = null, g.state = 0);
            else if (g.state === 4) g.n = g.p.multiply(g.q), g.n.bitLength() === g.bits ? ++g.state : (g.q = null, g.state = 0);
            else if (g.state === 5) {
              var ct = g.e.modInverse(g.phi);
              g.keys = {
                privateKey: _.rsa.setPrivateKey(g.n, g.e, ct, g.p, g.q, ct.mod(g.p1), ct.mod(g.q1), g.q.modInverse(g.p)),
                publicKey: _.rsa.setPublicKey(g.n, g.e)
              };
            }
            Y = +/* @__PURE__ */ new Date(), tt += Y - M, M = Y;
          }
          return g.keys !== null;
        }, _.rsa.generateKeyPair = function(g, u, F, z) {
          if (arguments.length === 1 ? typeof g == "object" ? (F = g, g = void 0) : typeof g == "function" && (z = g, g = void 0) : arguments.length === 2 ? typeof g == "number" ? typeof u == "function" ? (z = u, u = void 0) : typeof u != "number" && (F = u, u = void 0) : (F = g, z = u, g = void 0, u = void 0) : arguments.length === 3 && (typeof u == "number" ? typeof F == "function" && (z = F, F = void 0) : (z = F, F = u, u = void 0)), F = F || {}, g === void 0 && (g = F.bits || 2048), u === void 0 && (u = F.e || 65537), !d.options.usePureJavaScript && !F.prng && g >= 256 && g <= 16384 && (u === 65537 || u === 3)) {
            if (z) {
              if (S("generateKeyPair")) return e.generateKeyPair("rsa", {
                modulusLength: g,
                publicExponent: u,
                publicKeyEncoding: {
                  type: "spki",
                  format: "pem"
                },
                privateKeyEncoding: {
                  type: "pkcs8",
                  format: "pem"
                }
              }, function(tt, Z, ot) {
                if (tt) return z(tt);
                z(null, {
                  privateKey: _.privateKeyFromPem(ot),
                  publicKey: _.publicKeyFromPem(Z)
                });
              });
              if (N("generateKey") && N("exportKey")) return n.globalScope.crypto.subtle.generateKey({
                name: "RSASSA-PKCS1-v1_5",
                modulusLength: g,
                publicExponent: v(u),
                hash: {
                  name: "SHA-256"
                }
              }, true, [
                "sign",
                "verify"
              ]).then(function(tt) {
                return n.globalScope.crypto.subtle.exportKey("pkcs8", tt.privateKey);
              }).then(void 0, function(tt) {
                z(tt);
              }).then(function(tt) {
                if (tt) {
                  var Z = _.privateKeyFromAsn1(a.fromDer(d.util.createBuffer(tt)));
                  z(null, {
                    privateKey: Z,
                    publicKey: _.setRsaPublicKey(Z.n, Z.e)
                  });
                }
              });
              if (P("generateKey") && P("exportKey")) {
                var W = n.globalScope.msCrypto.subtle.generateKey({
                  name: "RSASSA-PKCS1-v1_5",
                  modulusLength: g,
                  publicExponent: v(u),
                  hash: {
                    name: "SHA-256"
                  }
                }, true, [
                  "sign",
                  "verify"
                ]);
                W.oncomplete = function(tt) {
                  var Z = tt.target.result, ot = n.globalScope.msCrypto.subtle.exportKey("pkcs8", Z.privateKey);
                  ot.oncomplete = function(ct) {
                    var pt = ct.target.result, wt = _.privateKeyFromAsn1(a.fromDer(d.util.createBuffer(pt)));
                    z(null, {
                      privateKey: wt,
                      publicKey: _.setRsaPublicKey(wt.n, wt.e)
                    });
                  }, ot.onerror = function(ct) {
                    z(ct);
                  };
                }, W.onerror = function(tt) {
                  z(tt);
                };
                return;
              }
            } else if (S("generateKeyPairSync")) {
              var M = e.generateKeyPairSync("rsa", {
                modulusLength: g,
                publicExponent: u,
                publicKeyEncoding: {
                  type: "spki",
                  format: "pem"
                },
                privateKeyEncoding: {
                  type: "pkcs8",
                  format: "pem"
                }
              });
              return {
                privateKey: _.privateKeyFromPem(M.privateKey),
                publicKey: _.publicKeyFromPem(M.publicKey)
              };
            }
          }
          var Y = _.rsa.createKeyPairGenerationState(g, u, F);
          if (!z) return _.rsa.stepKeyPairGenerationState(Y, 0), Y.keys;
          T(Y, F, z);
        }, _.setRsaPublicKey = _.rsa.setPublicKey = function(g, u) {
          var F = {
            n: g,
            e: u
          };
          return F.encrypt = function(z, W, M) {
            if (typeof W == "string" ? W = W.toUpperCase() : W === void 0 && (W = "RSAES-PKCS1-V1_5"), W === "RSAES-PKCS1-V1_5") W = {
              encode: function(tt, Z, ot) {
                return C(tt, Z, 2).getBytes();
              }
            };
            else if (W === "RSA-OAEP" || W === "RSAES-OAEP") W = {
              encode: function(tt, Z) {
                return d.pkcs1.encode_rsa_oaep(Z, tt, M);
              }
            };
            else if ([
              "RAW",
              "NONE",
              "NULL",
              null
            ].indexOf(W) !== -1) W = {
              encode: function(tt) {
                return tt;
              }
            };
            else if (typeof W == "string") throw new Error('Unsupported encryption scheme: "' + W + '".');
            var Y = W.encode(z, F, true);
            return _.rsa.encrypt(Y, F, true);
          }, F.verify = function(z, W, M, Y) {
            typeof M == "string" ? M = M.toUpperCase() : M === void 0 && (M = "RSASSA-PKCS1-V1_5"), Y === void 0 && (Y = {
              _parseAllDigestBytes: true
            }), "_parseAllDigestBytes" in Y || (Y._parseAllDigestBytes = true), M === "RSASSA-PKCS1-V1_5" ? M = {
              verify: function(Z, ot) {
                ot = A(ot, F, true);
                var ct = a.fromDer(ot, {
                  parseAllBytes: Y._parseAllDigestBytes
                }), pt = {}, wt = [];
                if (!a.validate(ct, R, pt, wt)) {
                  var yt = new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.");
                  throw yt.errors = wt, yt;
                }
                var St = a.derToOid(pt.algorithmIdentifier);
                if (!(St === d.oids.md2 || St === d.oids.md5 || St === d.oids.sha1 || St === d.oids.sha224 || St === d.oids.sha256 || St === d.oids.sha384 || St === d.oids.sha512 || St === d.oids["sha512-224"] || St === d.oids["sha512-256"])) {
                  var yt = new Error("Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.");
                  throw yt.oid = St, yt;
                }
                if ((St === d.oids.md2 || St === d.oids.md5) && !("parameters" in pt)) throw new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters.");
                return Z === pt.digest;
              }
            } : (M === "NONE" || M === "NULL" || M === null) && (M = {
              verify: function(Z, ot) {
                return ot = A(ot, F, true), Z === ot;
              }
            });
            var tt = _.rsa.decrypt(W, F, true, false);
            return M.verify(z, tt, F.n.bitLength());
          }, F;
        }, _.setRsaPrivateKey = _.rsa.setPrivateKey = function(g, u, F, z, W, M, Y, tt) {
          var Z = {
            n: g,
            e: u,
            d: F,
            p: z,
            q: W,
            dP: M,
            dQ: Y,
            qInv: tt
          };
          return Z.decrypt = function(ot, ct, pt) {
            typeof ct == "string" ? ct = ct.toUpperCase() : ct === void 0 && (ct = "RSAES-PKCS1-V1_5");
            var wt = _.rsa.decrypt(ot, Z, false, false);
            if (ct === "RSAES-PKCS1-V1_5") ct = {
              decode: A
            };
            else if (ct === "RSA-OAEP" || ct === "RSAES-OAEP") ct = {
              decode: function(yt, St) {
                return d.pkcs1.decode_rsa_oaep(St, yt, pt);
              }
            };
            else if ([
              "RAW",
              "NONE",
              "NULL",
              null
            ].indexOf(ct) !== -1) ct = {
              decode: function(yt) {
                return yt;
              }
            };
            else throw new Error('Unsupported encryption scheme: "' + ct + '".');
            return ct.decode(wt, Z, false);
          }, Z.sign = function(ot, ct) {
            var pt = false;
            typeof ct == "string" && (ct = ct.toUpperCase()), ct === void 0 || ct === "RSASSA-PKCS1-V1_5" ? (ct = {
              encode: j
            }, pt = 1) : (ct === "NONE" || ct === "NULL" || ct === null) && (ct = {
              encode: function() {
                return ot;
              }
            }, pt = 1);
            var wt = ct.encode(ot, Z.n.bitLength());
            return _.rsa.encrypt(wt, Z, pt);
          }, Z;
        }, _.wrapRsaPrivateKey = function(g) {
          return a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, true, [
            a.create(a.Class.UNIVERSAL, a.Type.INTEGER, false, a.integerToDer(0).getBytes()),
            a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, true, [
              a.create(a.Class.UNIVERSAL, a.Type.OID, false, a.oidToDer(_.oids.rsaEncryption).getBytes()),
              a.create(a.Class.UNIVERSAL, a.Type.NULL, false, "")
            ]),
            a.create(a.Class.UNIVERSAL, a.Type.OCTETSTRING, false, a.toDer(g).getBytes())
          ]);
        }, _.privateKeyFromAsn1 = function(g) {
          var u = {}, F = [];
          if (a.validate(g, s, u, F) && (g = a.fromDer(d.util.createBuffer(u.privateKey))), u = {}, F = [], !a.validate(g, p, u, F)) {
            var z = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
            throw z.errors = F, z;
          }
          var W, M, Y, tt, Z, ot, ct, pt;
          return W = d.util.createBuffer(u.privateKeyModulus).toHex(), M = d.util.createBuffer(u.privateKeyPublicExponent).toHex(), Y = d.util.createBuffer(u.privateKeyPrivateExponent).toHex(), tt = d.util.createBuffer(u.privateKeyPrime1).toHex(), Z = d.util.createBuffer(u.privateKeyPrime2).toHex(), ot = d.util.createBuffer(u.privateKeyExponent1).toHex(), ct = d.util.createBuffer(u.privateKeyExponent2).toHex(), pt = d.util.createBuffer(u.privateKeyCoefficient).toHex(), _.setRsaPrivateKey(new t(W, 16), new t(M, 16), new t(Y, 16), new t(tt, 16), new t(Z, 16), new t(ot, 16), new t(ct, 16), new t(pt, 16));
        }, _.privateKeyToAsn1 = _.privateKeyToRSAPrivateKey = function(g) {
          return a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, true, [
            a.create(a.Class.UNIVERSAL, a.Type.INTEGER, false, a.integerToDer(0).getBytes()),
            a.create(a.Class.UNIVERSAL, a.Type.INTEGER, false, h(g.n)),
            a.create(a.Class.UNIVERSAL, a.Type.INTEGER, false, h(g.e)),
            a.create(a.Class.UNIVERSAL, a.Type.INTEGER, false, h(g.d)),
            a.create(a.Class.UNIVERSAL, a.Type.INTEGER, false, h(g.p)),
            a.create(a.Class.UNIVERSAL, a.Type.INTEGER, false, h(g.q)),
            a.create(a.Class.UNIVERSAL, a.Type.INTEGER, false, h(g.dP)),
            a.create(a.Class.UNIVERSAL, a.Type.INTEGER, false, h(g.dQ)),
            a.create(a.Class.UNIVERSAL, a.Type.INTEGER, false, h(g.qInv))
          ]);
        }, _.publicKeyFromAsn1 = function(g) {
          var u = {}, F = [];
          if (a.validate(g, y, u, F)) {
            var z = a.derToOid(u.publicKeyOid);
            if (z !== _.oids.rsaEncryption) {
              var W = new Error("Cannot read public key. Unknown OID.");
              throw W.oid = z, W;
            }
            g = u.rsaPublicKey;
          }
          if (F = [], !a.validate(g, l, u, F)) {
            var W = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
            throw W.errors = F, W;
          }
          var M = d.util.createBuffer(u.publicKeyModulus).toHex(), Y = d.util.createBuffer(u.publicKeyExponent).toHex();
          return _.setRsaPublicKey(new t(M, 16), new t(Y, 16));
        }, _.publicKeyToAsn1 = _.publicKeyToSubjectPublicKeyInfo = function(g) {
          return a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, true, [
            a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, true, [
              a.create(a.Class.UNIVERSAL, a.Type.OID, false, a.oidToDer(_.oids.rsaEncryption).getBytes()),
              a.create(a.Class.UNIVERSAL, a.Type.NULL, false, "")
            ]),
            a.create(a.Class.UNIVERSAL, a.Type.BITSTRING, false, [
              _.publicKeyToRSAPublicKey(g)
            ])
          ]);
        }, _.publicKeyToRSAPublicKey = function(g) {
          return a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, true, [
            a.create(a.Class.UNIVERSAL, a.Type.INTEGER, false, h(g.n)),
            a.create(a.Class.UNIVERSAL, a.Type.INTEGER, false, h(g.e))
          ]);
        };
        function C(g, u, F) {
          var z = d.util.createBuffer(), W = Math.ceil(u.n.bitLength() / 8);
          if (g.length > W - 11) {
            var M = new Error("Message is too long for PKCS#1 v1.5 padding.");
            throw M.length = g.length, M.max = W - 11, M;
          }
          z.putByte(0), z.putByte(F);
          var Y = W - 3 - g.length, tt;
          if (F === 0 || F === 1) {
            tt = F === 0 ? 0 : 255;
            for (var Z = 0; Z < Y; ++Z) z.putByte(tt);
          } else for (; Y > 0; ) {
            for (var ot = 0, ct = d.random.getBytes(Y), Z = 0; Z < Y; ++Z) tt = ct.charCodeAt(Z), tt === 0 ? ++ot : z.putByte(tt);
            Y = ot;
          }
          return z.putByte(0), z.putBytes(g), z;
        }
        function A(g, u, F, z) {
          var W = Math.ceil(u.n.bitLength() / 8), M = d.util.createBuffer(g), Y = M.getByte(), tt = M.getByte();
          if (Y !== 0 || F && tt !== 0 && tt !== 1 || !F && tt != 2 || F && tt === 0 && typeof z > "u") throw new Error("Encryption block is invalid.");
          var Z = 0;
          if (tt === 0) {
            Z = W - 3 - z;
            for (var ot = 0; ot < Z; ++ot) if (M.getByte() !== 0) throw new Error("Encryption block is invalid.");
          } else if (tt === 1) for (Z = 0; M.length() > 1; ) {
            if (M.getByte() !== 255) {
              --M.read;
              break;
            }
            ++Z;
          }
          else if (tt === 2) for (Z = 0; M.length() > 1; ) {
            if (M.getByte() === 0) {
              --M.read;
              break;
            }
            ++Z;
          }
          var ct = M.getByte();
          if (ct !== 0 || Z !== W - 3 - M.length()) throw new Error("Encryption block is invalid.");
          return M.getBytes();
        }
        function T(g, u, F) {
          typeof u == "function" && (F = u, u = {}), u = u || {};
          var z = {
            algorithm: {
              name: u.algorithm || "PRIMEINC",
              options: {
                workers: u.workers || 2,
                workLoad: u.workLoad || 100,
                workerScript: u.workerScript
              }
            }
          };
          "prng" in u && (z.prng = u.prng), W();
          function W() {
            M(g.pBits, function(tt, Z) {
              if (tt) return F(tt);
              if (g.p = Z, g.q !== null) return Y(tt, g.q);
              M(g.qBits, Y);
            });
          }
          function M(tt, Z) {
            d.prime.generateProbablePrime(tt, z, Z);
          }
          function Y(tt, Z) {
            if (tt) return F(tt);
            if (g.q = Z, g.p.compareTo(g.q) < 0) {
              var ot = g.p;
              g.p = g.q, g.q = ot;
            }
            if (g.p.subtract(t.ONE).gcd(g.e).compareTo(t.ONE) !== 0) {
              g.p = null, W();
              return;
            }
            if (g.q.subtract(t.ONE).gcd(g.e).compareTo(t.ONE) !== 0) {
              g.q = null, M(g.qBits, Y);
              return;
            }
            if (g.p1 = g.p.subtract(t.ONE), g.q1 = g.q.subtract(t.ONE), g.phi = g.p1.multiply(g.q1), g.phi.gcd(g.e).compareTo(t.ONE) !== 0) {
              g.p = g.q = null, W();
              return;
            }
            if (g.n = g.p.multiply(g.q), g.n.bitLength() !== g.bits) {
              g.q = null, M(g.qBits, Y);
              return;
            }
            var ct = g.e.modInverse(g.phi);
            g.keys = {
              privateKey: _.rsa.setPrivateKey(g.n, g.e, ct, g.p, g.q, ct.mod(g.p1), ct.mod(g.q1), g.q.modInverse(g.p)),
              publicKey: _.rsa.setPublicKey(g.n, g.e)
            }, F(null, g.keys);
          }
        }
        function h(g) {
          var u = g.toString(16);
          u[0] >= "8" && (u = "00" + u);
          var F = d.util.hexToBytes(u);
          return F.length > 1 && (F.charCodeAt(0) === 0 && (F.charCodeAt(1) & 128) === 0 || F.charCodeAt(0) === 255 && (F.charCodeAt(1) & 128) === 128) ? F.substr(1) : F;
        }
        function k(g) {
          return g <= 100 ? 27 : g <= 150 ? 18 : g <= 200 ? 15 : g <= 250 ? 12 : g <= 300 ? 9 : g <= 350 ? 8 : g <= 400 ? 7 : g <= 500 ? 6 : g <= 600 ? 5 : g <= 800 ? 4 : g <= 1250 ? 3 : 2;
        }
        function S(g) {
          return d.util.isNodejs && typeof e[g] == "function";
        }
        function N(g) {
          return typeof n.globalScope < "u" && typeof n.globalScope.crypto == "object" && typeof n.globalScope.crypto.subtle == "object" && typeof n.globalScope.crypto.subtle[g] == "function";
        }
        function P(g) {
          return typeof n.globalScope < "u" && typeof n.globalScope.msCrypto == "object" && typeof n.globalScope.msCrypto.subtle == "object" && typeof n.globalScope.msCrypto.subtle[g] == "function";
        }
        function v(g) {
          for (var u = d.util.hexToBytes(g.toString(16)), F = new Uint8Array(u.length), z = 0; z < u.length; ++z) F[z] = u.charCodeAt(z);
          return F;
        }
        return Ka;
      }
      var qa, Xc;
      function Zd() {
        if (Xc) return qa;
        Xc = 1;
        var d = Lt();
        if (fn(), gr(), pa(), $r(), gn(), xo(), Cn(), ar(), Yd(), fa(), Ut(), typeof t > "u") var t = d.jsbn.BigInteger;
        var e = d.asn1, a = d.pki = d.pki || {};
        qa = a.pbe = d.pbe = d.pbe || {};
        var n = a.oids, _ = {
          name: "EncryptedPrivateKeyInfo",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
              tagClass: e.Class.UNIVERSAL,
              type: e.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "AlgorithmIdentifier.algorithm",
                  tagClass: e.Class.UNIVERSAL,
                  type: e.Type.OID,
                  constructed: false,
                  capture: "encryptionOid"
                },
                {
                  name: "AlgorithmIdentifier.parameters",
                  tagClass: e.Class.UNIVERSAL,
                  type: e.Type.SEQUENCE,
                  constructed: true,
                  captureAsn1: "encryptionParams"
                }
              ]
            },
            {
              name: "EncryptedPrivateKeyInfo.encryptedData",
              tagClass: e.Class.UNIVERSAL,
              type: e.Type.OCTETSTRING,
              constructed: false,
              capture: "encryptedData"
            }
          ]
        }, c = {
          name: "PBES2Algorithms",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "PBES2Algorithms.keyDerivationFunc",
              tagClass: e.Class.UNIVERSAL,
              type: e.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "PBES2Algorithms.keyDerivationFunc.oid",
                  tagClass: e.Class.UNIVERSAL,
                  type: e.Type.OID,
                  constructed: false,
                  capture: "kdfOid"
                },
                {
                  name: "PBES2Algorithms.params",
                  tagClass: e.Class.UNIVERSAL,
                  type: e.Type.SEQUENCE,
                  constructed: true,
                  value: [
                    {
                      name: "PBES2Algorithms.params.salt",
                      tagClass: e.Class.UNIVERSAL,
                      type: e.Type.OCTETSTRING,
                      constructed: false,
                      capture: "kdfSalt"
                    },
                    {
                      name: "PBES2Algorithms.params.iterationCount",
                      tagClass: e.Class.UNIVERSAL,
                      type: e.Type.INTEGER,
                      constructed: false,
                      capture: "kdfIterationCount"
                    },
                    {
                      name: "PBES2Algorithms.params.keyLength",
                      tagClass: e.Class.UNIVERSAL,
                      type: e.Type.INTEGER,
                      constructed: false,
                      optional: true,
                      capture: "keyLength"
                    },
                    {
                      name: "PBES2Algorithms.params.prf",
                      tagClass: e.Class.UNIVERSAL,
                      type: e.Type.SEQUENCE,
                      constructed: true,
                      optional: true,
                      value: [
                        {
                          name: "PBES2Algorithms.params.prf.algorithm",
                          tagClass: e.Class.UNIVERSAL,
                          type: e.Type.OID,
                          constructed: false,
                          capture: "prfOid"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              name: "PBES2Algorithms.encryptionScheme",
              tagClass: e.Class.UNIVERSAL,
              type: e.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "PBES2Algorithms.encryptionScheme.oid",
                  tagClass: e.Class.UNIVERSAL,
                  type: e.Type.OID,
                  constructed: false,
                  capture: "encOid"
                },
                {
                  name: "PBES2Algorithms.encryptionScheme.iv",
                  tagClass: e.Class.UNIVERSAL,
                  type: e.Type.OCTETSTRING,
                  constructed: false,
                  capture: "encIv"
                }
              ]
            }
          ]
        }, s = {
          name: "pkcs-12PbeParams",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "pkcs-12PbeParams.salt",
              tagClass: e.Class.UNIVERSAL,
              type: e.Type.OCTETSTRING,
              constructed: false,
              capture: "salt"
            },
            {
              name: "pkcs-12PbeParams.iterations",
              tagClass: e.Class.UNIVERSAL,
              type: e.Type.INTEGER,
              constructed: false,
              capture: "iterations"
            }
          ]
        };
        a.encryptPrivateKeyInfo = function(j, b, C) {
          C = C || {}, C.saltSize = C.saltSize || 8, C.count = C.count || 2048, C.algorithm = C.algorithm || "aes128", C.prfAlgorithm = C.prfAlgorithm || "sha1";
          var A = d.random.getBytesSync(C.saltSize), T = C.count, h = e.integerToDer(T), k, S, N;
          if (C.algorithm.indexOf("aes") === 0 || C.algorithm === "des") {
            var P, v, g;
            switch (C.algorithm) {
              case "aes128":
                k = 16, P = 16, v = n["aes128-CBC"], g = d.aes.createEncryptionCipher;
                break;
              case "aes192":
                k = 24, P = 16, v = n["aes192-CBC"], g = d.aes.createEncryptionCipher;
                break;
              case "aes256":
                k = 32, P = 16, v = n["aes256-CBC"], g = d.aes.createEncryptionCipher;
                break;
              case "des":
                k = 8, P = 8, v = n.desCBC, g = d.des.createEncryptionCipher;
                break;
              default:
                var u = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
                throw u.algorithm = C.algorithm, u;
            }
            var F = "hmacWith" + C.prfAlgorithm.toUpperCase(), z = y(F), W = d.pkcs5.pbkdf2(b, A, T, k, z), M = d.random.getBytesSync(P), Y = g(W);
            Y.start(M), Y.update(e.toDer(j)), Y.finish(), N = Y.output.getBytes();
            var tt = R(A, h, k, F);
            S = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, true, [
              e.create(e.Class.UNIVERSAL, e.Type.OID, false, e.oidToDer(n.pkcs5PBES2).getBytes()),
              e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, true, [
                e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, true, [
                  e.create(e.Class.UNIVERSAL, e.Type.OID, false, e.oidToDer(n.pkcs5PBKDF2).getBytes()),
                  tt
                ]),
                e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, true, [
                  e.create(e.Class.UNIVERSAL, e.Type.OID, false, e.oidToDer(v).getBytes()),
                  e.create(e.Class.UNIVERSAL, e.Type.OCTETSTRING, false, M)
                ])
              ])
            ]);
          } else if (C.algorithm === "3des") {
            k = 24;
            var Z = new d.util.ByteBuffer(A), W = a.pbe.generatePkcs12Key(b, Z, 1, T, k), M = a.pbe.generatePkcs12Key(b, Z, 2, T, k), Y = d.des.createEncryptionCipher(W);
            Y.start(M), Y.update(e.toDer(j)), Y.finish(), N = Y.output.getBytes(), S = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, true, [
              e.create(e.Class.UNIVERSAL, e.Type.OID, false, e.oidToDer(n["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),
              e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, true, [
                e.create(e.Class.UNIVERSAL, e.Type.OCTETSTRING, false, A),
                e.create(e.Class.UNIVERSAL, e.Type.INTEGER, false, h.getBytes())
              ])
            ]);
          } else {
            var u = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            throw u.algorithm = C.algorithm, u;
          }
          var ot = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, true, [
            S,
            e.create(e.Class.UNIVERSAL, e.Type.OCTETSTRING, false, N)
          ]);
          return ot;
        }, a.decryptPrivateKeyInfo = function(j, b) {
          var C = null, A = {}, T = [];
          if (!e.validate(j, _, A, T)) {
            var h = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
            throw h.errors = T, h;
          }
          var k = e.derToOid(A.encryptionOid), S = a.pbe.getCipher(k, A.encryptionParams, b), N = d.util.createBuffer(A.encryptedData);
          return S.update(N), S.finish() && (C = e.fromDer(S.output)), C;
        }, a.encryptedPrivateKeyToPem = function(j, b) {
          var C = {
            type: "ENCRYPTED PRIVATE KEY",
            body: e.toDer(j).getBytes()
          };
          return d.pem.encode(C, {
            maxline: b
          });
        }, a.encryptedPrivateKeyFromPem = function(j) {
          var b = d.pem.decode(j)[0];
          if (b.type !== "ENCRYPTED PRIVATE KEY") {
            var C = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
            throw C.headerType = b.type, C;
          }
          if (b.procType && b.procType.type === "ENCRYPTED") throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
          return e.fromDer(b.body);
        }, a.encryptRsaPrivateKey = function(j, b, C) {
          if (C = C || {}, !C.legacy) {
            var A = a.wrapRsaPrivateKey(a.privateKeyToAsn1(j));
            return A = a.encryptPrivateKeyInfo(A, b, C), a.encryptedPrivateKeyToPem(A);
          }
          var T, h, k, S;
          switch (C.algorithm) {
            case "aes128":
              T = "AES-128-CBC", k = 16, h = d.random.getBytesSync(16), S = d.aes.createEncryptionCipher;
              break;
            case "aes192":
              T = "AES-192-CBC", k = 24, h = d.random.getBytesSync(16), S = d.aes.createEncryptionCipher;
              break;
            case "aes256":
              T = "AES-256-CBC", k = 32, h = d.random.getBytesSync(16), S = d.aes.createEncryptionCipher;
              break;
            case "3des":
              T = "DES-EDE3-CBC", k = 24, h = d.random.getBytesSync(8), S = d.des.createEncryptionCipher;
              break;
            case "des":
              T = "DES-CBC", k = 8, h = d.random.getBytesSync(8), S = d.des.createEncryptionCipher;
              break;
            default:
              var N = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + C.algorithm + '".');
              throw N.algorithm = C.algorithm, N;
          }
          var P = d.pbe.opensslDeriveBytes(b, h.substr(0, 8), k), v = S(P);
          v.start(h), v.update(e.toDer(a.privateKeyToAsn1(j))), v.finish();
          var g = {
            type: "RSA PRIVATE KEY",
            procType: {
              version: "4",
              type: "ENCRYPTED"
            },
            dekInfo: {
              algorithm: T,
              parameters: d.util.bytesToHex(h).toUpperCase()
            },
            body: v.output.getBytes()
          };
          return d.pem.encode(g);
        }, a.decryptRsaPrivateKey = function(j, b) {
          var C = null, A = d.pem.decode(j)[0];
          if (A.type !== "ENCRYPTED PRIVATE KEY" && A.type !== "PRIVATE KEY" && A.type !== "RSA PRIVATE KEY") {
            var T = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
            throw T.headerType = T, T;
          }
          if (A.procType && A.procType.type === "ENCRYPTED") {
            var h, k;
            switch (A.dekInfo.algorithm) {
              case "DES-CBC":
                h = 8, k = d.des.createDecryptionCipher;
                break;
              case "DES-EDE3-CBC":
                h = 24, k = d.des.createDecryptionCipher;
                break;
              case "AES-128-CBC":
                h = 16, k = d.aes.createDecryptionCipher;
                break;
              case "AES-192-CBC":
                h = 24, k = d.aes.createDecryptionCipher;
                break;
              case "AES-256-CBC":
                h = 32, k = d.aes.createDecryptionCipher;
                break;
              case "RC2-40-CBC":
                h = 5, k = function(g) {
                  return d.rc2.createDecryptionCipher(g, 40);
                };
                break;
              case "RC2-64-CBC":
                h = 8, k = function(g) {
                  return d.rc2.createDecryptionCipher(g, 64);
                };
                break;
              case "RC2-128-CBC":
                h = 16, k = function(g) {
                  return d.rc2.createDecryptionCipher(g, 128);
                };
                break;
              default:
                var T = new Error('Could not decrypt private key; unsupported encryption algorithm "' + A.dekInfo.algorithm + '".');
                throw T.algorithm = A.dekInfo.algorithm, T;
            }
            var S = d.util.hexToBytes(A.dekInfo.parameters), N = d.pbe.opensslDeriveBytes(b, S.substr(0, 8), h), P = k(N);
            if (P.start(S), P.update(d.util.createBuffer(A.body)), P.finish()) C = P.output.getBytes();
            else return C;
          } else C = A.body;
          return A.type === "ENCRYPTED PRIVATE KEY" ? C = a.decryptPrivateKeyInfo(e.fromDer(C), b) : C = e.fromDer(C), C !== null && (C = a.privateKeyFromAsn1(C)), C;
        }, a.pbe.generatePkcs12Key = function(j, b, C, A, T, h) {
          var k, S;
          if (typeof h > "u" || h === null) {
            if (!("sha1" in d.md)) throw new Error('"sha1" hash algorithm unavailable.');
            h = d.md.sha1.create();
          }
          var N = h.digestLength, P = h.blockLength, v = new d.util.ByteBuffer(), g = new d.util.ByteBuffer();
          if (j != null) {
            for (S = 0; S < j.length; S++) g.putInt16(j.charCodeAt(S));
            g.putInt16(0);
          }
          var u = g.length(), F = b.length(), z = new d.util.ByteBuffer();
          z.fillWithByte(C, P);
          var W = P * Math.ceil(F / P), M = new d.util.ByteBuffer();
          for (S = 0; S < W; S++) M.putByte(b.at(S % F));
          var Y = P * Math.ceil(u / P), tt = new d.util.ByteBuffer();
          for (S = 0; S < Y; S++) tt.putByte(g.at(S % u));
          var Z = M;
          Z.putBuffer(tt);
          for (var ot = Math.ceil(T / N), ct = 1; ct <= ot; ct++) {
            var pt = new d.util.ByteBuffer();
            pt.putBytes(z.bytes()), pt.putBytes(Z.bytes());
            for (var wt = 0; wt < A; wt++) h.start(), h.update(pt.getBytes()), pt = h.digest();
            var yt = new d.util.ByteBuffer();
            for (S = 0; S < P; S++) yt.putByte(pt.at(S % N));
            var St = Math.ceil(F / P) + Math.ceil(u / P), Bt = new d.util.ByteBuffer();
            for (k = 0; k < St; k++) {
              var Kt = new d.util.ByteBuffer(Z.getBytes(P)), rt = 511;
              for (S = yt.length() - 1; S >= 0; S--) rt = rt >> 8, rt += yt.at(S) + Kt.at(S), Kt.setAt(S, rt & 255);
              Bt.putBuffer(Kt);
            }
            Z = Bt, v.putBuffer(pt);
          }
          return v.truncate(v.length() - T), v;
        }, a.pbe.getCipher = function(j, b, C) {
          switch (j) {
            case a.oids.pkcs5PBES2:
              return a.pbe.getCipherForPBES2(j, b, C);
            case a.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
            case a.oids["pbewithSHAAnd40BitRC2-CBC"]:
              return a.pbe.getCipherForPKCS12PBE(j, b, C);
            default:
              var A = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
              throw A.oid = j, A.supportedOids = [
                "pkcs5PBES2",
                "pbeWithSHAAnd3-KeyTripleDES-CBC",
                "pbewithSHAAnd40BitRC2-CBC"
              ], A;
          }
        }, a.pbe.getCipherForPBES2 = function(j, b, C) {
          var A = {}, T = [];
          if (!e.validate(b, c, A, T)) {
            var h = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
            throw h.errors = T, h;
          }
          if (j = e.derToOid(A.kdfOid), j !== a.oids.pkcs5PBKDF2) {
            var h = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
            throw h.oid = j, h.supportedOids = [
              "pkcs5PBKDF2"
            ], h;
          }
          if (j = e.derToOid(A.encOid), j !== a.oids["aes128-CBC"] && j !== a.oids["aes192-CBC"] && j !== a.oids["aes256-CBC"] && j !== a.oids["des-EDE3-CBC"] && j !== a.oids.desCBC) {
            var h = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
            throw h.oid = j, h.supportedOids = [
              "aes128-CBC",
              "aes192-CBC",
              "aes256-CBC",
              "des-EDE3-CBC",
              "desCBC"
            ], h;
          }
          var k = A.kdfSalt, S = d.util.createBuffer(A.kdfIterationCount);
          S = S.getInt(S.length() << 3);
          var N, P;
          switch (a.oids[j]) {
            case "aes128-CBC":
              N = 16, P = d.aes.createDecryptionCipher;
              break;
            case "aes192-CBC":
              N = 24, P = d.aes.createDecryptionCipher;
              break;
            case "aes256-CBC":
              N = 32, P = d.aes.createDecryptionCipher;
              break;
            case "des-EDE3-CBC":
              N = 24, P = d.des.createDecryptionCipher;
              break;
            case "desCBC":
              N = 8, P = d.des.createDecryptionCipher;
              break;
          }
          var v = l(A.prfOid), g = d.pkcs5.pbkdf2(C, k, S, N, v), u = A.encIv, F = P(g);
          return F.start(u), F;
        }, a.pbe.getCipherForPKCS12PBE = function(j, b, C) {
          var A = {}, T = [];
          if (!e.validate(b, s, A, T)) {
            var h = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
            throw h.errors = T, h;
          }
          var k = d.util.createBuffer(A.salt), S = d.util.createBuffer(A.iterations);
          S = S.getInt(S.length() << 3);
          var N, P, v;
          switch (j) {
            case a.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
              N = 24, P = 8, v = d.des.startDecrypting;
              break;
            case a.oids["pbewithSHAAnd40BitRC2-CBC"]:
              N = 5, P = 8, v = function(W, M) {
                var Y = d.rc2.createDecryptionCipher(W, 40);
                return Y.start(M, null), Y;
              };
              break;
            default:
              var h = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
              throw h.oid = j, h;
          }
          var g = l(A.prfOid), u = a.pbe.generatePkcs12Key(C, k, 1, S, N, g);
          g.start();
          var F = a.pbe.generatePkcs12Key(C, k, 2, S, P, g);
          return v(u, F);
        }, a.pbe.opensslDeriveBytes = function(j, b, C, A) {
          if (typeof A > "u" || A === null) {
            if (!("md5" in d.md)) throw new Error('"md5" hash algorithm unavailable.');
            A = d.md.md5.create();
          }
          b === null && (b = "");
          for (var T = [
            p(A, j + b)
          ], h = 16, k = 1; h < C; ++k, h += 16) T.push(p(A, T[k - 1] + j + b));
          return T.join("").substr(0, C);
        };
        function p(j, b) {
          return j.start().update(b).digest().getBytes();
        }
        function l(j) {
          var b;
          if (!j) b = "hmacWithSHA1";
          else if (b = a.oids[e.derToOid(j)], !b) {
            var C = new Error("Unsupported PRF OID.");
            throw C.oid = j, C.supported = [
              "hmacWithSHA1",
              "hmacWithSHA224",
              "hmacWithSHA256",
              "hmacWithSHA384",
              "hmacWithSHA512"
            ], C;
          }
          return y(b);
        }
        function y(j) {
          var b = d.md;
          switch (j) {
            case "hmacWithSHA224":
              b = d.md.sha512;
            case "hmacWithSHA1":
            case "hmacWithSHA256":
            case "hmacWithSHA384":
            case "hmacWithSHA512":
              j = j.substr(8).toLowerCase();
              break;
            default:
              var C = new Error("Unsupported PRF algorithm.");
              throw C.algorithm = j, C.supported = [
                "hmacWithSHA1",
                "hmacWithSHA224",
                "hmacWithSHA256",
                "hmacWithSHA384",
                "hmacWithSHA512"
              ], C;
          }
          if (!b || !(j in b)) throw new Error("Unknown hash algorithm: " + j);
          return b[j].create();
        }
        function R(j, b, C, A) {
          var T = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, true, [
            e.create(e.Class.UNIVERSAL, e.Type.OCTETSTRING, false, j),
            e.create(e.Class.UNIVERSAL, e.Type.INTEGER, false, b.getBytes())
          ]);
          return A !== "hmacWithSHA1" && T.value.push(e.create(e.Class.UNIVERSAL, e.Type.INTEGER, false, d.util.hexToBytes(C.toString(16))), e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, true, [
            e.create(e.Class.UNIVERSAL, e.Type.OID, false, e.oidToDer(a.oids[A]).getBytes()),
            e.create(e.Class.UNIVERSAL, e.Type.NULL, false, "")
          ])), T;
        }
        return qa;
      }
      var Ha = {
        exports: {}
      }, Ga = {
        exports: {}
      }, Jc;
      function tl() {
        if (Jc) return Ga.exports;
        Jc = 1;
        var d = Lt();
        gr(), Ut();
        var t = d.asn1, e = Ga.exports = d.pkcs7asn1 = d.pkcs7asn1 || {};
        d.pkcs7 = d.pkcs7 || {}, d.pkcs7.asn1 = e;
        var a = {
          name: "ContentInfo",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "ContentInfo.ContentType",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.OID,
              constructed: false,
              capture: "contentType"
            },
            {
              name: "ContentInfo.content",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: true,
              optional: true,
              captureAsn1: "content"
            }
          ]
        };
        e.contentInfoValidator = a;
        var n = {
          name: "EncryptedContentInfo",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "EncryptedContentInfo.contentType",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.OID,
              constructed: false,
              capture: "contentType"
            },
            {
              name: "EncryptedContentInfo.contentEncryptionAlgorithm",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.OID,
                  constructed: false,
                  capture: "encAlgorithm"
                },
                {
                  name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
                  tagClass: t.Class.UNIVERSAL,
                  captureAsn1: "encParameter"
                }
              ]
            },
            {
              name: "EncryptedContentInfo.encryptedContent",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              type: 0,
              capture: "encryptedContent",
              captureAsn1: "encryptedContentAsn1"
            }
          ]
        };
        e.envelopedDataValidator = {
          name: "EnvelopedData",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "EnvelopedData.Version",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.INTEGER,
              constructed: false,
              capture: "version"
            },
            {
              name: "EnvelopedData.RecipientInfos",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SET,
              constructed: true,
              captureAsn1: "recipientInfos"
            }
          ].concat(n)
        }, e.encryptedDataValidator = {
          name: "EncryptedData",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "EncryptedData.Version",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.INTEGER,
              constructed: false,
              capture: "version"
            }
          ].concat(n)
        };
        var _ = {
          name: "SignerInfo",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "SignerInfo.version",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.INTEGER,
              constructed: false
            },
            {
              name: "SignerInfo.issuerAndSerialNumber",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "SignerInfo.issuerAndSerialNumber.issuer",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: true,
                  captureAsn1: "issuer"
                },
                {
                  name: "SignerInfo.issuerAndSerialNumber.serialNumber",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.INTEGER,
                  constructed: false,
                  capture: "serial"
                }
              ]
            },
            {
              name: "SignerInfo.digestAlgorithm",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "SignerInfo.digestAlgorithm.algorithm",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.OID,
                  constructed: false,
                  capture: "digestAlgorithm"
                },
                {
                  name: "SignerInfo.digestAlgorithm.parameter",
                  tagClass: t.Class.UNIVERSAL,
                  constructed: false,
                  captureAsn1: "digestParameter",
                  optional: true
                }
              ]
            },
            {
              name: "SignerInfo.authenticatedAttributes",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: true,
              optional: true,
              capture: "authenticatedAttributes"
            },
            {
              name: "SignerInfo.digestEncryptionAlgorithm",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: true,
              capture: "signatureAlgorithm"
            },
            {
              name: "SignerInfo.encryptedDigest",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.OCTETSTRING,
              constructed: false,
              capture: "signature"
            },
            {
              name: "SignerInfo.unauthenticatedAttributes",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              type: 1,
              constructed: true,
              optional: true,
              capture: "unauthenticatedAttributes"
            }
          ]
        };
        return e.signedDataValidator = {
          name: "SignedData",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "SignedData.Version",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.INTEGER,
              constructed: false,
              capture: "version"
            },
            {
              name: "SignedData.DigestAlgorithms",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SET,
              constructed: true,
              captureAsn1: "digestAlgorithms"
            },
            a,
            {
              name: "SignedData.Certificates",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              type: 0,
              optional: true,
              captureAsn1: "certificates"
            },
            {
              name: "SignedData.CertificateRevocationLists",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              type: 1,
              optional: true,
              captureAsn1: "crls"
            },
            {
              name: "SignedData.SignerInfos",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SET,
              capture: "signerInfos",
              optional: true,
              value: [
                _
              ]
            }
          ]
        }, e.recipientInfoValidator = {
          name: "RecipientInfo",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "RecipientInfo.version",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.INTEGER,
              constructed: false,
              capture: "version"
            },
            {
              name: "RecipientInfo.issuerAndSerial",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "RecipientInfo.issuerAndSerial.issuer",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: true,
                  captureAsn1: "issuer"
                },
                {
                  name: "RecipientInfo.issuerAndSerial.serialNumber",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.INTEGER,
                  constructed: false,
                  capture: "serial"
                }
              ]
            },
            {
              name: "RecipientInfo.keyEncryptionAlgorithm",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.OID,
                  constructed: false,
                  capture: "encAlgorithm"
                },
                {
                  name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
                  tagClass: t.Class.UNIVERSAL,
                  constructed: false,
                  captureAsn1: "encParameter",
                  optional: true
                }
              ]
            },
            {
              name: "RecipientInfo.encryptedKey",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.OCTETSTRING,
              constructed: false,
              capture: "encKey"
            }
          ]
        }, Ga.exports;
      }
      var Wa = {
        exports: {}
      }, Qa = {
        exports: {}
      }, Zc;
      function el() {
        if (Zc) return Qa.exports;
        Zc = 1;
        var d = Lt();
        Ut(), d.mgf = d.mgf || {};
        var t = Qa.exports = d.mgf.mgf1 = d.mgf1 = d.mgf1 || {};
        return t.create = function(e) {
          var a = {
            generate: function(n, _) {
              for (var c = new d.util.ByteBuffer(), s = Math.ceil(_ / e.digestLength), p = 0; p < s; p++) {
                var l = new d.util.ByteBuffer();
                l.putInt32(p), e.start(), e.update(n + l.getBytes()), c.putBuffer(e.digest());
              }
              return c.truncate(c.length() - _), c.getBytes();
            }
          };
          return a;
        }, Qa.exports;
      }
      var $a, td;
      function u$() {
        if (td) return $a;
        td = 1;
        var d = Lt();
        return el(), $a = d.mgf = d.mgf || {}, d.mgf.mgf1 = d.mgf1, $a;
      }
      var Ya = {
        exports: {}
      }, ed;
      function Eo() {
        if (ed) return Ya.exports;
        ed = 1;
        var d = Lt();
        ar(), Ut();
        var t = Ya.exports = d.pss = d.pss || {};
        return t.create = function(e) {
          arguments.length === 3 && (e = {
            md: arguments[0],
            mgf: arguments[1],
            saltLength: arguments[2]
          });
          var a = e.md, n = e.mgf, _ = a.digestLength, c = e.salt || null;
          typeof c == "string" && (c = d.util.createBuffer(c));
          var s;
          if ("saltLength" in e) s = e.saltLength;
          else if (c !== null) s = c.length();
          else throw new Error("Salt length not specified or specific salt not given.");
          if (c !== null && c.length() !== s) throw new Error("Given salt length does not match length of given salt.");
          var p = e.prng || d.random, l = {};
          return l.encode = function(y, R) {
            var j, b = R - 1, C = Math.ceil(b / 8), A = y.digest().getBytes();
            if (C < _ + s + 2) throw new Error("Message is too long to encrypt.");
            var T;
            c === null ? T = p.getBytesSync(s) : T = c.bytes();
            var h = new d.util.ByteBuffer();
            h.fillWithByte(0, 8), h.putBytes(A), h.putBytes(T), a.start(), a.update(h.getBytes());
            var k = a.digest().getBytes(), S = new d.util.ByteBuffer();
            S.fillWithByte(0, C - s - _ - 2), S.putByte(1), S.putBytes(T);
            var N = S.getBytes(), P = C - _ - 1, v = n.generate(k, P), g = "";
            for (j = 0; j < P; j++) g += String.fromCharCode(N.charCodeAt(j) ^ v.charCodeAt(j));
            var u = 65280 >> 8 * C - b & 255;
            return g = String.fromCharCode(g.charCodeAt(0) & ~u) + g.substr(1), g + k + "\xBC";
          }, l.verify = function(y, R, j) {
            var b, C = j - 1, A = Math.ceil(C / 8);
            if (R = R.substr(-A), A < _ + s + 2) throw new Error("Inconsistent parameters to PSS signature verification.");
            if (R.charCodeAt(A - 1) !== 188) throw new Error("Encoded message does not end in 0xBC.");
            var T = A - _ - 1, h = R.substr(0, T), k = R.substr(T, _), S = 65280 >> 8 * A - C & 255;
            if ((h.charCodeAt(0) & S) !== 0) throw new Error("Bits beyond keysize not zero as expected.");
            var N = n.generate(k, T), P = "";
            for (b = 0; b < T; b++) P += String.fromCharCode(h.charCodeAt(b) ^ N.charCodeAt(b));
            P = String.fromCharCode(P.charCodeAt(0) & ~S) + P.substr(1);
            var v = A - _ - s - 2;
            for (b = 0; b < v; b++) if (P.charCodeAt(b) !== 0) throw new Error("Leftmost octets not zero as expected");
            if (P.charCodeAt(v) !== 1) throw new Error("Inconsistent PSS signature, 0x01 marker not found");
            var g = P.substr(-s), u = new d.util.ByteBuffer();
            u.fillWithByte(0, 8), u.putBytes(y), u.putBytes(g), a.start(), a.update(u.getBytes());
            var F = a.digest().getBytes();
            return k === F;
          }, l;
        }, Ya.exports;
      }
      var rd;
      function Co() {
        if (rd) return Wa.exports;
        rd = 1;
        var d = Lt();
        fn(), gr(), pa(), $r(), u$(), gn(), Cn(), Eo(), fa(), Ut();
        var t = d.asn1, e = Wa.exports = d.pki = d.pki || {}, a = e.oids, n = {};
        n.CN = a.commonName, n.commonName = "CN", n.C = a.countryName, n.countryName = "C", n.L = a.localityName, n.localityName = "L", n.ST = a.stateOrProvinceName, n.stateOrProvinceName = "ST", n.O = a.organizationName, n.organizationName = "O", n.OU = a.organizationalUnitName, n.organizationalUnitName = "OU", n.E = a.emailAddress, n.emailAddress = "E";
        var _ = d.pki.rsa.publicKeyValidator, c = {
          name: "Certificate",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "Certificate.TBSCertificate",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "tbsCertificate",
              value: [
                {
                  name: "Certificate.TBSCertificate.version",
                  tagClass: t.Class.CONTEXT_SPECIFIC,
                  type: 0,
                  constructed: true,
                  optional: true,
                  value: [
                    {
                      name: "Certificate.TBSCertificate.version.integer",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.INTEGER,
                      constructed: false,
                      capture: "certVersion"
                    }
                  ]
                },
                {
                  name: "Certificate.TBSCertificate.serialNumber",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.INTEGER,
                  constructed: false,
                  capture: "certSerialNumber"
                },
                {
                  name: "Certificate.TBSCertificate.signature",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: true,
                  value: [
                    {
                      name: "Certificate.TBSCertificate.signature.algorithm",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.OID,
                      constructed: false,
                      capture: "certinfoSignatureOid"
                    },
                    {
                      name: "Certificate.TBSCertificate.signature.parameters",
                      tagClass: t.Class.UNIVERSAL,
                      optional: true,
                      captureAsn1: "certinfoSignatureParams"
                    }
                  ]
                },
                {
                  name: "Certificate.TBSCertificate.issuer",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: true,
                  captureAsn1: "certIssuer"
                },
                {
                  name: "Certificate.TBSCertificate.validity",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: true,
                  value: [
                    {
                      name: "Certificate.TBSCertificate.validity.notBefore (utc)",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.UTCTIME,
                      constructed: false,
                      optional: true,
                      capture: "certValidity1UTCTime"
                    },
                    {
                      name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.GENERALIZEDTIME,
                      constructed: false,
                      optional: true,
                      capture: "certValidity2GeneralizedTime"
                    },
                    {
                      name: "Certificate.TBSCertificate.validity.notAfter (utc)",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.UTCTIME,
                      constructed: false,
                      optional: true,
                      capture: "certValidity3UTCTime"
                    },
                    {
                      name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.GENERALIZEDTIME,
                      constructed: false,
                      optional: true,
                      capture: "certValidity4GeneralizedTime"
                    }
                  ]
                },
                {
                  name: "Certificate.TBSCertificate.subject",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: true,
                  captureAsn1: "certSubject"
                },
                _,
                {
                  name: "Certificate.TBSCertificate.issuerUniqueID",
                  tagClass: t.Class.CONTEXT_SPECIFIC,
                  type: 1,
                  constructed: true,
                  optional: true,
                  value: [
                    {
                      name: "Certificate.TBSCertificate.issuerUniqueID.id",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.BITSTRING,
                      constructed: false,
                      captureBitStringValue: "certIssuerUniqueId"
                    }
                  ]
                },
                {
                  name: "Certificate.TBSCertificate.subjectUniqueID",
                  tagClass: t.Class.CONTEXT_SPECIFIC,
                  type: 2,
                  constructed: true,
                  optional: true,
                  value: [
                    {
                      name: "Certificate.TBSCertificate.subjectUniqueID.id",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.BITSTRING,
                      constructed: false,
                      captureBitStringValue: "certSubjectUniqueId"
                    }
                  ]
                },
                {
                  name: "Certificate.TBSCertificate.extensions",
                  tagClass: t.Class.CONTEXT_SPECIFIC,
                  type: 3,
                  constructed: true,
                  captureAsn1: "certExtensions",
                  optional: true
                }
              ]
            },
            {
              name: "Certificate.signatureAlgorithm",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "Certificate.signatureAlgorithm.algorithm",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.OID,
                  constructed: false,
                  capture: "certSignatureOid"
                },
                {
                  name: "Certificate.TBSCertificate.signature.parameters",
                  tagClass: t.Class.UNIVERSAL,
                  optional: true,
                  captureAsn1: "certSignatureParams"
                }
              ]
            },
            {
              name: "Certificate.signatureValue",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certSignature"
            }
          ]
        }, s = {
          name: "rsapss",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "rsapss.hashAlgorithm",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: true,
              value: [
                {
                  name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Class.SEQUENCE,
                  constructed: true,
                  optional: true,
                  value: [
                    {
                      name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.OID,
                      constructed: false,
                      capture: "hashOid"
                    }
                  ]
                }
              ]
            },
            {
              name: "rsapss.maskGenAlgorithm",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              type: 1,
              constructed: true,
              value: [
                {
                  name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Class.SEQUENCE,
                  constructed: true,
                  optional: true,
                  value: [
                    {
                      name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.OID,
                      constructed: false,
                      capture: "maskGenOid"
                    },
                    {
                      name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: true,
                      value: [
                        {
                          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.OID,
                          constructed: false,
                          capture: "maskGenHashOid"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              name: "rsapss.saltLength",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              type: 2,
              optional: true,
              value: [
                {
                  name: "rsapss.saltLength.saltLength",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Class.INTEGER,
                  constructed: false,
                  capture: "saltLength"
                }
              ]
            },
            {
              name: "rsapss.trailerField",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              type: 3,
              optional: true,
              value: [
                {
                  name: "rsapss.trailer.trailer",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Class.INTEGER,
                  constructed: false,
                  capture: "trailer"
                }
              ]
            }
          ]
        }, p = {
          name: "CertificationRequestInfo",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfo",
          value: [
            {
              name: "CertificationRequestInfo.integer",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.INTEGER,
              constructed: false,
              capture: "certificationRequestInfoVersion"
            },
            {
              name: "CertificationRequestInfo.subject",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "certificationRequestInfoSubject"
            },
            _,
            {
              name: "CertificationRequestInfo.attributes",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: true,
              optional: true,
              capture: "certificationRequestInfoAttributes",
              value: [
                {
                  name: "CertificationRequestInfo.attributes",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: true,
                  value: [
                    {
                      name: "CertificationRequestInfo.attributes.type",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.OID,
                      constructed: false
                    },
                    {
                      name: "CertificationRequestInfo.attributes.value",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SET,
                      constructed: true
                    }
                  ]
                }
              ]
            }
          ]
        }, l = {
          name: "CertificationRequest",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "csr",
          value: [
            p,
            {
              name: "CertificationRequest.signatureAlgorithm",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "CertificationRequest.signatureAlgorithm.algorithm",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.OID,
                  constructed: false,
                  capture: "csrSignatureOid"
                },
                {
                  name: "CertificationRequest.signatureAlgorithm.parameters",
                  tagClass: t.Class.UNIVERSAL,
                  optional: true,
                  captureAsn1: "csrSignatureParams"
                }
              ]
            },
            {
              name: "CertificationRequest.signature",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "csrSignature"
            }
          ]
        };
        e.RDNAttributesAsArray = function(v, g) {
          for (var u = [], F, z, W, M = 0; M < v.value.length; ++M) {
            F = v.value[M];
            for (var Y = 0; Y < F.value.length; ++Y) W = {}, z = F.value[Y], W.type = t.derToOid(z.value[0].value), W.value = z.value[1].value, W.valueTagClass = z.value[1].type, W.type in a && (W.name = a[W.type], W.name in n && (W.shortName = n[W.name])), g && (g.update(W.type), g.update(W.value)), u.push(W);
          }
          return u;
        }, e.CRIAttributesAsArray = function(v) {
          for (var g = [], u = 0; u < v.length; ++u) for (var F = v[u], z = t.derToOid(F.value[0].value), W = F.value[1].value, M = 0; M < W.length; ++M) {
            var Y = {};
            if (Y.type = z, Y.value = W[M].value, Y.valueTagClass = W[M].type, Y.type in a && (Y.name = a[Y.type], Y.name in n && (Y.shortName = n[Y.name])), Y.type === a.extensionRequest) {
              Y.extensions = [];
              for (var tt = 0; tt < Y.value.length; ++tt) Y.extensions.push(e.certificateExtensionFromAsn1(Y.value[tt]));
            }
            g.push(Y);
          }
          return g;
        };
        function y(v, g) {
          typeof g == "string" && (g = {
            shortName: g
          });
          for (var u = null, F, z = 0; u === null && z < v.attributes.length; ++z) F = v.attributes[z], (g.type && g.type === F.type || g.name && g.name === F.name || g.shortName && g.shortName === F.shortName) && (u = F);
          return u;
        }
        var R = function(v, g, u) {
          var F = {};
          if (v !== a["RSASSA-PSS"]) return F;
          u && (F = {
            hash: {
              algorithmOid: a.sha1
            },
            mgf: {
              algorithmOid: a.mgf1,
              hash: {
                algorithmOid: a.sha1
              }
            },
            saltLength: 20
          });
          var z = {}, W = [];
          if (!t.validate(g, s, z, W)) {
            var M = new Error("Cannot read RSASSA-PSS parameter block.");
            throw M.errors = W, M;
          }
          return z.hashOid !== void 0 && (F.hash = F.hash || {}, F.hash.algorithmOid = t.derToOid(z.hashOid)), z.maskGenOid !== void 0 && (F.mgf = F.mgf || {}, F.mgf.algorithmOid = t.derToOid(z.maskGenOid), F.mgf.hash = F.mgf.hash || {}, F.mgf.hash.algorithmOid = t.derToOid(z.maskGenHashOid)), z.saltLength !== void 0 && (F.saltLength = z.saltLength.charCodeAt(0)), F;
        }, j = function(v) {
          switch (a[v.signatureOid]) {
            case "sha1WithRSAEncryption":
            case "sha1WithRSASignature":
              return d.md.sha1.create();
            case "md5WithRSAEncryption":
              return d.md.md5.create();
            case "sha256WithRSAEncryption":
              return d.md.sha256.create();
            case "sha384WithRSAEncryption":
              return d.md.sha384.create();
            case "sha512WithRSAEncryption":
              return d.md.sha512.create();
            case "RSASSA-PSS":
              return d.md.sha256.create();
            default:
              var g = new Error("Could not compute " + v.type + " digest. Unknown signature OID.");
              throw g.signatureOid = v.signatureOid, g;
          }
        }, b = function(v) {
          var g = v.certificate, u;
          switch (g.signatureOid) {
            case a.sha1WithRSAEncryption:
            case a.sha1WithRSASignature:
              break;
            case a["RSASSA-PSS"]:
              var F, z;
              if (F = a[g.signatureParameters.mgf.hash.algorithmOid], F === void 0 || d.md[F] === void 0) {
                var W = new Error("Unsupported MGF hash function.");
                throw W.oid = g.signatureParameters.mgf.hash.algorithmOid, W.name = F, W;
              }
              if (z = a[g.signatureParameters.mgf.algorithmOid], z === void 0 || d.mgf[z] === void 0) {
                var W = new Error("Unsupported MGF function.");
                throw W.oid = g.signatureParameters.mgf.algorithmOid, W.name = z, W;
              }
              if (z = d.mgf[z].create(d.md[F].create()), F = a[g.signatureParameters.hash.algorithmOid], F === void 0 || d.md[F] === void 0) {
                var W = new Error("Unsupported RSASSA-PSS hash function.");
                throw W.oid = g.signatureParameters.hash.algorithmOid, W.name = F, W;
              }
              u = d.pss.create(d.md[F].create(), z, g.signatureParameters.saltLength);
              break;
          }
          return g.publicKey.verify(v.md.digest().getBytes(), v.signature, u);
        };
        e.certificateFromPem = function(v, g, u) {
          var F = d.pem.decode(v)[0];
          if (F.type !== "CERTIFICATE" && F.type !== "X509 CERTIFICATE" && F.type !== "TRUSTED CERTIFICATE") {
            var z = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
            throw z.headerType = F.type, z;
          }
          if (F.procType && F.procType.type === "ENCRYPTED") throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
          var W = t.fromDer(F.body, u);
          return e.certificateFromAsn1(W, g);
        }, e.certificateToPem = function(v, g) {
          var u = {
            type: "CERTIFICATE",
            body: t.toDer(e.certificateToAsn1(v)).getBytes()
          };
          return d.pem.encode(u, {
            maxline: g
          });
        }, e.publicKeyFromPem = function(v) {
          var g = d.pem.decode(v)[0];
          if (g.type !== "PUBLIC KEY" && g.type !== "RSA PUBLIC KEY") {
            var u = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
            throw u.headerType = g.type, u;
          }
          if (g.procType && g.procType.type === "ENCRYPTED") throw new Error("Could not convert public key from PEM; PEM is encrypted.");
          var F = t.fromDer(g.body);
          return e.publicKeyFromAsn1(F);
        }, e.publicKeyToPem = function(v, g) {
          var u = {
            type: "PUBLIC KEY",
            body: t.toDer(e.publicKeyToAsn1(v)).getBytes()
          };
          return d.pem.encode(u, {
            maxline: g
          });
        }, e.publicKeyToRSAPublicKeyPem = function(v, g) {
          var u = {
            type: "RSA PUBLIC KEY",
            body: t.toDer(e.publicKeyToRSAPublicKey(v)).getBytes()
          };
          return d.pem.encode(u, {
            maxline: g
          });
        }, e.getPublicKeyFingerprint = function(v, g) {
          g = g || {};
          var u = g.md || d.md.sha1.create(), F = g.type || "RSAPublicKey", z;
          switch (F) {
            case "RSAPublicKey":
              z = t.toDer(e.publicKeyToRSAPublicKey(v)).getBytes();
              break;
            case "SubjectPublicKeyInfo":
              z = t.toDer(e.publicKeyToAsn1(v)).getBytes();
              break;
            default:
              throw new Error('Unknown fingerprint type "' + g.type + '".');
          }
          u.start(), u.update(z);
          var W = u.digest();
          if (g.encoding === "hex") {
            var M = W.toHex();
            return g.delimiter ? M.match(/.{2}/g).join(g.delimiter) : M;
          } else {
            if (g.encoding === "binary") return W.getBytes();
            if (g.encoding) throw new Error('Unknown encoding "' + g.encoding + '".');
          }
          return W;
        }, e.certificationRequestFromPem = function(v, g, u) {
          var F = d.pem.decode(v)[0];
          if (F.type !== "CERTIFICATE REQUEST") {
            var z = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
            throw z.headerType = F.type, z;
          }
          if (F.procType && F.procType.type === "ENCRYPTED") throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
          var W = t.fromDer(F.body, u);
          return e.certificationRequestFromAsn1(W, g);
        }, e.certificationRequestToPem = function(v, g) {
          var u = {
            type: "CERTIFICATE REQUEST",
            body: t.toDer(e.certificationRequestToAsn1(v)).getBytes()
          };
          return d.pem.encode(u, {
            maxline: g
          });
        }, e.createCertificate = function() {
          var v = {};
          return v.version = 2, v.serialNumber = "00", v.signatureOid = null, v.signature = null, v.siginfo = {}, v.siginfo.algorithmOid = null, v.validity = {}, v.validity.notBefore = /* @__PURE__ */ new Date(), v.validity.notAfter = /* @__PURE__ */ new Date(), v.issuer = {}, v.issuer.getField = function(g) {
            return y(v.issuer, g);
          }, v.issuer.addField = function(g) {
            A([
              g
            ]), v.issuer.attributes.push(g);
          }, v.issuer.attributes = [], v.issuer.hash = null, v.subject = {}, v.subject.getField = function(g) {
            return y(v.subject, g);
          }, v.subject.addField = function(g) {
            A([
              g
            ]), v.subject.attributes.push(g);
          }, v.subject.attributes = [], v.subject.hash = null, v.extensions = [], v.publicKey = null, v.md = null, v.setSubject = function(g, u) {
            A(g), v.subject.attributes = g, delete v.subject.uniqueId, u && (v.subject.uniqueId = u), v.subject.hash = null;
          }, v.setIssuer = function(g, u) {
            A(g), v.issuer.attributes = g, delete v.issuer.uniqueId, u && (v.issuer.uniqueId = u), v.issuer.hash = null;
          }, v.setExtensions = function(g) {
            for (var u = 0; u < g.length; ++u) T(g[u], {
              cert: v
            });
            v.extensions = g;
          }, v.getExtension = function(g) {
            typeof g == "string" && (g = {
              name: g
            });
            for (var u = null, F, z = 0; u === null && z < v.extensions.length; ++z) F = v.extensions[z], (g.id && F.id === g.id || g.name && F.name === g.name) && (u = F);
            return u;
          }, v.sign = function(g, u) {
            v.md = u || d.md.sha1.create();
            var F = a[v.md.algorithm + "WithRSAEncryption"];
            if (!F) {
              var z = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
              throw z.algorithm = v.md.algorithm, z;
            }
            v.signatureOid = v.siginfo.algorithmOid = F, v.tbsCertificate = e.getTBSCertificate(v);
            var W = t.toDer(v.tbsCertificate);
            v.md.update(W.getBytes()), v.signature = g.sign(v.md);
          }, v.verify = function(g) {
            var u = false;
            if (!v.issued(g)) {
              var F = g.issuer, z = v.subject, W = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
              throw W.expectedIssuer = z.attributes, W.actualIssuer = F.attributes, W;
            }
            var M = g.md;
            if (M === null) {
              M = j({
                signatureOid: g.signatureOid,
                type: "certificate"
              });
              var Y = g.tbsCertificate || e.getTBSCertificate(g), tt = t.toDer(Y);
              M.update(tt.getBytes());
            }
            return M !== null && (u = b({
              certificate: v,
              md: M,
              signature: g.signature
            })), u;
          }, v.isIssuer = function(g) {
            var u = false, F = v.issuer, z = g.subject;
            if (F.hash && z.hash) u = F.hash === z.hash;
            else if (F.attributes.length === z.attributes.length) {
              u = true;
              for (var W, M, Y = 0; u && Y < F.attributes.length; ++Y) W = F.attributes[Y], M = z.attributes[Y], (W.type !== M.type || W.value !== M.value) && (u = false);
            }
            return u;
          }, v.issued = function(g) {
            return g.isIssuer(v);
          }, v.generateSubjectKeyIdentifier = function() {
            return e.getPublicKeyFingerprint(v.publicKey, {
              type: "RSAPublicKey"
            });
          }, v.verifySubjectKeyIdentifier = function() {
            for (var g = a.subjectKeyIdentifier, u = 0; u < v.extensions.length; ++u) {
              var F = v.extensions[u];
              if (F.id === g) {
                var z = v.generateSubjectKeyIdentifier().getBytes();
                return d.util.hexToBytes(F.subjectKeyIdentifier) === z;
              }
            }
            return false;
          }, v;
        }, e.certificateFromAsn1 = function(v, g) {
          var u = {}, F = [];
          if (!t.validate(v, c, u, F)) {
            var z = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
            throw z.errors = F, z;
          }
          var W = t.derToOid(u.publicKeyOid);
          if (W !== e.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
          var M = e.createCertificate();
          M.version = u.certVersion ? u.certVersion.charCodeAt(0) : 0;
          var Y = d.util.createBuffer(u.certSerialNumber);
          M.serialNumber = Y.toHex(), M.signatureOid = d.asn1.derToOid(u.certSignatureOid), M.signatureParameters = R(M.signatureOid, u.certSignatureParams, true), M.siginfo.algorithmOid = d.asn1.derToOid(u.certinfoSignatureOid), M.siginfo.parameters = R(M.siginfo.algorithmOid, u.certinfoSignatureParams, false), M.signature = u.certSignature;
          var tt = [];
          if (u.certValidity1UTCTime !== void 0 && tt.push(t.utcTimeToDate(u.certValidity1UTCTime)), u.certValidity2GeneralizedTime !== void 0 && tt.push(t.generalizedTimeToDate(u.certValidity2GeneralizedTime)), u.certValidity3UTCTime !== void 0 && tt.push(t.utcTimeToDate(u.certValidity3UTCTime)), u.certValidity4GeneralizedTime !== void 0 && tt.push(t.generalizedTimeToDate(u.certValidity4GeneralizedTime)), tt.length > 2) throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
          if (tt.length < 2) throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
          if (M.validity.notBefore = tt[0], M.validity.notAfter = tt[1], M.tbsCertificate = u.tbsCertificate, g) {
            M.md = j({
              signatureOid: M.signatureOid,
              type: "certificate"
            });
            var Z = t.toDer(M.tbsCertificate);
            M.md.update(Z.getBytes());
          }
          var ot = d.md.sha1.create(), ct = t.toDer(u.certIssuer);
          ot.update(ct.getBytes()), M.issuer.getField = function(yt) {
            return y(M.issuer, yt);
          }, M.issuer.addField = function(yt) {
            A([
              yt
            ]), M.issuer.attributes.push(yt);
          }, M.issuer.attributes = e.RDNAttributesAsArray(u.certIssuer), u.certIssuerUniqueId && (M.issuer.uniqueId = u.certIssuerUniqueId), M.issuer.hash = ot.digest().toHex();
          var pt = d.md.sha1.create(), wt = t.toDer(u.certSubject);
          return pt.update(wt.getBytes()), M.subject.getField = function(yt) {
            return y(M.subject, yt);
          }, M.subject.addField = function(yt) {
            A([
              yt
            ]), M.subject.attributes.push(yt);
          }, M.subject.attributes = e.RDNAttributesAsArray(u.certSubject), u.certSubjectUniqueId && (M.subject.uniqueId = u.certSubjectUniqueId), M.subject.hash = pt.digest().toHex(), u.certExtensions ? M.extensions = e.certificateExtensionsFromAsn1(u.certExtensions) : M.extensions = [], M.publicKey = e.publicKeyFromAsn1(u.subjectPublicKeyInfo), M;
        }, e.certificateExtensionsFromAsn1 = function(v) {
          for (var g = [], u = 0; u < v.value.length; ++u) for (var F = v.value[u], z = 0; z < F.value.length; ++z) g.push(e.certificateExtensionFromAsn1(F.value[z]));
          return g;
        }, e.certificateExtensionFromAsn1 = function(v) {
          var g = {};
          if (g.id = t.derToOid(v.value[0].value), g.critical = false, v.value[1].type === t.Type.BOOLEAN ? (g.critical = v.value[1].value.charCodeAt(0) !== 0, g.value = v.value[2].value) : g.value = v.value[1].value, g.id in a) {
            if (g.name = a[g.id], g.name === "keyUsage") {
              var u = t.fromDer(g.value), F = 0, z = 0;
              u.value.length > 1 && (F = u.value.charCodeAt(1), z = u.value.length > 2 ? u.value.charCodeAt(2) : 0), g.digitalSignature = (F & 128) === 128, g.nonRepudiation = (F & 64) === 64, g.keyEncipherment = (F & 32) === 32, g.dataEncipherment = (F & 16) === 16, g.keyAgreement = (F & 8) === 8, g.keyCertSign = (F & 4) === 4, g.cRLSign = (F & 2) === 2, g.encipherOnly = (F & 1) === 1, g.decipherOnly = (z & 128) === 128;
            } else if (g.name === "basicConstraints") {
              var u = t.fromDer(g.value);
              u.value.length > 0 && u.value[0].type === t.Type.BOOLEAN ? g.cA = u.value[0].value.charCodeAt(0) !== 0 : g.cA = false;
              var W = null;
              u.value.length > 0 && u.value[0].type === t.Type.INTEGER ? W = u.value[0].value : u.value.length > 1 && (W = u.value[1].value), W !== null && (g.pathLenConstraint = t.derToInteger(W));
            } else if (g.name === "extKeyUsage") for (var u = t.fromDer(g.value), M = 0; M < u.value.length; ++M) {
              var Y = t.derToOid(u.value[M].value);
              Y in a ? g[a[Y]] = true : g[Y] = true;
            }
            else if (g.name === "nsCertType") {
              var u = t.fromDer(g.value), F = 0;
              u.value.length > 1 && (F = u.value.charCodeAt(1)), g.client = (F & 128) === 128, g.server = (F & 64) === 64, g.email = (F & 32) === 32, g.objsign = (F & 16) === 16, g.reserved = (F & 8) === 8, g.sslCA = (F & 4) === 4, g.emailCA = (F & 2) === 2, g.objCA = (F & 1) === 1;
            } else if (g.name === "subjectAltName" || g.name === "issuerAltName") {
              g.altNames = [];
              for (var tt, u = t.fromDer(g.value), Z = 0; Z < u.value.length; ++Z) {
                tt = u.value[Z];
                var ot = {
                  type: tt.type,
                  value: tt.value
                };
                switch (g.altNames.push(ot), tt.type) {
                  case 1:
                  case 2:
                  case 6:
                    break;
                  case 7:
                    ot.ip = d.util.bytesToIP(tt.value);
                    break;
                  case 8:
                    ot.oid = t.derToOid(tt.value);
                    break;
                }
              }
            } else if (g.name === "subjectKeyIdentifier") {
              var u = t.fromDer(g.value);
              g.subjectKeyIdentifier = d.util.bytesToHex(u.value);
            }
          }
          return g;
        }, e.certificationRequestFromAsn1 = function(v, g) {
          var u = {}, F = [];
          if (!t.validate(v, l, u, F)) {
            var z = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
            throw z.errors = F, z;
          }
          var W = t.derToOid(u.publicKeyOid);
          if (W !== e.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
          var M = e.createCertificationRequest();
          if (M.version = u.csrVersion ? u.csrVersion.charCodeAt(0) : 0, M.signatureOid = d.asn1.derToOid(u.csrSignatureOid), M.signatureParameters = R(M.signatureOid, u.csrSignatureParams, true), M.siginfo.algorithmOid = d.asn1.derToOid(u.csrSignatureOid), M.siginfo.parameters = R(M.siginfo.algorithmOid, u.csrSignatureParams, false), M.signature = u.csrSignature, M.certificationRequestInfo = u.certificationRequestInfo, g) {
            M.md = j({
              signatureOid: M.signatureOid,
              type: "certification request"
            });
            var Y = t.toDer(M.certificationRequestInfo);
            M.md.update(Y.getBytes());
          }
          var tt = d.md.sha1.create();
          return M.subject.getField = function(Z) {
            return y(M.subject, Z);
          }, M.subject.addField = function(Z) {
            A([
              Z
            ]), M.subject.attributes.push(Z);
          }, M.subject.attributes = e.RDNAttributesAsArray(u.certificationRequestInfoSubject, tt), M.subject.hash = tt.digest().toHex(), M.publicKey = e.publicKeyFromAsn1(u.subjectPublicKeyInfo), M.getAttribute = function(Z) {
            return y(M, Z);
          }, M.addAttribute = function(Z) {
            A([
              Z
            ]), M.attributes.push(Z);
          }, M.attributes = e.CRIAttributesAsArray(u.certificationRequestInfoAttributes || []), M;
        }, e.createCertificationRequest = function() {
          var v = {};
          return v.version = 0, v.signatureOid = null, v.signature = null, v.siginfo = {}, v.siginfo.algorithmOid = null, v.subject = {}, v.subject.getField = function(g) {
            return y(v.subject, g);
          }, v.subject.addField = function(g) {
            A([
              g
            ]), v.subject.attributes.push(g);
          }, v.subject.attributes = [], v.subject.hash = null, v.publicKey = null, v.attributes = [], v.getAttribute = function(g) {
            return y(v, g);
          }, v.addAttribute = function(g) {
            A([
              g
            ]), v.attributes.push(g);
          }, v.md = null, v.setSubject = function(g) {
            A(g), v.subject.attributes = g, v.subject.hash = null;
          }, v.setAttributes = function(g) {
            A(g), v.attributes = g;
          }, v.sign = function(g, u) {
            v.md = u || d.md.sha1.create();
            var F = a[v.md.algorithm + "WithRSAEncryption"];
            if (!F) {
              var z = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
              throw z.algorithm = v.md.algorithm, z;
            }
            v.signatureOid = v.siginfo.algorithmOid = F, v.certificationRequestInfo = e.getCertificationRequestInfo(v);
            var W = t.toDer(v.certificationRequestInfo);
            v.md.update(W.getBytes()), v.signature = g.sign(v.md);
          }, v.verify = function() {
            var g = false, u = v.md;
            if (u === null) {
              u = j({
                signatureOid: v.signatureOid,
                type: "certification request"
              });
              var F = v.certificationRequestInfo || e.getCertificationRequestInfo(v), z = t.toDer(F);
              u.update(z.getBytes());
            }
            return u !== null && (g = b({
              certificate: v,
              md: u,
              signature: v.signature
            })), g;
          }, v;
        };
        function C(v) {
          for (var g = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, []), u, F, z = v.attributes, W = 0; W < z.length; ++W) {
            u = z[W];
            var M = u.value, Y = t.Type.PRINTABLESTRING;
            "valueTagClass" in u && (Y = u.valueTagClass, Y === t.Type.UTF8 && (M = d.util.encodeUtf8(M))), F = t.create(t.Class.UNIVERSAL, t.Type.SET, true, [
              t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
                t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(u.type).getBytes()),
                t.create(t.Class.UNIVERSAL, Y, false, M)
              ])
            ]), g.value.push(F);
          }
          return g;
        }
        function A(v) {
          for (var g, u = 0; u < v.length; ++u) {
            if (g = v[u], typeof g.name > "u" && (g.type && g.type in e.oids ? g.name = e.oids[g.type] : g.shortName && g.shortName in n && (g.name = e.oids[n[g.shortName]])), typeof g.type > "u") if (g.name && g.name in e.oids) g.type = e.oids[g.name];
            else {
              var F = new Error("Attribute type not specified.");
              throw F.attribute = g, F;
            }
            if (typeof g.shortName > "u" && g.name && g.name in n && (g.shortName = n[g.name]), g.type === a.extensionRequest && (g.valueConstructed = true, g.valueTagClass = t.Type.SEQUENCE, !g.value && g.extensions)) {
              g.value = [];
              for (var z = 0; z < g.extensions.length; ++z) g.value.push(e.certificateExtensionToAsn1(T(g.extensions[z])));
            }
            if (typeof g.value > "u") {
              var F = new Error("Attribute value not specified.");
              throw F.attribute = g, F;
            }
          }
        }
        function T(v, g) {
          if (g = g || {}, typeof v.name > "u" && v.id && v.id in e.oids && (v.name = e.oids[v.id]), typeof v.id > "u") if (v.name && v.name in e.oids) v.id = e.oids[v.name];
          else {
            var u = new Error("Extension ID not specified.");
            throw u.extension = v, u;
          }
          if (typeof v.value < "u") return v;
          if (v.name === "keyUsage") {
            var F = 0, z = 0, W = 0;
            v.digitalSignature && (z |= 128, F = 7), v.nonRepudiation && (z |= 64, F = 6), v.keyEncipherment && (z |= 32, F = 5), v.dataEncipherment && (z |= 16, F = 4), v.keyAgreement && (z |= 8, F = 3), v.keyCertSign && (z |= 4, F = 2), v.cRLSign && (z |= 2, F = 1), v.encipherOnly && (z |= 1, F = 0), v.decipherOnly && (W |= 128, F = 7);
            var M = String.fromCharCode(F);
            W !== 0 ? M += String.fromCharCode(z) + String.fromCharCode(W) : z !== 0 && (M += String.fromCharCode(z)), v.value = t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, false, M);
          } else if (v.name === "basicConstraints") v.value = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, []), v.cA && v.value.value.push(t.create(t.Class.UNIVERSAL, t.Type.BOOLEAN, false, "\xFF")), "pathLenConstraint" in v && v.value.value.push(t.create(t.Class.UNIVERSAL, t.Type.INTEGER, false, t.integerToDer(v.pathLenConstraint).getBytes()));
          else if (v.name === "extKeyUsage") {
            v.value = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, []);
            var Y = v.value.value;
            for (var tt in v) v[tt] === true && (tt in a ? Y.push(t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(a[tt]).getBytes())) : tt.indexOf(".") !== -1 && Y.push(t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(tt).getBytes())));
          } else if (v.name === "nsCertType") {
            var F = 0, z = 0;
            v.client && (z |= 128, F = 7), v.server && (z |= 64, F = 6), v.email && (z |= 32, F = 5), v.objsign && (z |= 16, F = 4), v.reserved && (z |= 8, F = 3), v.sslCA && (z |= 4, F = 2), v.emailCA && (z |= 2, F = 1), v.objCA && (z |= 1, F = 0);
            var M = String.fromCharCode(F);
            z !== 0 && (M += String.fromCharCode(z)), v.value = t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, false, M);
          } else if (v.name === "subjectAltName" || v.name === "issuerAltName") {
            v.value = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, []);
            for (var Z, ot = 0; ot < v.altNames.length; ++ot) {
              Z = v.altNames[ot];
              var M = Z.value;
              if (Z.type === 7 && Z.ip) {
                if (M = d.util.bytesFromIP(Z.ip), M === null) {
                  var u = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
                  throw u.extension = v, u;
                }
              } else Z.type === 8 && (Z.oid ? M = t.oidToDer(t.oidToDer(Z.oid)) : M = t.oidToDer(M));
              v.value.value.push(t.create(t.Class.CONTEXT_SPECIFIC, Z.type, false, M));
            }
          } else if (v.name === "nsComment" && g.cert) {
            if (!/^[\x00-\x7F]*$/.test(v.comment) || v.comment.length < 1 || v.comment.length > 128) throw new Error('Invalid "nsComment" content.');
            v.value = t.create(t.Class.UNIVERSAL, t.Type.IA5STRING, false, v.comment);
          } else if (v.name === "subjectKeyIdentifier" && g.cert) {
            var ct = g.cert.generateSubjectKeyIdentifier();
            v.subjectKeyIdentifier = ct.toHex(), v.value = t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, ct.getBytes());
          } else if (v.name === "authorityKeyIdentifier" && g.cert) {
            v.value = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, []);
            var Y = v.value.value;
            if (v.keyIdentifier) {
              var pt = v.keyIdentifier === true ? g.cert.generateSubjectKeyIdentifier().getBytes() : v.keyIdentifier;
              Y.push(t.create(t.Class.CONTEXT_SPECIFIC, 0, false, pt));
            }
            if (v.authorityCertIssuer) {
              var wt = [
                t.create(t.Class.CONTEXT_SPECIFIC, 4, true, [
                  C(v.authorityCertIssuer === true ? g.cert.issuer : v.authorityCertIssuer)
                ])
              ];
              Y.push(t.create(t.Class.CONTEXT_SPECIFIC, 1, true, wt));
            }
            if (v.serialNumber) {
              var yt = d.util.hexToBytes(v.serialNumber === true ? g.cert.serialNumber : v.serialNumber);
              Y.push(t.create(t.Class.CONTEXT_SPECIFIC, 2, false, yt));
            }
          } else if (v.name === "cRLDistributionPoints") {
            v.value = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, []);
            for (var Y = v.value.value, St = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, []), Bt = t.create(t.Class.CONTEXT_SPECIFIC, 0, true, []), Z, ot = 0; ot < v.altNames.length; ++ot) {
              Z = v.altNames[ot];
              var M = Z.value;
              if (Z.type === 7 && Z.ip) {
                if (M = d.util.bytesFromIP(Z.ip), M === null) {
                  var u = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
                  throw u.extension = v, u;
                }
              } else Z.type === 8 && (Z.oid ? M = t.oidToDer(t.oidToDer(Z.oid)) : M = t.oidToDer(M));
              Bt.value.push(t.create(t.Class.CONTEXT_SPECIFIC, Z.type, false, M));
            }
            St.value.push(t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
              Bt
            ])), Y.push(St);
          }
          if (typeof v.value > "u") {
            var u = new Error("Extension value not specified.");
            throw u.extension = v, u;
          }
          return v;
        }
        function h(v, g) {
          switch (v) {
            case a["RSASSA-PSS"]:
              var u = [];
              return g.hash.algorithmOid !== void 0 && u.push(t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
                t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
                  t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(g.hash.algorithmOid).getBytes()),
                  t.create(t.Class.UNIVERSAL, t.Type.NULL, false, "")
                ])
              ])), g.mgf.algorithmOid !== void 0 && u.push(t.create(t.Class.CONTEXT_SPECIFIC, 1, true, [
                t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
                  t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(g.mgf.algorithmOid).getBytes()),
                  t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
                    t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(g.mgf.hash.algorithmOid).getBytes()),
                    t.create(t.Class.UNIVERSAL, t.Type.NULL, false, "")
                  ])
                ])
              ])), g.saltLength !== void 0 && u.push(t.create(t.Class.CONTEXT_SPECIFIC, 2, true, [
                t.create(t.Class.UNIVERSAL, t.Type.INTEGER, false, t.integerToDer(g.saltLength).getBytes())
              ])), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, u);
            default:
              return t.create(t.Class.UNIVERSAL, t.Type.NULL, false, "");
          }
        }
        function k(v) {
          var g = t.create(t.Class.CONTEXT_SPECIFIC, 0, true, []);
          if (v.attributes.length === 0) return g;
          for (var u = v.attributes, F = 0; F < u.length; ++F) {
            var z = u[F], W = z.value, M = t.Type.UTF8;
            "valueTagClass" in z && (M = z.valueTagClass), M === t.Type.UTF8 && (W = d.util.encodeUtf8(W));
            var Y = false;
            "valueConstructed" in z && (Y = z.valueConstructed);
            var tt = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(z.type).getBytes()),
              t.create(t.Class.UNIVERSAL, t.Type.SET, true, [
                t.create(t.Class.UNIVERSAL, M, Y, W)
              ])
            ]);
            g.value.push(tt);
          }
          return g;
        }
        var S = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z"), N = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
        function P(v) {
          return v >= S && v < N ? t.create(t.Class.UNIVERSAL, t.Type.UTCTIME, false, t.dateToUtcTime(v)) : t.create(t.Class.UNIVERSAL, t.Type.GENERALIZEDTIME, false, t.dateToGeneralizedTime(v));
        }
        return e.getTBSCertificate = function(v) {
          var g = P(v.validity.notBefore), u = P(v.validity.notAfter), F = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
            t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
              t.create(t.Class.UNIVERSAL, t.Type.INTEGER, false, t.integerToDer(v.version).getBytes())
            ]),
            t.create(t.Class.UNIVERSAL, t.Type.INTEGER, false, d.util.hexToBytes(v.serialNumber)),
            t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(v.siginfo.algorithmOid).getBytes()),
              h(v.siginfo.algorithmOid, v.siginfo.parameters)
            ]),
            C(v.issuer),
            t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              g,
              u
            ]),
            C(v.subject),
            e.publicKeyToAsn1(v.publicKey)
          ]);
          return v.issuer.uniqueId && F.value.push(t.create(t.Class.CONTEXT_SPECIFIC, 1, true, [
            t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, false, "\0" + v.issuer.uniqueId)
          ])), v.subject.uniqueId && F.value.push(t.create(t.Class.CONTEXT_SPECIFIC, 2, true, [
            t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, false, "\0" + v.subject.uniqueId)
          ])), v.extensions.length > 0 && F.value.push(e.certificateExtensionsToAsn1(v.extensions)), F;
        }, e.getCertificationRequestInfo = function(v) {
          var g = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
            t.create(t.Class.UNIVERSAL, t.Type.INTEGER, false, t.integerToDer(v.version).getBytes()),
            C(v.subject),
            e.publicKeyToAsn1(v.publicKey),
            k(v)
          ]);
          return g;
        }, e.distinguishedNameToAsn1 = function(v) {
          return C(v);
        }, e.certificateToAsn1 = function(v) {
          var g = v.tbsCertificate || e.getTBSCertificate(v);
          return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
            g,
            t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(v.signatureOid).getBytes()),
              h(v.signatureOid, v.signatureParameters)
            ]),
            t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, false, "\0" + v.signature)
          ]);
        }, e.certificateExtensionsToAsn1 = function(v) {
          var g = t.create(t.Class.CONTEXT_SPECIFIC, 3, true, []), u = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, []);
          g.value.push(u);
          for (var F = 0; F < v.length; ++F) u.value.push(e.certificateExtensionToAsn1(v[F]));
          return g;
        }, e.certificateExtensionToAsn1 = function(v) {
          var g = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, []);
          g.value.push(t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(v.id).getBytes())), v.critical && g.value.push(t.create(t.Class.UNIVERSAL, t.Type.BOOLEAN, false, "\xFF"));
          var u = v.value;
          return typeof v.value != "string" && (u = t.toDer(u).getBytes()), g.value.push(t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, u)), g;
        }, e.certificationRequestToAsn1 = function(v) {
          var g = v.certificationRequestInfo || e.getCertificationRequestInfo(v);
          return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
            g,
            t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(v.signatureOid).getBytes()),
              h(v.signatureOid, v.signatureParameters)
            ]),
            t.create(t.Class.UNIVERSAL, t.Type.BITSTRING, false, "\0" + v.signature)
          ]);
        }, e.createCaStore = function(v) {
          var g = {
            certs: {}
          };
          g.getIssuer = function(M) {
            var Y = u(M.issuer);
            return Y;
          }, g.addCertificate = function(M) {
            if (typeof M == "string" && (M = d.pki.certificateFromPem(M)), F(M.subject), !g.hasCertificate(M)) if (M.subject.hash in g.certs) {
              var Y = g.certs[M.subject.hash];
              d.util.isArray(Y) || (Y = [
                Y
              ]), Y.push(M), g.certs[M.subject.hash] = Y;
            } else g.certs[M.subject.hash] = M;
          }, g.hasCertificate = function(M) {
            typeof M == "string" && (M = d.pki.certificateFromPem(M));
            var Y = u(M.subject);
            if (!Y) return false;
            d.util.isArray(Y) || (Y = [
              Y
            ]);
            for (var tt = t.toDer(e.certificateToAsn1(M)).getBytes(), Z = 0; Z < Y.length; ++Z) {
              var ot = t.toDer(e.certificateToAsn1(Y[Z])).getBytes();
              if (tt === ot) return true;
            }
            return false;
          }, g.listAllCertificates = function() {
            var M = [];
            for (var Y in g.certs) if (g.certs.hasOwnProperty(Y)) {
              var tt = g.certs[Y];
              if (!d.util.isArray(tt)) M.push(tt);
              else for (var Z = 0; Z < tt.length; ++Z) M.push(tt[Z]);
            }
            return M;
          }, g.removeCertificate = function(M) {
            var Y;
            if (typeof M == "string" && (M = d.pki.certificateFromPem(M)), F(M.subject), !g.hasCertificate(M)) return null;
            var tt = u(M.subject);
            if (!d.util.isArray(tt)) return Y = g.certs[M.subject.hash], delete g.certs[M.subject.hash], Y;
            for (var Z = t.toDer(e.certificateToAsn1(M)).getBytes(), ot = 0; ot < tt.length; ++ot) {
              var ct = t.toDer(e.certificateToAsn1(tt[ot])).getBytes();
              Z === ct && (Y = tt[ot], tt.splice(ot, 1));
            }
            return tt.length === 0 && delete g.certs[M.subject.hash], Y;
          };
          function u(M) {
            return F(M), g.certs[M.hash] || null;
          }
          function F(M) {
            if (!M.hash) {
              var Y = d.md.sha1.create();
              M.attributes = e.RDNAttributesAsArray(C(M), Y), M.hash = Y.digest().toHex();
            }
          }
          if (v) for (var z = 0; z < v.length; ++z) {
            var W = v[z];
            g.addCertificate(W);
          }
          return g;
        }, e.certificateError = {
          bad_certificate: "forge.pki.BadCertificate",
          unsupported_certificate: "forge.pki.UnsupportedCertificate",
          certificate_revoked: "forge.pki.CertificateRevoked",
          certificate_expired: "forge.pki.CertificateExpired",
          certificate_unknown: "forge.pki.CertificateUnknown",
          unknown_ca: "forge.pki.UnknownCertificateAuthority"
        }, e.verifyCertificateChain = function(v, g, u) {
          typeof u == "function" && (u = {
            verify: u
          }), u = u || {}, g = g.slice(0);
          var F = g.slice(0), z = u.validityCheckDate;
          typeof z > "u" && (z = /* @__PURE__ */ new Date());
          var W = true, M = null, Y = 0;
          do {
            var tt = g.shift(), Z = null, ot = false;
            if (z && (z < tt.validity.notBefore || z > tt.validity.notAfter) && (M = {
              message: "Certificate is not valid yet or has expired.",
              error: e.certificateError.certificate_expired,
              notBefore: tt.validity.notBefore,
              notAfter: tt.validity.notAfter,
              now: z
            }), M === null) {
              if (Z = g[0] || v.getIssuer(tt), Z === null && tt.isIssuer(tt) && (ot = true, Z = tt), Z) {
                var ct = Z;
                d.util.isArray(ct) || (ct = [
                  ct
                ]);
                for (var pt = false; !pt && ct.length > 0; ) {
                  Z = ct.shift();
                  try {
                    pt = Z.verify(tt);
                  } catch {
                  }
                }
                pt || (M = {
                  message: "Certificate signature is invalid.",
                  error: e.certificateError.bad_certificate
                });
              }
              M === null && (!Z || ot) && !v.hasCertificate(tt) && (M = {
                message: "Certificate is not trusted.",
                error: e.certificateError.unknown_ca
              });
            }
            if (M === null && Z && !tt.isIssuer(Z) && (M = {
              message: "Certificate issuer is invalid.",
              error: e.certificateError.bad_certificate
            }), M === null) for (var wt = {
              keyUsage: true,
              basicConstraints: true
            }, yt = 0; M === null && yt < tt.extensions.length; ++yt) {
              var St = tt.extensions[yt];
              St.critical && !(St.name in wt) && (M = {
                message: "Certificate has an unsupported critical extension.",
                error: e.certificateError.unsupported_certificate
              });
            }
            if (M === null && (!W || g.length === 0 && (!Z || ot))) {
              var Bt = tt.getExtension("basicConstraints"), Kt = tt.getExtension("keyUsage");
              if (Kt !== null && (!Kt.keyCertSign || Bt === null) && (M = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: e.certificateError.bad_certificate
              }), M === null && Bt !== null && !Bt.cA && (M = {
                message: "Certificate basicConstraints indicates the certificate is not a CA.",
                error: e.certificateError.bad_certificate
              }), M === null && Kt !== null && "pathLenConstraint" in Bt) {
                var rt = Y - 1;
                rt > Bt.pathLenConstraint && (M = {
                  message: "Certificate basicConstraints pathLenConstraint violated.",
                  error: e.certificateError.bad_certificate
                });
              }
            }
            var Tt = M === null ? true : M.error, gt = u.verify ? u.verify(Tt, Y, F) : Tt;
            if (gt === true) M = null;
            else throw Tt === true && (M = {
              message: "The application rejected the certificate.",
              error: e.certificateError.bad_certificate
            }), (gt || gt === 0) && (typeof gt == "object" && !d.util.isArray(gt) ? (gt.message && (M.message = gt.message), gt.error && (M.error = gt.error)) : typeof gt == "string" && (M.error = gt)), M;
            W = false, ++Y;
          } while (g.length > 0);
          return true;
        }, Wa.exports;
      }
      var _d;
      function rl() {
        if (_d) return Ha.exports;
        _d = 1;
        var d = Lt();
        gr(), Dn(), gn(), tl(), Zd(), ar(), fa(), Pn(), Ut(), Co();
        var t = d.asn1, e = d.pki, a = Ha.exports = d.pkcs12 = d.pkcs12 || {}, n = {
          name: "ContentInfo",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "ContentInfo.contentType",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.OID,
              constructed: false,
              capture: "contentType"
            },
            {
              name: "ContentInfo.content",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              constructed: true,
              captureAsn1: "content"
            }
          ]
        }, _ = {
          name: "PFX",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "PFX.version",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.INTEGER,
              constructed: false,
              capture: "version"
            },
            n,
            {
              name: "PFX.macData",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: true,
              optional: true,
              captureAsn1: "mac",
              value: [
                {
                  name: "PFX.macData.mac",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.SEQUENCE,
                  constructed: true,
                  value: [
                    {
                      name: "PFX.macData.mac.digestAlgorithm",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.SEQUENCE,
                      constructed: true,
                      value: [
                        {
                          name: "PFX.macData.mac.digestAlgorithm.algorithm",
                          tagClass: t.Class.UNIVERSAL,
                          type: t.Type.OID,
                          constructed: false,
                          capture: "macAlgorithm"
                        },
                        {
                          name: "PFX.macData.mac.digestAlgorithm.parameters",
                          tagClass: t.Class.UNIVERSAL,
                          captureAsn1: "macAlgorithmParameters"
                        }
                      ]
                    },
                    {
                      name: "PFX.macData.mac.digest",
                      tagClass: t.Class.UNIVERSAL,
                      type: t.Type.OCTETSTRING,
                      constructed: false,
                      capture: "macDigest"
                    }
                  ]
                },
                {
                  name: "PFX.macData.macSalt",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.OCTETSTRING,
                  constructed: false,
                  capture: "macSalt"
                },
                {
                  name: "PFX.macData.iterations",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.INTEGER,
                  constructed: false,
                  optional: true,
                  capture: "macIterations"
                }
              ]
            }
          ]
        }, c = {
          name: "SafeBag",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "SafeBag.bagId",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.OID,
              constructed: false,
              capture: "bagId"
            },
            {
              name: "SafeBag.bagValue",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              constructed: true,
              captureAsn1: "bagValue"
            },
            {
              name: "SafeBag.bagAttributes",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SET,
              constructed: true,
              optional: true,
              capture: "bagAttributes"
            }
          ]
        }, s = {
          name: "Attribute",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "Attribute.attrId",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.OID,
              constructed: false,
              capture: "oid"
            },
            {
              name: "Attribute.attrValues",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SET,
              constructed: true,
              capture: "values"
            }
          ]
        }, p = {
          name: "CertBag",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "CertBag.certId",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.OID,
              constructed: false,
              capture: "certId"
            },
            {
              name: "CertBag.certValue",
              tagClass: t.Class.CONTEXT_SPECIFIC,
              constructed: true,
              value: [
                {
                  name: "CertBag.certValue[0]",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Class.OCTETSTRING,
                  constructed: false,
                  capture: "cert"
                }
              ]
            }
          ]
        };
        function l(A, T, h, k) {
          for (var S = [], N = 0; N < A.length; N++) for (var P = 0; P < A[N].safeBags.length; P++) {
            var v = A[N].safeBags[P];
            if (!(k !== void 0 && v.type !== k)) {
              if (T === null) {
                S.push(v);
                continue;
              }
              v.attributes[T] !== void 0 && v.attributes[T].indexOf(h) >= 0 && S.push(v);
            }
          }
          return S;
        }
        a.pkcs12FromAsn1 = function(A, T, h) {
          typeof T == "string" ? (h = T, T = true) : T === void 0 && (T = true);
          var k = {}, S = [];
          if (!t.validate(A, _, k, S)) {
            var N = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
            throw N.errors = N, N;
          }
          var P = {
            version: k.version.charCodeAt(0),
            safeContents: [],
            getBags: function(Z) {
              var ot = {}, ct;
              return "localKeyId" in Z ? ct = Z.localKeyId : "localKeyIdHex" in Z && (ct = d.util.hexToBytes(Z.localKeyIdHex)), ct === void 0 && !("friendlyName" in Z) && "bagType" in Z && (ot[Z.bagType] = l(P.safeContents, null, null, Z.bagType)), ct !== void 0 && (ot.localKeyId = l(P.safeContents, "localKeyId", ct, Z.bagType)), "friendlyName" in Z && (ot.friendlyName = l(P.safeContents, "friendlyName", Z.friendlyName, Z.bagType)), ot;
            },
            getBagsByFriendlyName: function(Z, ot) {
              return l(P.safeContents, "friendlyName", Z, ot);
            },
            getBagsByLocalKeyId: function(Z, ot) {
              return l(P.safeContents, "localKeyId", Z, ot);
            }
          };
          if (k.version.charCodeAt(0) !== 3) {
            var N = new Error("PKCS#12 PFX of version other than 3 not supported.");
            throw N.version = k.version.charCodeAt(0), N;
          }
          if (t.derToOid(k.contentType) !== e.oids.data) {
            var N = new Error("Only PKCS#12 PFX in password integrity mode supported.");
            throw N.oid = t.derToOid(k.contentType), N;
          }
          var v = k.content.value[0];
          if (v.tagClass !== t.Class.UNIVERSAL || v.type !== t.Type.OCTETSTRING) throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
          if (v = y(v), k.mac) {
            var g = null, u = 0, F = t.derToOid(k.macAlgorithm);
            switch (F) {
              case e.oids.sha1:
                g = d.md.sha1.create(), u = 20;
                break;
              case e.oids.sha256:
                g = d.md.sha256.create(), u = 32;
                break;
              case e.oids.sha384:
                g = d.md.sha384.create(), u = 48;
                break;
              case e.oids.sha512:
                g = d.md.sha512.create(), u = 64;
                break;
              case e.oids.md5:
                g = d.md.md5.create(), u = 16;
                break;
            }
            if (g === null) throw new Error("PKCS#12 uses unsupported MAC algorithm: " + F);
            var z = new d.util.ByteBuffer(k.macSalt), W = "macIterations" in k ? parseInt(d.util.bytesToHex(k.macIterations), 16) : 1, M = a.generateKey(h, z, 3, W, u, g), Y = d.hmac.create();
            Y.start(g, M), Y.update(v.value);
            var tt = Y.getMac();
            if (tt.getBytes() !== k.macDigest) throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
          }
          return R(P, v.value, T, h), P;
        };
        function y(A) {
          if (A.composed || A.constructed) {
            for (var T = d.util.createBuffer(), h = 0; h < A.value.length; ++h) T.putBytes(A.value[h].value);
            A.composed = A.constructed = false, A.value = T.getBytes();
          }
          return A;
        }
        function R(A, T, h, k) {
          if (T = t.fromDer(T, h), T.tagClass !== t.Class.UNIVERSAL || T.type !== t.Type.SEQUENCE || T.constructed !== true) throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
          for (var S = 0; S < T.value.length; S++) {
            var N = T.value[S], P = {}, v = [];
            if (!t.validate(N, n, P, v)) {
              var g = new Error("Cannot read ContentInfo.");
              throw g.errors = v, g;
            }
            var u = {
              encrypted: false
            }, F = null, z = P.content.value[0];
            switch (t.derToOid(P.contentType)) {
              case e.oids.data:
                if (z.tagClass !== t.Class.UNIVERSAL || z.type !== t.Type.OCTETSTRING) throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
                F = y(z).value;
                break;
              case e.oids.encryptedData:
                F = j(z, k), u.encrypted = true;
                break;
              default:
                var g = new Error("Unsupported PKCS#12 contentType.");
                throw g.contentType = t.derToOid(P.contentType), g;
            }
            u.safeBags = b(F, h, k), A.safeContents.push(u);
          }
        }
        function j(A, T) {
          var h = {}, k = [];
          if (!t.validate(A, d.pkcs7.asn1.encryptedDataValidator, h, k)) {
            var S = new Error("Cannot read EncryptedContentInfo.");
            throw S.errors = k, S;
          }
          var N = t.derToOid(h.contentType);
          if (N !== e.oids.data) {
            var S = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.");
            throw S.oid = N, S;
          }
          N = t.derToOid(h.encAlgorithm);
          var P = e.pbe.getCipher(N, h.encParameter, T), v = y(h.encryptedContentAsn1), g = d.util.createBuffer(v.value);
          if (P.update(g), !P.finish()) throw new Error("Failed to decrypt PKCS#12 SafeContents.");
          return P.output.getBytes();
        }
        function b(A, T, h) {
          if (!T && A.length === 0) return [];
          if (A = t.fromDer(A, T), A.tagClass !== t.Class.UNIVERSAL || A.type !== t.Type.SEQUENCE || A.constructed !== true) throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");
          for (var k = [], S = 0; S < A.value.length; S++) {
            var N = A.value[S], P = {}, v = [];
            if (!t.validate(N, c, P, v)) {
              var g = new Error("Cannot read SafeBag.");
              throw g.errors = v, g;
            }
            var u = {
              type: t.derToOid(P.bagId),
              attributes: C(P.bagAttributes)
            };
            k.push(u);
            var F, z, W = P.bagValue.value[0];
            switch (u.type) {
              case e.oids.pkcs8ShroudedKeyBag:
                if (W = e.decryptPrivateKeyInfo(W, h), W === null) throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");
              case e.oids.keyBag:
                try {
                  u.key = e.privateKeyFromAsn1(W);
                } catch {
                  u.key = null, u.asn1 = W;
                }
                continue;
              case e.oids.certBag:
                F = p, z = function() {
                  if (t.derToOid(P.certId) !== e.oids.x509Certificate) {
                    var Y = new Error("Unsupported certificate type, only X.509 supported.");
                    throw Y.oid = t.derToOid(P.certId), Y;
                  }
                  var tt = t.fromDer(P.cert, T);
                  try {
                    u.cert = e.certificateFromAsn1(tt, true);
                  } catch {
                    u.cert = null, u.asn1 = tt;
                  }
                };
                break;
              default:
                var g = new Error("Unsupported PKCS#12 SafeBag type.");
                throw g.oid = u.type, g;
            }
            if (F !== void 0 && !t.validate(W, F, P, v)) {
              var g = new Error("Cannot read PKCS#12 " + F.name);
              throw g.errors = v, g;
            }
            z();
          }
          return k;
        }
        function C(A) {
          var T = {};
          if (A !== void 0) for (var h = 0; h < A.length; ++h) {
            var k = {}, S = [];
            if (!t.validate(A[h], s, k, S)) {
              var N = new Error("Cannot read PKCS#12 BagAttribute.");
              throw N.errors = S, N;
            }
            var P = t.derToOid(k.oid);
            if (e.oids[P] !== void 0) {
              T[e.oids[P]] = [];
              for (var v = 0; v < k.values.length; ++v) T[e.oids[P]].push(k.values[v].value);
            }
          }
          return T;
        }
        return a.toPkcs12Asn1 = function(A, T, h, k) {
          k = k || {}, k.saltSize = k.saltSize || 8, k.count = k.count || 2048, k.algorithm = k.algorithm || k.encAlgorithm || "aes128", "useMac" in k || (k.useMac = true), "localKeyId" in k || (k.localKeyId = null), "generateLocalKeyId" in k || (k.generateLocalKeyId = true);
          var S = k.localKeyId, N;
          if (S !== null) S = d.util.hexToBytes(S);
          else if (k.generateLocalKeyId) if (T) {
            var P = d.util.isArray(T) ? T[0] : T;
            typeof P == "string" && (P = e.certificateFromPem(P));
            var v = d.md.sha1.create();
            v.update(t.toDer(e.certificateToAsn1(P)).getBytes()), S = v.digest().getBytes();
          } else S = d.random.getBytes(20);
          var g = [];
          S !== null && g.push(t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
            t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(e.oids.localKeyId).getBytes()),
            t.create(t.Class.UNIVERSAL, t.Type.SET, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, S)
            ])
          ])), "friendlyName" in k && g.push(t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
            t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(e.oids.friendlyName).getBytes()),
            t.create(t.Class.UNIVERSAL, t.Type.SET, true, [
              t.create(t.Class.UNIVERSAL, t.Type.BMPSTRING, false, k.friendlyName)
            ])
          ])), g.length > 0 && (N = t.create(t.Class.UNIVERSAL, t.Type.SET, true, g));
          var u = [], F = [];
          T !== null && (d.util.isArray(T) ? F = T : F = [
            T
          ]);
          for (var z = [], W = 0; W < F.length; ++W) {
            T = F[W], typeof T == "string" && (T = e.certificateFromPem(T));
            var M = W === 0 ? N : void 0, Y = e.certificateToAsn1(T), tt = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(e.oids.certBag).getBytes()),
              t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
                t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
                  t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(e.oids.x509Certificate).getBytes()),
                  t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
                    t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, t.toDer(Y).getBytes())
                  ])
                ])
              ]),
              M
            ]);
            z.push(tt);
          }
          if (z.length > 0) {
            var Z = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, z), ot = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(e.oids.data).getBytes()),
              t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
                t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, t.toDer(Z).getBytes())
              ])
            ]);
            u.push(ot);
          }
          var ct = null;
          if (A !== null) {
            var pt = e.wrapRsaPrivateKey(e.privateKeyToAsn1(A));
            h === null ? ct = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(e.oids.keyBag).getBytes()),
              t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
                pt
              ]),
              N
            ]) : ct = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(e.oids.pkcs8ShroudedKeyBag).getBytes()),
              t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
                e.encryptPrivateKeyInfo(pt, h, k)
              ]),
              N
            ]);
            var wt = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              ct
            ]), yt = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(e.oids.data).getBytes()),
              t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
                t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, t.toDer(wt).getBytes())
              ])
            ]);
            u.push(yt);
          }
          var St = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, u), Bt;
          if (k.useMac) {
            var v = d.md.sha1.create(), Kt = new d.util.ByteBuffer(d.random.getBytes(k.saltSize)), rt = k.count, A = a.generateKey(h, Kt, 3, rt, 20), Tt = d.hmac.create();
            Tt.start(v, A), Tt.update(t.toDer(St).getBytes());
            var gt = Tt.getMac();
            Bt = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
                t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
                  t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(e.oids.sha1).getBytes()),
                  t.create(t.Class.UNIVERSAL, t.Type.NULL, false, "")
                ]),
                t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, gt.getBytes())
              ]),
              t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, Kt.getBytes()),
              t.create(t.Class.UNIVERSAL, t.Type.INTEGER, false, t.integerToDer(rt).getBytes())
            ]);
          }
          return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
            t.create(t.Class.UNIVERSAL, t.Type.INTEGER, false, t.integerToDer(3).getBytes()),
            t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(e.oids.data).getBytes()),
              t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
                t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, t.toDer(St).getBytes())
              ])
            ]),
            Bt
          ]);
        }, a.generateKey = d.pbe.generatePkcs12Key, Ha.exports;
      }
      var nd;
      function _l() {
        if (nd) return La.exports;
        nd = 1;
        var d = Lt();
        gr(), gn(), Zd(), Cn(), xo(), rl(), Eo(), fa(), Ut(), Co();
        var t = d.asn1, e = La.exports = d.pki = d.pki || {};
        return e.pemToDer = function(a) {
          var n = d.pem.decode(a)[0];
          if (n.procType && n.procType.type === "ENCRYPTED") throw new Error("Could not convert PEM to DER; PEM is encrypted.");
          return d.util.createBuffer(n.body);
        }, e.privateKeyFromPem = function(a) {
          var n = d.pem.decode(a)[0];
          if (n.type !== "PRIVATE KEY" && n.type !== "RSA PRIVATE KEY") {
            var _ = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
            throw _.headerType = n.type, _;
          }
          if (n.procType && n.procType.type === "ENCRYPTED") throw new Error("Could not convert private key from PEM; PEM is encrypted.");
          var c = t.fromDer(n.body);
          return e.privateKeyFromAsn1(c);
        }, e.privateKeyToPem = function(a, n) {
          var _ = {
            type: "RSA PRIVATE KEY",
            body: t.toDer(e.privateKeyToAsn1(a)).getBytes()
          };
          return d.pem.encode(_, {
            maxline: n
          });
        }, e.privateKeyInfoToPem = function(a, n) {
          var _ = {
            type: "PRIVATE KEY",
            body: t.toDer(a).getBytes()
          };
          return d.pem.encode(_, {
            maxline: n
          });
        }, La.exports;
      }
      var Xa, ad;
      function nl() {
        if (ad) return Xa;
        ad = 1;
        var d = Lt();
        gr(), Dn(), mo(), Cn(), _l(), ar(), Pn(), Ut();
        var t = function(x, m, E, f) {
          var I = d.util.createBuffer(), D = x.length >> 1, L = D + (x.length & 1), $ = x.substr(0, L), Q = x.substr(D, L), X = d.util.createBuffer(), G = d.hmac.create();
          E = m + E;
          var J = Math.ceil(f / 16), at = Math.ceil(f / 20);
          G.start("MD5", $);
          var ft = d.util.createBuffer();
          X.putBytes(E);
          for (var ut = 0; ut < J; ++ut) G.start(null, null), G.update(X.getBytes()), X.putBuffer(G.digest()), G.start(null, null), G.update(X.bytes() + E), ft.putBuffer(G.digest());
          G.start("SHA1", Q);
          var kt = d.util.createBuffer();
          X.clear(), X.putBytes(E);
          for (var ut = 0; ut < at; ++ut) G.start(null, null), G.update(X.getBytes()), X.putBuffer(G.digest()), G.start(null, null), G.update(X.bytes() + E), kt.putBuffer(G.digest());
          return I.putBytes(d.util.xorBytes(ft.getBytes(), kt.getBytes(), f)), I;
        }, e = function(x, m, E) {
          var f = d.hmac.create();
          f.start("SHA1", x);
          var I = d.util.createBuffer();
          return I.putInt32(m[0]), I.putInt32(m[1]), I.putByte(E.type), I.putByte(E.version.major), I.putByte(E.version.minor), I.putInt16(E.length), I.putBytes(E.fragment.bytes()), f.update(I.getBytes()), f.digest().getBytes();
        }, a = function(x, m, E) {
          var f = false;
          try {
            var I = x.deflate(m.fragment.getBytes());
            m.fragment = d.util.createBuffer(I), m.length = I.length, f = true;
          } catch {
          }
          return f;
        }, n = function(x, m, E) {
          var f = false;
          try {
            var I = x.inflate(m.fragment.getBytes());
            m.fragment = d.util.createBuffer(I), m.length = I.length, f = true;
          } catch {
          }
          return f;
        }, _ = function(x, m) {
          var E = 0;
          switch (m) {
            case 1:
              E = x.getByte();
              break;
            case 2:
              E = x.getInt16();
              break;
            case 3:
              E = x.getInt24();
              break;
            case 4:
              E = x.getInt32();
              break;
          }
          return d.util.createBuffer(x.getBytes(E));
        }, c = function(x, m, E) {
          x.putInt(E.length(), m << 3), x.putBuffer(E);
        }, s = {};
        s.Versions = {
          TLS_1_0: {
            major: 3,
            minor: 1
          },
          TLS_1_1: {
            major: 3,
            minor: 2
          },
          TLS_1_2: {
            major: 3,
            minor: 3
          }
        }, s.SupportedVersions = [
          s.Versions.TLS_1_1,
          s.Versions.TLS_1_0
        ], s.Version = s.SupportedVersions[0], s.MaxFragment = 15360, s.ConnectionEnd = {
          server: 0,
          client: 1
        }, s.PRFAlgorithm = {
          tls_prf_sha256: 0
        }, s.BulkCipherAlgorithm = {
          none: null,
          rc4: 0,
          des3: 1,
          aes: 2
        }, s.CipherType = {
          stream: 0,
          block: 1,
          aead: 2
        }, s.MACAlgorithm = {
          none: null,
          hmac_md5: 0,
          hmac_sha1: 1,
          hmac_sha256: 2,
          hmac_sha384: 3,
          hmac_sha512: 4
        }, s.CompressionMethod = {
          none: 0,
          deflate: 1
        }, s.ContentType = {
          change_cipher_spec: 20,
          alert: 21,
          handshake: 22,
          application_data: 23,
          heartbeat: 24
        }, s.HandshakeType = {
          hello_request: 0,
          client_hello: 1,
          server_hello: 2,
          certificate: 11,
          server_key_exchange: 12,
          certificate_request: 13,
          server_hello_done: 14,
          certificate_verify: 15,
          client_key_exchange: 16,
          finished: 20
        }, s.Alert = {}, s.Alert.Level = {
          warning: 1,
          fatal: 2
        }, s.Alert.Description = {
          close_notify: 0,
          unexpected_message: 10,
          bad_record_mac: 20,
          decryption_failed: 21,
          record_overflow: 22,
          decompression_failure: 30,
          handshake_failure: 40,
          bad_certificate: 42,
          unsupported_certificate: 43,
          certificate_revoked: 44,
          certificate_expired: 45,
          certificate_unknown: 46,
          illegal_parameter: 47,
          unknown_ca: 48,
          access_denied: 49,
          decode_error: 50,
          decrypt_error: 51,
          export_restriction: 60,
          protocol_version: 70,
          insufficient_security: 71,
          internal_error: 80,
          user_canceled: 90,
          no_renegotiation: 100
        }, s.HeartbeatMessageType = {
          heartbeat_request: 1,
          heartbeat_response: 2
        }, s.CipherSuites = {}, s.getCipherSuite = function(x) {
          var m = null;
          for (var E in s.CipherSuites) {
            var f = s.CipherSuites[E];
            if (f.id[0] === x.charCodeAt(0) && f.id[1] === x.charCodeAt(1)) {
              m = f;
              break;
            }
          }
          return m;
        }, s.handleUnexpected = function(x, m) {
          var E = !x.open && x.entity === s.ConnectionEnd.client;
          E || x.error(x, {
            message: "Unexpected message. Received TLS record out of order.",
            send: true,
            alert: {
              level: s.Alert.Level.fatal,
              description: s.Alert.Description.unexpected_message
            }
          });
        }, s.handleHelloRequest = function(x, m, E) {
          !x.handshaking && x.handshakes > 0 && (s.queue(x, s.createAlert(x, {
            level: s.Alert.Level.warning,
            description: s.Alert.Description.no_renegotiation
          })), s.flush(x)), x.process();
        }, s.parseHelloMessage = function(x, m, E) {
          var f = null, I = x.entity === s.ConnectionEnd.client;
          if (E < 38) x.error(x, {
            message: I ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
            send: true,
            alert: {
              level: s.Alert.Level.fatal,
              description: s.Alert.Description.illegal_parameter
            }
          });
          else {
            var D = m.fragment, L = D.length();
            if (f = {
              version: {
                major: D.getByte(),
                minor: D.getByte()
              },
              random: d.util.createBuffer(D.getBytes(32)),
              session_id: _(D, 1),
              extensions: []
            }, I ? (f.cipher_suite = D.getBytes(2), f.compression_method = D.getByte()) : (f.cipher_suites = _(D, 2), f.compression_methods = _(D, 1)), L = E - (L - D.length()), L > 0) {
              for (var $ = _(D, 2); $.length() > 0; ) f.extensions.push({
                type: [
                  $.getByte(),
                  $.getByte()
                ],
                data: _($, 2)
              });
              if (!I) for (var Q = 0; Q < f.extensions.length; ++Q) {
                var X = f.extensions[Q];
                if (X.type[0] === 0 && X.type[1] === 0) for (var G = _(X.data, 2); G.length() > 0; ) {
                  var J = G.getByte();
                  if (J !== 0) break;
                  x.session.extensions.server_name.serverNameList.push(_(G, 2).getBytes());
                }
              }
            }
            if (x.session.version && (f.version.major !== x.session.version.major || f.version.minor !== x.session.version.minor)) return x.error(x, {
              message: "TLS version change is disallowed during renegotiation.",
              send: true,
              alert: {
                level: s.Alert.Level.fatal,
                description: s.Alert.Description.protocol_version
              }
            });
            if (I) x.session.cipherSuite = s.getCipherSuite(f.cipher_suite);
            else for (var at = d.util.createBuffer(f.cipher_suites.bytes()); at.length() > 0 && (x.session.cipherSuite = s.getCipherSuite(at.getBytes(2)), x.session.cipherSuite === null); ) ;
            if (x.session.cipherSuite === null) return x.error(x, {
              message: "No cipher suites in common.",
              send: true,
              alert: {
                level: s.Alert.Level.fatal,
                description: s.Alert.Description.handshake_failure
              },
              cipherSuite: d.util.bytesToHex(f.cipher_suite)
            });
            I ? x.session.compressionMethod = f.compression_method : x.session.compressionMethod = s.CompressionMethod.none;
          }
          return f;
        }, s.createSecurityParameters = function(x, m) {
          var E = x.entity === s.ConnectionEnd.client, f = m.random.bytes(), I = E ? x.session.sp.client_random : f, D = E ? f : s.createRandom().getBytes();
          x.session.sp = {
            entity: x.entity,
            prf_algorithm: s.PRFAlgorithm.tls_prf_sha256,
            bulk_cipher_algorithm: null,
            cipher_type: null,
            enc_key_length: null,
            block_length: null,
            fixed_iv_length: null,
            record_iv_length: null,
            mac_algorithm: null,
            mac_length: null,
            mac_key_length: null,
            compression_algorithm: x.session.compressionMethod,
            pre_master_secret: null,
            master_secret: null,
            client_random: I,
            server_random: D
          };
        }, s.handleServerHello = function(x, m, E) {
          var f = s.parseHelloMessage(x, m, E);
          if (!x.fail) {
            if (f.version.minor <= x.version.minor) x.version.minor = f.version.minor;
            else return x.error(x, {
              message: "Incompatible TLS version.",
              send: true,
              alert: {
                level: s.Alert.Level.fatal,
                description: s.Alert.Description.protocol_version
              }
            });
            x.session.version = x.version;
            var I = f.session_id.bytes();
            I.length > 0 && I === x.session.id ? (x.expect = b, x.session.resuming = true, x.session.sp.server_random = f.random.bytes()) : (x.expect = l, x.session.resuming = false, s.createSecurityParameters(x, f)), x.session.id = I, x.process();
          }
        }, s.handleClientHello = function(x, m, E) {
          var f = s.parseHelloMessage(x, m, E);
          if (!x.fail) {
            var I = f.session_id.bytes(), D = null;
            if (x.sessionCache && (D = x.sessionCache.getSession(I), D === null ? I = "" : (D.version.major !== f.version.major || D.version.minor > f.version.minor) && (D = null, I = "")), I.length === 0 && (I = d.random.getBytes(32)), x.session.id = I, x.session.clientHelloVersion = f.version, x.session.sp = {}, D) x.version = x.session.version = D.version, x.session.sp = D.sp;
            else {
              for (var L, $ = 1; $ < s.SupportedVersions.length && (L = s.SupportedVersions[$], !(L.minor <= f.version.minor)); ++$) ;
              x.version = {
                major: L.major,
                minor: L.minor
              }, x.session.version = x.version;
            }
            D !== null ? (x.expect = P, x.session.resuming = true, x.session.sp.client_random = f.random.bytes()) : (x.expect = x.verifyClient !== false ? k : S, x.session.resuming = false, s.createSecurityParameters(x, f)), x.open = true, s.queue(x, s.createRecord(x, {
              type: s.ContentType.handshake,
              data: s.createServerHello(x)
            })), x.session.resuming ? (s.queue(x, s.createRecord(x, {
              type: s.ContentType.change_cipher_spec,
              data: s.createChangeCipherSpec()
            })), x.state.pending = s.createConnectionState(x), x.state.current.write = x.state.pending.write, s.queue(x, s.createRecord(x, {
              type: s.ContentType.handshake,
              data: s.createFinished(x)
            }))) : (s.queue(x, s.createRecord(x, {
              type: s.ContentType.handshake,
              data: s.createCertificate(x)
            })), x.fail || (s.queue(x, s.createRecord(x, {
              type: s.ContentType.handshake,
              data: s.createServerKeyExchange(x)
            })), x.verifyClient !== false && s.queue(x, s.createRecord(x, {
              type: s.ContentType.handshake,
              data: s.createCertificateRequest(x)
            })), s.queue(x, s.createRecord(x, {
              type: s.ContentType.handshake,
              data: s.createServerHelloDone(x)
            })))), s.flush(x), x.process();
          }
        }, s.handleCertificate = function(x, m, E) {
          if (E < 3) return x.error(x, {
            message: "Invalid Certificate message. Message too short.",
            send: true,
            alert: {
              level: s.Alert.Level.fatal,
              description: s.Alert.Description.illegal_parameter
            }
          });
          var f = m.fragment, I = {
            certificate_list: _(f, 3)
          }, D, L, $ = [];
          try {
            for (; I.certificate_list.length() > 0; ) D = _(I.certificate_list, 3), L = d.asn1.fromDer(D), D = d.pki.certificateFromAsn1(L, true), $.push(D);
          } catch (X) {
            return x.error(x, {
              message: "Could not parse certificate list.",
              cause: X,
              send: true,
              alert: {
                level: s.Alert.Level.fatal,
                description: s.Alert.Description.bad_certificate
              }
            });
          }
          var Q = x.entity === s.ConnectionEnd.client;
          (Q || x.verifyClient === true) && $.length === 0 ? x.error(x, {
            message: Q ? "No server certificate provided." : "No client certificate provided.",
            send: true,
            alert: {
              level: s.Alert.Level.fatal,
              description: s.Alert.Description.illegal_parameter
            }
          }) : $.length === 0 ? x.expect = Q ? y : S : (Q ? x.session.serverCertificate = $[0] : x.session.clientCertificate = $[0], s.verifyCertificateChain(x, $) && (x.expect = Q ? y : S)), x.process();
        }, s.handleServerKeyExchange = function(x, m, E) {
          if (E > 0) return x.error(x, {
            message: "Invalid key parameters. Only RSA is supported.",
            send: true,
            alert: {
              level: s.Alert.Level.fatal,
              description: s.Alert.Description.unsupported_certificate
            }
          });
          x.expect = R, x.process();
        }, s.handleClientKeyExchange = function(x, m, E) {
          if (E < 48) return x.error(x, {
            message: "Invalid key parameters. Only RSA is supported.",
            send: true,
            alert: {
              level: s.Alert.Level.fatal,
              description: s.Alert.Description.unsupported_certificate
            }
          });
          var f = m.fragment, I = {
            enc_pre_master_secret: _(f, 2).getBytes()
          }, D = null;
          if (x.getPrivateKey) try {
            D = x.getPrivateKey(x, x.session.serverCertificate), D = d.pki.privateKeyFromPem(D);
          } catch (Q) {
            x.error(x, {
              message: "Could not get private key.",
              cause: Q,
              send: true,
              alert: {
                level: s.Alert.Level.fatal,
                description: s.Alert.Description.internal_error
              }
            });
          }
          if (D === null) return x.error(x, {
            message: "No private key set.",
            send: true,
            alert: {
              level: s.Alert.Level.fatal,
              description: s.Alert.Description.internal_error
            }
          });
          try {
            var L = x.session.sp;
            L.pre_master_secret = D.decrypt(I.enc_pre_master_secret);
            var $ = x.session.clientHelloVersion;
            if ($.major !== L.pre_master_secret.charCodeAt(0) || $.minor !== L.pre_master_secret.charCodeAt(1)) throw new Error("TLS version rollback attack detected.");
          } catch {
            L.pre_master_secret = d.random.getBytes(48);
          }
          x.expect = P, x.session.clientCertificate !== null && (x.expect = N), x.process();
        }, s.handleCertificateRequest = function(x, m, E) {
          if (E < 3) return x.error(x, {
            message: "Invalid CertificateRequest. Message too short.",
            send: true,
            alert: {
              level: s.Alert.Level.fatal,
              description: s.Alert.Description.illegal_parameter
            }
          });
          var f = m.fragment, I = {
            certificate_types: _(f, 1),
            certificate_authorities: _(f, 2)
          };
          x.session.certificateRequest = I, x.expect = j, x.process();
        }, s.handleCertificateVerify = function(x, m, E) {
          if (E < 2) return x.error(x, {
            message: "Invalid CertificateVerify. Message too short.",
            send: true,
            alert: {
              level: s.Alert.Level.fatal,
              description: s.Alert.Description.illegal_parameter
            }
          });
          var f = m.fragment;
          f.read -= 4;
          var I = f.bytes();
          f.read += 4;
          var D = {
            signature: _(f, 2).getBytes()
          }, L = d.util.createBuffer();
          L.putBuffer(x.session.md5.digest()), L.putBuffer(x.session.sha1.digest()), L = L.getBytes();
          try {
            var $ = x.session.clientCertificate;
            if (!$.publicKey.verify(L, D.signature, "NONE")) throw new Error("CertificateVerify signature does not match.");
            x.session.md5.update(I), x.session.sha1.update(I);
          } catch {
            return x.error(x, {
              message: "Bad signature in CertificateVerify.",
              send: true,
              alert: {
                level: s.Alert.Level.fatal,
                description: s.Alert.Description.handshake_failure
              }
            });
          }
          x.expect = P, x.process();
        }, s.handleServerHelloDone = function(x, m, E) {
          if (E > 0) return x.error(x, {
            message: "Invalid ServerHelloDone message. Invalid length.",
            send: true,
            alert: {
              level: s.Alert.Level.fatal,
              description: s.Alert.Description.record_overflow
            }
          });
          if (x.serverCertificate === null) {
            var f = {
              message: "No server certificate provided. Not enough security.",
              send: true,
              alert: {
                level: s.Alert.Level.fatal,
                description: s.Alert.Description.insufficient_security
              }
            }, I = 0, D = x.verify(x, f.alert.description, I, []);
            if (D !== true) return (D || D === 0) && (typeof D == "object" && !d.util.isArray(D) ? (D.message && (f.message = D.message), D.alert && (f.alert.description = D.alert)) : typeof D == "number" && (f.alert.description = D)), x.error(x, f);
          }
          x.session.certificateRequest !== null && (m = s.createRecord(x, {
            type: s.ContentType.handshake,
            data: s.createCertificate(x)
          }), s.queue(x, m)), m = s.createRecord(x, {
            type: s.ContentType.handshake,
            data: s.createClientKeyExchange(x)
          }), s.queue(x, m), x.expect = T;
          var L = function($, Q) {
            $.session.certificateRequest !== null && $.session.clientCertificate !== null && s.queue($, s.createRecord($, {
              type: s.ContentType.handshake,
              data: s.createCertificateVerify($, Q)
            })), s.queue($, s.createRecord($, {
              type: s.ContentType.change_cipher_spec,
              data: s.createChangeCipherSpec()
            })), $.state.pending = s.createConnectionState($), $.state.current.write = $.state.pending.write, s.queue($, s.createRecord($, {
              type: s.ContentType.handshake,
              data: s.createFinished($)
            })), $.expect = b, s.flush($), $.process();
          };
          if (x.session.certificateRequest === null || x.session.clientCertificate === null) return L(x, null);
          s.getClientSignature(x, L);
        }, s.handleChangeCipherSpec = function(x, m) {
          if (m.fragment.getByte() !== 1) return x.error(x, {
            message: "Invalid ChangeCipherSpec message received.",
            send: true,
            alert: {
              level: s.Alert.Level.fatal,
              description: s.Alert.Description.illegal_parameter
            }
          });
          var E = x.entity === s.ConnectionEnd.client;
          (x.session.resuming && E || !x.session.resuming && !E) && (x.state.pending = s.createConnectionState(x)), x.state.current.read = x.state.pending.read, (!x.session.resuming && E || x.session.resuming && !E) && (x.state.pending = null), x.expect = E ? C : v, x.process();
        }, s.handleFinished = function(x, m, E) {
          var f = m.fragment;
          f.read -= 4;
          var I = f.bytes();
          f.read += 4;
          var D = m.fragment.getBytes();
          f = d.util.createBuffer(), f.putBuffer(x.session.md5.digest()), f.putBuffer(x.session.sha1.digest());
          var L = x.entity === s.ConnectionEnd.client, $ = L ? "server finished" : "client finished", Q = x.session.sp, X = 12, G = t;
          if (f = G(Q.master_secret, $, f.getBytes(), X), f.getBytes() !== D) return x.error(x, {
            message: "Invalid verify_data in Finished message.",
            send: true,
            alert: {
              level: s.Alert.Level.fatal,
              description: s.Alert.Description.decrypt_error
            }
          });
          x.session.md5.update(I), x.session.sha1.update(I), (x.session.resuming && L || !x.session.resuming && !L) && (s.queue(x, s.createRecord(x, {
            type: s.ContentType.change_cipher_spec,
            data: s.createChangeCipherSpec()
          })), x.state.current.write = x.state.pending.write, x.state.pending = null, s.queue(x, s.createRecord(x, {
            type: s.ContentType.handshake,
            data: s.createFinished(x)
          }))), x.expect = L ? A : g, x.handshaking = false, ++x.handshakes, x.peerCertificate = L ? x.session.serverCertificate : x.session.clientCertificate, s.flush(x), x.isConnected = true, x.connected(x), x.process();
        }, s.handleAlert = function(x, m) {
          var E = m.fragment, f = {
            level: E.getByte(),
            description: E.getByte()
          }, I;
          switch (f.description) {
            case s.Alert.Description.close_notify:
              I = "Connection closed.";
              break;
            case s.Alert.Description.unexpected_message:
              I = "Unexpected message.";
              break;
            case s.Alert.Description.bad_record_mac:
              I = "Bad record MAC.";
              break;
            case s.Alert.Description.decryption_failed:
              I = "Decryption failed.";
              break;
            case s.Alert.Description.record_overflow:
              I = "Record overflow.";
              break;
            case s.Alert.Description.decompression_failure:
              I = "Decompression failed.";
              break;
            case s.Alert.Description.handshake_failure:
              I = "Handshake failure.";
              break;
            case s.Alert.Description.bad_certificate:
              I = "Bad certificate.";
              break;
            case s.Alert.Description.unsupported_certificate:
              I = "Unsupported certificate.";
              break;
            case s.Alert.Description.certificate_revoked:
              I = "Certificate revoked.";
              break;
            case s.Alert.Description.certificate_expired:
              I = "Certificate expired.";
              break;
            case s.Alert.Description.certificate_unknown:
              I = "Certificate unknown.";
              break;
            case s.Alert.Description.illegal_parameter:
              I = "Illegal parameter.";
              break;
            case s.Alert.Description.unknown_ca:
              I = "Unknown certificate authority.";
              break;
            case s.Alert.Description.access_denied:
              I = "Access denied.";
              break;
            case s.Alert.Description.decode_error:
              I = "Decode error.";
              break;
            case s.Alert.Description.decrypt_error:
              I = "Decrypt error.";
              break;
            case s.Alert.Description.export_restriction:
              I = "Export restriction.";
              break;
            case s.Alert.Description.protocol_version:
              I = "Unsupported protocol version.";
              break;
            case s.Alert.Description.insufficient_security:
              I = "Insufficient security.";
              break;
            case s.Alert.Description.internal_error:
              I = "Internal error.";
              break;
            case s.Alert.Description.user_canceled:
              I = "User canceled.";
              break;
            case s.Alert.Description.no_renegotiation:
              I = "Renegotiation not supported.";
              break;
            default:
              I = "Unknown error.";
              break;
          }
          if (f.description === s.Alert.Description.close_notify) return x.close();
          x.error(x, {
            message: I,
            send: false,
            origin: x.entity === s.ConnectionEnd.client ? "server" : "client",
            alert: f
          }), x.process();
        }, s.handleHandshake = function(x, m) {
          var E = m.fragment, f = E.getByte(), I = E.getInt24();
          if (I > E.length()) return x.fragmented = m, m.fragment = d.util.createBuffer(), E.read -= 4, x.process();
          x.fragmented = null, E.read -= 4;
          var D = E.bytes(I + 4);
          E.read += 4, f in Bt[x.entity][x.expect] ? (x.entity === s.ConnectionEnd.server && !x.open && !x.fail && (x.handshaking = true, x.session = {
            version: null,
            extensions: {
              server_name: {
                serverNameList: []
              }
            },
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            clientCertificate: null,
            md5: d.md.md5.create(),
            sha1: d.md.sha1.create()
          }), f !== s.HandshakeType.hello_request && f !== s.HandshakeType.certificate_verify && f !== s.HandshakeType.finished && (x.session.md5.update(D), x.session.sha1.update(D)), Bt[x.entity][x.expect][f](x, m, I)) : s.handleUnexpected(x, m);
        }, s.handleApplicationData = function(x, m) {
          x.data.putBuffer(m.fragment), x.dataReady(x), x.process();
        }, s.handleHeartbeat = function(x, m) {
          var E = m.fragment, f = E.getByte(), I = E.getInt16(), D = E.getBytes(I);
          if (f === s.HeartbeatMessageType.heartbeat_request) {
            if (x.handshaking || I > D.length) return x.process();
            s.queue(x, s.createRecord(x, {
              type: s.ContentType.heartbeat,
              data: s.createHeartbeat(s.HeartbeatMessageType.heartbeat_response, D)
            })), s.flush(x);
          } else if (f === s.HeartbeatMessageType.heartbeat_response) {
            if (D !== x.expectedHeartbeatPayload) return x.process();
            x.heartbeatReceived && x.heartbeatReceived(x, d.util.createBuffer(D));
          }
          x.process();
        };
        var p = 0, l = 1, y = 2, R = 3, j = 4, b = 5, C = 6, A = 7, T = 8, h = 0, k = 1, S = 2, N = 3, P = 4, v = 5, g = 6, u = s.handleUnexpected, F = s.handleChangeCipherSpec, z = s.handleAlert, W = s.handleHandshake, M = s.handleApplicationData, Y = s.handleHeartbeat, tt = [];
        tt[s.ConnectionEnd.client] = [
          [
            u,
            z,
            W,
            u,
            Y
          ],
          [
            u,
            z,
            W,
            u,
            Y
          ],
          [
            u,
            z,
            W,
            u,
            Y
          ],
          [
            u,
            z,
            W,
            u,
            Y
          ],
          [
            u,
            z,
            W,
            u,
            Y
          ],
          [
            F,
            z,
            u,
            u,
            Y
          ],
          [
            u,
            z,
            W,
            u,
            Y
          ],
          [
            u,
            z,
            W,
            M,
            Y
          ],
          [
            u,
            z,
            W,
            u,
            Y
          ]
        ], tt[s.ConnectionEnd.server] = [
          [
            u,
            z,
            W,
            u,
            Y
          ],
          [
            u,
            z,
            W,
            u,
            Y
          ],
          [
            u,
            z,
            W,
            u,
            Y
          ],
          [
            u,
            z,
            W,
            u,
            Y
          ],
          [
            F,
            z,
            u,
            u,
            Y
          ],
          [
            u,
            z,
            W,
            u,
            Y
          ],
          [
            u,
            z,
            W,
            M,
            Y
          ],
          [
            u,
            z,
            W,
            u,
            Y
          ]
        ];
        var Z = s.handleHelloRequest, ot = s.handleServerHello, ct = s.handleCertificate, pt = s.handleServerKeyExchange, wt = s.handleCertificateRequest, yt = s.handleServerHelloDone, St = s.handleFinished, Bt = [];
        Bt[s.ConnectionEnd.client] = [
          [
            u,
            u,
            ot,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u
          ],
          [
            Z,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            ct,
            pt,
            wt,
            yt,
            u,
            u,
            u,
            u,
            u,
            u
          ],
          [
            Z,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            pt,
            wt,
            yt,
            u,
            u,
            u,
            u,
            u,
            u
          ],
          [
            Z,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            wt,
            yt,
            u,
            u,
            u,
            u,
            u,
            u
          ],
          [
            Z,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            yt,
            u,
            u,
            u,
            u,
            u,
            u
          ],
          [
            Z,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u
          ],
          [
            Z,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            St
          ],
          [
            Z,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u
          ],
          [
            Z,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u
          ]
        ];
        var Kt = s.handleClientHello, rt = s.handleClientKeyExchange, Tt = s.handleCertificateVerify;
        Bt[s.ConnectionEnd.server] = [
          [
            u,
            Kt,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u
          ],
          [
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            ct,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u
          ],
          [
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            rt,
            u,
            u,
            u,
            u
          ],
          [
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            Tt,
            u,
            u,
            u,
            u,
            u
          ],
          [
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u
          ],
          [
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            St
          ],
          [
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u
          ],
          [
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u,
            u
          ]
        ], s.generateKeys = function(x, m) {
          var E = t, f = m.client_random + m.server_random;
          x.session.resuming || (m.master_secret = E(m.pre_master_secret, "master secret", f, 48).bytes(), m.pre_master_secret = null), f = m.server_random + m.client_random;
          var I = 2 * m.mac_key_length + 2 * m.enc_key_length, D = x.version.major === s.Versions.TLS_1_0.major && x.version.minor === s.Versions.TLS_1_0.minor;
          D && (I += 2 * m.fixed_iv_length);
          var L = E(m.master_secret, "key expansion", f, I), $ = {
            client_write_MAC_key: L.getBytes(m.mac_key_length),
            server_write_MAC_key: L.getBytes(m.mac_key_length),
            client_write_key: L.getBytes(m.enc_key_length),
            server_write_key: L.getBytes(m.enc_key_length)
          };
          return D && ($.client_write_IV = L.getBytes(m.fixed_iv_length), $.server_write_IV = L.getBytes(m.fixed_iv_length)), $;
        }, s.createConnectionState = function(x) {
          var m = x.entity === s.ConnectionEnd.client, E = function() {
            var D = {
              sequenceNumber: [
                0,
                0
              ],
              macKey: null,
              macLength: 0,
              macFunction: null,
              cipherState: null,
              cipherFunction: function(L) {
                return true;
              },
              compressionState: null,
              compressFunction: function(L) {
                return true;
              },
              updateSequenceNumber: function() {
                D.sequenceNumber[1] === 4294967295 ? (D.sequenceNumber[1] = 0, ++D.sequenceNumber[0]) : ++D.sequenceNumber[1];
              }
            };
            return D;
          }, f = {
            read: E(),
            write: E()
          };
          if (f.read.update = function(D, L) {
            return f.read.cipherFunction(L, f.read) ? f.read.compressFunction(D, L, f.read) || D.error(D, {
              message: "Could not decompress record.",
              send: true,
              alert: {
                level: s.Alert.Level.fatal,
                description: s.Alert.Description.decompression_failure
              }
            }) : D.error(D, {
              message: "Could not decrypt record or bad MAC.",
              send: true,
              alert: {
                level: s.Alert.Level.fatal,
                description: s.Alert.Description.bad_record_mac
              }
            }), !D.fail;
          }, f.write.update = function(D, L) {
            return f.write.compressFunction(D, L, f.write) ? f.write.cipherFunction(L, f.write) || D.error(D, {
              message: "Could not encrypt record.",
              send: false,
              alert: {
                level: s.Alert.Level.fatal,
                description: s.Alert.Description.internal_error
              }
            }) : D.error(D, {
              message: "Could not compress record.",
              send: false,
              alert: {
                level: s.Alert.Level.fatal,
                description: s.Alert.Description.internal_error
              }
            }), !D.fail;
          }, x.session) {
            var I = x.session.sp;
            switch (x.session.cipherSuite.initSecurityParameters(I), I.keys = s.generateKeys(x, I), f.read.macKey = m ? I.keys.server_write_MAC_key : I.keys.client_write_MAC_key, f.write.macKey = m ? I.keys.client_write_MAC_key : I.keys.server_write_MAC_key, x.session.cipherSuite.initConnectionState(f, x, I), I.compression_algorithm) {
              case s.CompressionMethod.none:
                break;
              case s.CompressionMethod.deflate:
                f.read.compressFunction = n, f.write.compressFunction = a;
                break;
              default:
                throw new Error("Unsupported compression algorithm.");
            }
          }
          return f;
        }, s.createRandom = function() {
          var x = /* @__PURE__ */ new Date(), m = +x + x.getTimezoneOffset() * 6e4, E = d.util.createBuffer();
          return E.putInt32(m), E.putBytes(d.random.getBytes(28)), E;
        }, s.createRecord = function(x, m) {
          if (!m.data) return null;
          var E = {
            type: m.type,
            version: {
              major: x.version.major,
              minor: x.version.minor
            },
            length: m.data.length(),
            fragment: m.data
          };
          return E;
        }, s.createAlert = function(x, m) {
          var E = d.util.createBuffer();
          return E.putByte(m.level), E.putByte(m.description), s.createRecord(x, {
            type: s.ContentType.alert,
            data: E
          });
        }, s.createClientHello = function(x) {
          x.session.clientHelloVersion = {
            major: x.version.major,
            minor: x.version.minor
          };
          for (var m = d.util.createBuffer(), E = 0; E < x.cipherSuites.length; ++E) {
            var f = x.cipherSuites[E];
            m.putByte(f.id[0]), m.putByte(f.id[1]);
          }
          var I = m.length(), D = d.util.createBuffer();
          D.putByte(s.CompressionMethod.none);
          var L = D.length(), $ = d.util.createBuffer();
          if (x.virtualHost) {
            var Q = d.util.createBuffer();
            Q.putByte(0), Q.putByte(0);
            var X = d.util.createBuffer();
            X.putByte(0), c(X, 2, d.util.createBuffer(x.virtualHost));
            var G = d.util.createBuffer();
            c(G, 2, X), c(Q, 2, G), $.putBuffer(Q);
          }
          var J = $.length();
          J > 0 && (J += 2);
          var at = x.session.id, ft = at.length + 1 + 2 + 4 + 28 + 2 + I + 1 + L + J, ut = d.util.createBuffer();
          return ut.putByte(s.HandshakeType.client_hello), ut.putInt24(ft), ut.putByte(x.version.major), ut.putByte(x.version.minor), ut.putBytes(x.session.sp.client_random), c(ut, 1, d.util.createBuffer(at)), c(ut, 2, m), c(ut, 1, D), J > 0 && c(ut, 2, $), ut;
        }, s.createServerHello = function(x) {
          var m = x.session.id, E = m.length + 1 + 2 + 4 + 28 + 2 + 1, f = d.util.createBuffer();
          return f.putByte(s.HandshakeType.server_hello), f.putInt24(E), f.putByte(x.version.major), f.putByte(x.version.minor), f.putBytes(x.session.sp.server_random), c(f, 1, d.util.createBuffer(m)), f.putByte(x.session.cipherSuite.id[0]), f.putByte(x.session.cipherSuite.id[1]), f.putByte(x.session.compressionMethod), f;
        }, s.createCertificate = function(x) {
          var m = x.entity === s.ConnectionEnd.client, E = null;
          if (x.getCertificate) {
            var f;
            m ? f = x.session.certificateRequest : f = x.session.extensions.server_name.serverNameList, E = x.getCertificate(x, f);
          }
          var I = d.util.createBuffer();
          if (E !== null) try {
            d.util.isArray(E) || (E = [
              E
            ]);
            for (var D = null, L = 0; L < E.length; ++L) {
              var $ = d.pem.decode(E[L])[0];
              if ($.type !== "CERTIFICATE" && $.type !== "X509 CERTIFICATE" && $.type !== "TRUSTED CERTIFICATE") {
                var Q = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
                throw Q.headerType = $.type, Q;
              }
              if ($.procType && $.procType.type === "ENCRYPTED") throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
              var X = d.util.createBuffer($.body);
              D === null && (D = d.asn1.fromDer(X.bytes(), false));
              var G = d.util.createBuffer();
              c(G, 3, X), I.putBuffer(G);
            }
            E = d.pki.certificateFromAsn1(D), m ? x.session.clientCertificate = E : x.session.serverCertificate = E;
          } catch (ft) {
            return x.error(x, {
              message: "Could not send certificate list.",
              cause: ft,
              send: true,
              alert: {
                level: s.Alert.Level.fatal,
                description: s.Alert.Description.bad_certificate
              }
            });
          }
          var J = 3 + I.length(), at = d.util.createBuffer();
          return at.putByte(s.HandshakeType.certificate), at.putInt24(J), c(at, 3, I), at;
        }, s.createClientKeyExchange = function(x) {
          var m = d.util.createBuffer();
          m.putByte(x.session.clientHelloVersion.major), m.putByte(x.session.clientHelloVersion.minor), m.putBytes(d.random.getBytes(46));
          var E = x.session.sp;
          E.pre_master_secret = m.getBytes();
          var f = x.session.serverCertificate.publicKey;
          m = f.encrypt(E.pre_master_secret);
          var I = m.length + 2, D = d.util.createBuffer();
          return D.putByte(s.HandshakeType.client_key_exchange), D.putInt24(I), D.putInt16(m.length), D.putBytes(m), D;
        }, s.createServerKeyExchange = function(x) {
          var m = d.util.createBuffer();
          return m;
        }, s.getClientSignature = function(x, m) {
          var E = d.util.createBuffer();
          E.putBuffer(x.session.md5.digest()), E.putBuffer(x.session.sha1.digest()), E = E.getBytes(), x.getSignature = x.getSignature || function(f, I, D) {
            var L = null;
            if (f.getPrivateKey) try {
              L = f.getPrivateKey(f, f.session.clientCertificate), L = d.pki.privateKeyFromPem(L);
            } catch ($) {
              f.error(f, {
                message: "Could not get private key.",
                cause: $,
                send: true,
                alert: {
                  level: s.Alert.Level.fatal,
                  description: s.Alert.Description.internal_error
                }
              });
            }
            L === null ? f.error(f, {
              message: "No private key set.",
              send: true,
              alert: {
                level: s.Alert.Level.fatal,
                description: s.Alert.Description.internal_error
              }
            }) : I = L.sign(I, null), D(f, I);
          }, x.getSignature(x, E, m);
        }, s.createCertificateVerify = function(x, m) {
          var E = m.length + 2, f = d.util.createBuffer();
          return f.putByte(s.HandshakeType.certificate_verify), f.putInt24(E), f.putInt16(m.length), f.putBytes(m), f;
        }, s.createCertificateRequest = function(x) {
          var m = d.util.createBuffer();
          m.putByte(1);
          var E = d.util.createBuffer();
          for (var f in x.caStore.certs) {
            var I = x.caStore.certs[f], D = d.pki.distinguishedNameToAsn1(I.subject), L = d.asn1.toDer(D);
            E.putInt16(L.length()), E.putBuffer(L);
          }
          var $ = 1 + m.length() + 2 + E.length(), Q = d.util.createBuffer();
          return Q.putByte(s.HandshakeType.certificate_request), Q.putInt24($), c(Q, 1, m), c(Q, 2, E), Q;
        }, s.createServerHelloDone = function(x) {
          var m = d.util.createBuffer();
          return m.putByte(s.HandshakeType.server_hello_done), m.putInt24(0), m;
        }, s.createChangeCipherSpec = function() {
          var x = d.util.createBuffer();
          return x.putByte(1), x;
        }, s.createFinished = function(x) {
          var m = d.util.createBuffer();
          m.putBuffer(x.session.md5.digest()), m.putBuffer(x.session.sha1.digest());
          var E = x.entity === s.ConnectionEnd.client, f = x.session.sp, I = 12, D = t, L = E ? "client finished" : "server finished";
          m = D(f.master_secret, L, m.getBytes(), I);
          var $ = d.util.createBuffer();
          return $.putByte(s.HandshakeType.finished), $.putInt24(m.length()), $.putBuffer(m), $;
        }, s.createHeartbeat = function(x, m, E) {
          typeof E > "u" && (E = m.length);
          var f = d.util.createBuffer();
          f.putByte(x), f.putInt16(E), f.putBytes(m);
          var I = f.length(), D = Math.max(16, I - E - 3);
          return f.putBytes(d.random.getBytes(D)), f;
        }, s.queue = function(x, m) {
          if (m && !(m.fragment.length() === 0 && (m.type === s.ContentType.handshake || m.type === s.ContentType.alert || m.type === s.ContentType.change_cipher_spec))) {
            if (m.type === s.ContentType.handshake) {
              var E = m.fragment.bytes();
              x.session.md5.update(E), x.session.sha1.update(E), E = null;
            }
            var f;
            if (m.fragment.length() <= s.MaxFragment) f = [
              m
            ];
            else {
              f = [];
              for (var I = m.fragment.bytes(); I.length > s.MaxFragment; ) f.push(s.createRecord(x, {
                type: m.type,
                data: d.util.createBuffer(I.slice(0, s.MaxFragment))
              })), I = I.slice(s.MaxFragment);
              I.length > 0 && f.push(s.createRecord(x, {
                type: m.type,
                data: d.util.createBuffer(I)
              }));
            }
            for (var D = 0; D < f.length && !x.fail; ++D) {
              var L = f[D], $ = x.state.current.write;
              $.update(x, L) && x.records.push(L);
            }
          }
        }, s.flush = function(x) {
          for (var m = 0; m < x.records.length; ++m) {
            var E = x.records[m];
            x.tlsData.putByte(E.type), x.tlsData.putByte(E.version.major), x.tlsData.putByte(E.version.minor), x.tlsData.putInt16(E.fragment.length()), x.tlsData.putBuffer(x.records[m].fragment);
          }
          return x.records = [], x.tlsDataReady(x);
        };
        var gt = function(x) {
          switch (x) {
            case true:
              return true;
            case d.pki.certificateError.bad_certificate:
              return s.Alert.Description.bad_certificate;
            case d.pki.certificateError.unsupported_certificate:
              return s.Alert.Description.unsupported_certificate;
            case d.pki.certificateError.certificate_revoked:
              return s.Alert.Description.certificate_revoked;
            case d.pki.certificateError.certificate_expired:
              return s.Alert.Description.certificate_expired;
            case d.pki.certificateError.certificate_unknown:
              return s.Alert.Description.certificate_unknown;
            case d.pki.certificateError.unknown_ca:
              return s.Alert.Description.unknown_ca;
            default:
              return s.Alert.Description.bad_certificate;
          }
        }, ae = function(x) {
          switch (x) {
            case true:
              return true;
            case s.Alert.Description.bad_certificate:
              return d.pki.certificateError.bad_certificate;
            case s.Alert.Description.unsupported_certificate:
              return d.pki.certificateError.unsupported_certificate;
            case s.Alert.Description.certificate_revoked:
              return d.pki.certificateError.certificate_revoked;
            case s.Alert.Description.certificate_expired:
              return d.pki.certificateError.certificate_expired;
            case s.Alert.Description.certificate_unknown:
              return d.pki.certificateError.certificate_unknown;
            case s.Alert.Description.unknown_ca:
              return d.pki.certificateError.unknown_ca;
            default:
              return d.pki.certificateError.bad_certificate;
          }
        };
        s.verifyCertificateChain = function(x, m) {
          try {
            var E = {};
            for (var f in x.verifyOptions) E[f] = x.verifyOptions[f];
            E.verify = function(D, L, $) {
              var Q = gt(D), X = x.verify(x, D, L, $);
              if (X !== true) {
                if (typeof X == "object" && !d.util.isArray(X)) {
                  var G = new Error("The application rejected the certificate.");
                  throw G.send = true, G.alert = {
                    level: s.Alert.Level.fatal,
                    description: s.Alert.Description.bad_certificate
                  }, X.message && (G.message = X.message), X.alert && (G.alert.description = X.alert), G;
                }
                X !== D && (X = ae(X));
              }
              return X;
            }, d.pki.verifyCertificateChain(x.caStore, m, E);
          } catch (D) {
            var I = D;
            (typeof I != "object" || d.util.isArray(I)) && (I = {
              send: true,
              alert: {
                level: s.Alert.Level.fatal,
                description: gt(D)
              }
            }), "send" in I || (I.send = true), "alert" in I || (I.alert = {
              level: s.Alert.Level.fatal,
              description: gt(I.error)
            }), x.error(x, I);
          }
          return !x.fail;
        }, s.createSessionCache = function(x, m) {
          var E = null;
          if (x && x.getSession && x.setSession && x.order) E = x;
          else {
            E = {}, E.cache = x || {}, E.capacity = Math.max(m || 100, 1), E.order = [];
            for (var f in x) E.order.length <= m ? E.order.push(f) : delete x[f];
            E.getSession = function(I) {
              var D = null, L = null;
              if (I ? L = d.util.bytesToHex(I) : E.order.length > 0 && (L = E.order[0]), L !== null && L in E.cache) {
                D = E.cache[L], delete E.cache[L];
                for (var $ in E.order) if (E.order[$] === L) {
                  E.order.splice($, 1);
                  break;
                }
              }
              return D;
            }, E.setSession = function(I, D) {
              if (E.order.length === E.capacity) {
                var L = E.order.shift();
                delete E.cache[L];
              }
              var L = d.util.bytesToHex(I);
              E.order.push(L), E.cache[L] = D;
            };
          }
          return E;
        }, s.createConnection = function(x) {
          var m = null;
          x.caStore ? d.util.isArray(x.caStore) ? m = d.pki.createCaStore(x.caStore) : m = x.caStore : m = d.pki.createCaStore();
          var E = x.cipherSuites || null;
          if (E === null) {
            E = [];
            for (var f in s.CipherSuites) E.push(s.CipherSuites[f]);
          }
          var I = x.server ? s.ConnectionEnd.server : s.ConnectionEnd.client, D = x.sessionCache ? s.createSessionCache(x.sessionCache) : null, L = {
            version: {
              major: s.Version.major,
              minor: s.Version.minor
            },
            entity: I,
            sessionId: x.sessionId,
            caStore: m,
            sessionCache: D,
            cipherSuites: E,
            connected: x.connected,
            virtualHost: x.virtualHost || null,
            verifyClient: x.verifyClient || false,
            verify: x.verify || function(G, J, at, ft) {
              return J;
            },
            verifyOptions: x.verifyOptions || {},
            getCertificate: x.getCertificate || null,
            getPrivateKey: x.getPrivateKey || null,
            getSignature: x.getSignature || null,
            input: d.util.createBuffer(),
            tlsData: d.util.createBuffer(),
            data: d.util.createBuffer(),
            tlsDataReady: x.tlsDataReady,
            dataReady: x.dataReady,
            heartbeatReceived: x.heartbeatReceived,
            closed: x.closed,
            error: function(G, J) {
              J.origin = J.origin || (G.entity === s.ConnectionEnd.client ? "client" : "server"), J.send && (s.queue(G, s.createAlert(G, J.alert)), s.flush(G));
              var at = J.fatal !== false;
              at && (G.fail = true), x.error(G, J), at && G.close(false);
            },
            deflate: x.deflate || null,
            inflate: x.inflate || null
          };
          L.reset = function(G) {
            L.version = {
              major: s.Version.major,
              minor: s.Version.minor
            }, L.record = null, L.session = null, L.peerCertificate = null, L.state = {
              pending: null,
              current: null
            }, L.expect = L.entity === s.ConnectionEnd.client ? p : h, L.fragmented = null, L.records = [], L.open = false, L.handshakes = 0, L.handshaking = false, L.isConnected = false, L.fail = !(G || typeof G > "u"), L.input.clear(), L.tlsData.clear(), L.data.clear(), L.state.current = s.createConnectionState(L);
          }, L.reset();
          var $ = function(G, J) {
            var at = J.type - s.ContentType.change_cipher_spec, ft = tt[G.entity][G.expect];
            at in ft ? ft[at](G, J) : s.handleUnexpected(G, J);
          }, Q = function(G) {
            var J = 0, at = G.input, ft = at.length();
            if (ft < 5) J = 5 - ft;
            else {
              G.record = {
                type: at.getByte(),
                version: {
                  major: at.getByte(),
                  minor: at.getByte()
                },
                length: at.getInt16(),
                fragment: d.util.createBuffer(),
                ready: false
              };
              var ut = G.record.version.major === G.version.major;
              ut && G.session && G.session.version && (ut = G.record.version.minor === G.version.minor), ut || G.error(G, {
                message: "Incompatible TLS version.",
                send: true,
                alert: {
                  level: s.Alert.Level.fatal,
                  description: s.Alert.Description.protocol_version
                }
              });
            }
            return J;
          }, X = function(G) {
            var J = 0, at = G.input, ft = at.length();
            if (ft < G.record.length) J = G.record.length - ft;
            else {
              G.record.fragment.putBytes(at.getBytes(G.record.length)), at.compact();
              var ut = G.state.current.read;
              ut.update(G, G.record) && (G.fragmented !== null && (G.fragmented.type === G.record.type ? (G.fragmented.fragment.putBuffer(G.record.fragment), G.record = G.fragmented) : G.error(G, {
                message: "Invalid fragmented record.",
                send: true,
                alert: {
                  level: s.Alert.Level.fatal,
                  description: s.Alert.Description.unexpected_message
                }
              })), G.record.ready = true);
            }
            return J;
          };
          return L.handshake = function(G) {
            if (L.entity !== s.ConnectionEnd.client) L.error(L, {
              message: "Cannot initiate handshake as a server.",
              fatal: false
            });
            else if (L.handshaking) L.error(L, {
              message: "Handshake already in progress.",
              fatal: false
            });
            else {
              L.fail && !L.open && L.handshakes === 0 && (L.fail = false), L.handshaking = true, G = G || "";
              var J = null;
              G.length > 0 && (L.sessionCache && (J = L.sessionCache.getSession(G)), J === null && (G = "")), G.length === 0 && L.sessionCache && (J = L.sessionCache.getSession(), J !== null && (G = J.id)), L.session = {
                id: G,
                version: null,
                cipherSuite: null,
                compressionMethod: null,
                serverCertificate: null,
                certificateRequest: null,
                clientCertificate: null,
                sp: {},
                md5: d.md.md5.create(),
                sha1: d.md.sha1.create()
              }, J && (L.version = J.version, L.session.sp = J.sp), L.session.sp.client_random = s.createRandom().getBytes(), L.open = true, s.queue(L, s.createRecord(L, {
                type: s.ContentType.handshake,
                data: s.createClientHello(L)
              })), s.flush(L);
            }
          }, L.process = function(G) {
            var J = 0;
            return G && L.input.putBytes(G), L.fail || (L.record !== null && L.record.ready && L.record.fragment.isEmpty() && (L.record = null), L.record === null && (J = Q(L)), !L.fail && L.record !== null && !L.record.ready && (J = X(L)), !L.fail && L.record !== null && L.record.ready && $(L, L.record)), J;
          }, L.prepare = function(G) {
            return s.queue(L, s.createRecord(L, {
              type: s.ContentType.application_data,
              data: d.util.createBuffer(G)
            })), s.flush(L);
          }, L.prepareHeartbeatRequest = function(G, J) {
            return G instanceof d.util.ByteBuffer && (G = G.bytes()), typeof J > "u" && (J = G.length), L.expectedHeartbeatPayload = G, s.queue(L, s.createRecord(L, {
              type: s.ContentType.heartbeat,
              data: s.createHeartbeat(s.HeartbeatMessageType.heartbeat_request, G, J)
            })), s.flush(L);
          }, L.close = function(G) {
            if (!L.fail && L.sessionCache && L.session) {
              var J = {
                id: L.session.id,
                version: L.session.version,
                sp: L.session.sp
              };
              J.sp.keys = null, L.sessionCache.setSession(J.id, J);
            }
            L.open && (L.open = false, L.input.clear(), (L.isConnected || L.handshaking) && (L.isConnected = L.handshaking = false, s.queue(L, s.createAlert(L, {
              level: s.Alert.Level.warning,
              description: s.Alert.Description.close_notify
            })), s.flush(L)), L.closed(L)), L.reset(G);
          }, L;
        }, Xa = d.tls = d.tls || {};
        for (var Ct in s) typeof s[Ct] != "function" && (d.tls[Ct] = s[Ct]);
        return d.tls.prf_tls1 = t, d.tls.hmac_sha1 = e, d.tls.createSessionCache = s.createSessionCache, d.tls.createConnection = s.createConnection, Xa;
      }
      var od;
      function f$() {
        if (od) return Ta.exports;
        od = 1;
        var d = Lt();
        fn(), nl();
        var t = Ta.exports = d.tls;
        t.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
          id: [
            0,
            47
          ],
          name: "TLS_RSA_WITH_AES_128_CBC_SHA",
          initSecurityParameters: function(p) {
            p.bulk_cipher_algorithm = t.BulkCipherAlgorithm.aes, p.cipher_type = t.CipherType.block, p.enc_key_length = 16, p.block_length = 16, p.fixed_iv_length = 16, p.record_iv_length = 16, p.mac_algorithm = t.MACAlgorithm.hmac_sha1, p.mac_length = 20, p.mac_key_length = 20;
          },
          initConnectionState: e
        }, t.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
          id: [
            0,
            53
          ],
          name: "TLS_RSA_WITH_AES_256_CBC_SHA",
          initSecurityParameters: function(p) {
            p.bulk_cipher_algorithm = t.BulkCipherAlgorithm.aes, p.cipher_type = t.CipherType.block, p.enc_key_length = 32, p.block_length = 16, p.fixed_iv_length = 16, p.record_iv_length = 16, p.mac_algorithm = t.MACAlgorithm.hmac_sha1, p.mac_length = 20, p.mac_key_length = 20;
          },
          initConnectionState: e
        };
        function e(p, l, y) {
          var R = l.entity === d.tls.ConnectionEnd.client;
          p.read.cipherState = {
            init: false,
            cipher: d.cipher.createDecipher("AES-CBC", R ? y.keys.server_write_key : y.keys.client_write_key),
            iv: R ? y.keys.server_write_IV : y.keys.client_write_IV
          }, p.write.cipherState = {
            init: false,
            cipher: d.cipher.createCipher("AES-CBC", R ? y.keys.client_write_key : y.keys.server_write_key),
            iv: R ? y.keys.client_write_IV : y.keys.server_write_IV
          }, p.read.cipherFunction = c, p.write.cipherFunction = a, p.read.macLength = p.write.macLength = y.mac_length, p.read.macFunction = p.write.macFunction = t.hmac_sha1;
        }
        function a(p, l) {
          var y = false, R = l.macFunction(l.macKey, l.sequenceNumber, p);
          p.fragment.putBytes(R), l.updateSequenceNumber();
          var j;
          p.version.minor === t.Versions.TLS_1_0.minor ? j = l.cipherState.init ? null : l.cipherState.iv : j = d.random.getBytesSync(16), l.cipherState.init = true;
          var b = l.cipherState.cipher;
          return b.start({
            iv: j
          }), p.version.minor >= t.Versions.TLS_1_1.minor && b.output.putBytes(j), b.update(p.fragment), b.finish(n) && (p.fragment = b.output, p.length = p.fragment.length(), y = true), y;
        }
        function n(p, l, y) {
          if (!y) {
            var R = p - l.length() % p;
            l.fillWithByte(R - 1, R);
          }
          return true;
        }
        function _(p, l, y) {
          var R = true;
          if (y) {
            for (var j = l.length(), b = l.last(), C = j - 1 - b; C < j - 1; ++C) R = R && l.at(C) == b;
            R && l.truncate(b + 1);
          }
          return R;
        }
        function c(p, l) {
          var y = false, R;
          p.version.minor === t.Versions.TLS_1_0.minor ? R = l.cipherState.init ? null : l.cipherState.iv : R = p.fragment.getBytes(16), l.cipherState.init = true;
          var j = l.cipherState.cipher;
          j.start({
            iv: R
          }), j.update(p.fragment), y = j.finish(_);
          var b = l.macLength, C = d.random.getBytesSync(b), A = j.output.length();
          A >= b ? (p.fragment = j.output.getBytes(A - b), C = j.output.getBytes(b)) : p.fragment = j.output.getBytes(), p.fragment = d.util.createBuffer(p.fragment), p.length = p.fragment.length();
          var T = l.macFunction(l.macKey, l.sequenceNumber, p);
          return l.updateSequenceNumber(), y = s(l.macKey, C, T) && y, y;
        }
        function s(p, l, y) {
          var R = d.hmac.create();
          return R.start("SHA1", p), R.update(l), l = R.digest().getBytes(), R.start(null, null), R.update(y), y = R.digest().getBytes(), l === y;
        }
        return Ta.exports;
      }
      var Ja = {
        exports: {}
      }, sd;
      function al() {
        if (sd) return Ja.exports;
        sd = 1;
        var d = Lt();
        $r(), Ut();
        var t = Ja.exports = d.sha512 = d.sha512 || {};
        d.md.sha512 = d.md.algorithms.sha512 = t;
        var e = d.sha384 = d.sha512.sha384 = d.sha512.sha384 || {};
        e.create = function() {
          return t.create("SHA-384");
        }, d.md.sha384 = d.md.algorithms.sha384 = e, d.sha512.sha256 = d.sha512.sha256 || {
          create: function() {
            return t.create("SHA-512/256");
          }
        }, d.md["sha512/256"] = d.md.algorithms["sha512/256"] = d.sha512.sha256, d.sha512.sha224 = d.sha512.sha224 || {
          create: function() {
            return t.create("SHA-512/224");
          }
        }, d.md["sha512/224"] = d.md.algorithms["sha512/224"] = d.sha512.sha224, t.create = function(l) {
          if (n || s(), typeof l > "u" && (l = "SHA-512"), !(l in c)) throw new Error("Invalid SHA-512 algorithm: " + l);
          for (var y = c[l], R = null, j = d.util.createBuffer(), b = new Array(80), C = 0; C < 80; ++C) b[C] = new Array(2);
          var A = 64;
          switch (l) {
            case "SHA-384":
              A = 48;
              break;
            case "SHA-512/256":
              A = 32;
              break;
            case "SHA-512/224":
              A = 28;
              break;
          }
          var T = {
            algorithm: l.replace("-", "").toLowerCase(),
            blockLength: 128,
            digestLength: A,
            messageLength: 0,
            fullMessageLength: null,
            messageLengthSize: 16
          };
          return T.start = function() {
            T.messageLength = 0, T.fullMessageLength = T.messageLength128 = [];
            for (var h = T.messageLengthSize / 4, k = 0; k < h; ++k) T.fullMessageLength.push(0);
            j = d.util.createBuffer(), R = new Array(y.length);
            for (var k = 0; k < y.length; ++k) R[k] = y[k].slice(0);
            return T;
          }, T.start(), T.update = function(h, k) {
            k === "utf8" && (h = d.util.encodeUtf8(h));
            var S = h.length;
            T.messageLength += S, S = [
              S / 4294967296 >>> 0,
              S >>> 0
            ];
            for (var N = T.fullMessageLength.length - 1; N >= 0; --N) T.fullMessageLength[N] += S[1], S[1] = S[0] + (T.fullMessageLength[N] / 4294967296 >>> 0), T.fullMessageLength[N] = T.fullMessageLength[N] >>> 0, S[0] = S[1] / 4294967296 >>> 0;
            return j.putBytes(h), p(R, b, j), (j.read > 2048 || j.length() === 0) && j.compact(), T;
          }, T.digest = function() {
            var h = d.util.createBuffer();
            h.putBytes(j.bytes());
            var k = T.fullMessageLength[T.fullMessageLength.length - 1] + T.messageLengthSize, S = k & T.blockLength - 1;
            h.putBytes(a.substr(0, T.blockLength - S));
            for (var N, P, v = T.fullMessageLength[0] * 8, g = 0; g < T.fullMessageLength.length - 1; ++g) N = T.fullMessageLength[g + 1] * 8, P = N / 4294967296 >>> 0, v += P, h.putInt32(v >>> 0), v = N >>> 0;
            h.putInt32(v);
            for (var u = new Array(R.length), g = 0; g < R.length; ++g) u[g] = R[g].slice(0);
            p(u, b, h);
            var F = d.util.createBuffer(), z;
            l === "SHA-512" ? z = u.length : l === "SHA-384" ? z = u.length - 2 : z = u.length - 4;
            for (var g = 0; g < z; ++g) F.putInt32(u[g][0]), (g !== z - 1 || l !== "SHA-512/224") && F.putInt32(u[g][1]);
            return F;
          }, T;
        };
        var a = null, n = false, _ = null, c = null;
        function s() {
          a = "\x80", a += d.util.fillString("\0", 128), _ = [
            [
              1116352408,
              3609767458
            ],
            [
              1899447441,
              602891725
            ],
            [
              3049323471,
              3964484399
            ],
            [
              3921009573,
              2173295548
            ],
            [
              961987163,
              4081628472
            ],
            [
              1508970993,
              3053834265
            ],
            [
              2453635748,
              2937671579
            ],
            [
              2870763221,
              3664609560
            ],
            [
              3624381080,
              2734883394
            ],
            [
              310598401,
              1164996542
            ],
            [
              607225278,
              1323610764
            ],
            [
              1426881987,
              3590304994
            ],
            [
              1925078388,
              4068182383
            ],
            [
              2162078206,
              991336113
            ],
            [
              2614888103,
              633803317
            ],
            [
              3248222580,
              3479774868
            ],
            [
              3835390401,
              2666613458
            ],
            [
              4022224774,
              944711139
            ],
            [
              264347078,
              2341262773
            ],
            [
              604807628,
              2007800933
            ],
            [
              770255983,
              1495990901
            ],
            [
              1249150122,
              1856431235
            ],
            [
              1555081692,
              3175218132
            ],
            [
              1996064986,
              2198950837
            ],
            [
              2554220882,
              3999719339
            ],
            [
              2821834349,
              766784016
            ],
            [
              2952996808,
              2566594879
            ],
            [
              3210313671,
              3203337956
            ],
            [
              3336571891,
              1034457026
            ],
            [
              3584528711,
              2466948901
            ],
            [
              113926993,
              3758326383
            ],
            [
              338241895,
              168717936
            ],
            [
              666307205,
              1188179964
            ],
            [
              773529912,
              1546045734
            ],
            [
              1294757372,
              1522805485
            ],
            [
              1396182291,
              2643833823
            ],
            [
              1695183700,
              2343527390
            ],
            [
              1986661051,
              1014477480
            ],
            [
              2177026350,
              1206759142
            ],
            [
              2456956037,
              344077627
            ],
            [
              2730485921,
              1290863460
            ],
            [
              2820302411,
              3158454273
            ],
            [
              3259730800,
              3505952657
            ],
            [
              3345764771,
              106217008
            ],
            [
              3516065817,
              3606008344
            ],
            [
              3600352804,
              1432725776
            ],
            [
              4094571909,
              1467031594
            ],
            [
              275423344,
              851169720
            ],
            [
              430227734,
              3100823752
            ],
            [
              506948616,
              1363258195
            ],
            [
              659060556,
              3750685593
            ],
            [
              883997877,
              3785050280
            ],
            [
              958139571,
              3318307427
            ],
            [
              1322822218,
              3812723403
            ],
            [
              1537002063,
              2003034995
            ],
            [
              1747873779,
              3602036899
            ],
            [
              1955562222,
              1575990012
            ],
            [
              2024104815,
              1125592928
            ],
            [
              2227730452,
              2716904306
            ],
            [
              2361852424,
              442776044
            ],
            [
              2428436474,
              593698344
            ],
            [
              2756734187,
              3733110249
            ],
            [
              3204031479,
              2999351573
            ],
            [
              3329325298,
              3815920427
            ],
            [
              3391569614,
              3928383900
            ],
            [
              3515267271,
              566280711
            ],
            [
              3940187606,
              3454069534
            ],
            [
              4118630271,
              4000239992
            ],
            [
              116418474,
              1914138554
            ],
            [
              174292421,
              2731055270
            ],
            [
              289380356,
              3203993006
            ],
            [
              460393269,
              320620315
            ],
            [
              685471733,
              587496836
            ],
            [
              852142971,
              1086792851
            ],
            [
              1017036298,
              365543100
            ],
            [
              1126000580,
              2618297676
            ],
            [
              1288033470,
              3409855158
            ],
            [
              1501505948,
              4234509866
            ],
            [
              1607167915,
              987167468
            ],
            [
              1816402316,
              1246189591
            ]
          ], c = {}, c["SHA-512"] = [
            [
              1779033703,
              4089235720
            ],
            [
              3144134277,
              2227873595
            ],
            [
              1013904242,
              4271175723
            ],
            [
              2773480762,
              1595750129
            ],
            [
              1359893119,
              2917565137
            ],
            [
              2600822924,
              725511199
            ],
            [
              528734635,
              4215389547
            ],
            [
              1541459225,
              327033209
            ]
          ], c["SHA-384"] = [
            [
              3418070365,
              3238371032
            ],
            [
              1654270250,
              914150663
            ],
            [
              2438529370,
              812702999
            ],
            [
              355462360,
              4144912697
            ],
            [
              1731405415,
              4290775857
            ],
            [
              2394180231,
              1750603025
            ],
            [
              3675008525,
              1694076839
            ],
            [
              1203062813,
              3204075428
            ]
          ], c["SHA-512/256"] = [
            [
              573645204,
              4230739756
            ],
            [
              2673172387,
              3360449730
            ],
            [
              596883563,
              1867755857
            ],
            [
              2520282905,
              1497426621
            ],
            [
              2519219938,
              2827943907
            ],
            [
              3193839141,
              1401305490
            ],
            [
              721525244,
              746961066
            ],
            [
              246885852,
              2177182882
            ]
          ], c["SHA-512/224"] = [
            [
              2352822216,
              424955298
            ],
            [
              1944164710,
              2312950998
            ],
            [
              502970286,
              855612546
            ],
            [
              1738396948,
              1479516111
            ],
            [
              258812777,
              2077511080
            ],
            [
              2011393907,
              79989058
            ],
            [
              1067287976,
              1780299464
            ],
            [
              286451373,
              2446758561
            ]
          ], n = true;
        }
        function p(l, y, R) {
          for (var j, b, C, A, T, h, k, S, N, P, v, g, u, F, z, W, M, Y, tt, Z, ot, ct, pt, wt, yt, St, Bt, Kt, rt, Tt, gt, ae, Ct, x, m, E = R.length(); E >= 128; ) {
            for (rt = 0; rt < 16; ++rt) y[rt][0] = R.getInt32() >>> 0, y[rt][1] = R.getInt32() >>> 0;
            for (; rt < 80; ++rt) ae = y[rt - 2], Tt = ae[0], gt = ae[1], j = ((Tt >>> 19 | gt << 13) ^ (gt >>> 29 | Tt << 3) ^ Tt >>> 6) >>> 0, b = ((Tt << 13 | gt >>> 19) ^ (gt << 3 | Tt >>> 29) ^ (Tt << 26 | gt >>> 6)) >>> 0, x = y[rt - 15], Tt = x[0], gt = x[1], C = ((Tt >>> 1 | gt << 31) ^ (Tt >>> 8 | gt << 24) ^ Tt >>> 7) >>> 0, A = ((Tt << 31 | gt >>> 1) ^ (Tt << 24 | gt >>> 8) ^ (Tt << 25 | gt >>> 7)) >>> 0, Ct = y[rt - 7], m = y[rt - 16], gt = b + Ct[1] + A + m[1], y[rt][0] = j + Ct[0] + C + m[0] + (gt / 4294967296 >>> 0) >>> 0, y[rt][1] = gt >>> 0;
            for (u = l[0][0], F = l[0][1], z = l[1][0], W = l[1][1], M = l[2][0], Y = l[2][1], tt = l[3][0], Z = l[3][1], ot = l[4][0], ct = l[4][1], pt = l[5][0], wt = l[5][1], yt = l[6][0], St = l[6][1], Bt = l[7][0], Kt = l[7][1], rt = 0; rt < 80; ++rt) k = ((ot >>> 14 | ct << 18) ^ (ot >>> 18 | ct << 14) ^ (ct >>> 9 | ot << 23)) >>> 0, S = ((ot << 18 | ct >>> 14) ^ (ot << 14 | ct >>> 18) ^ (ct << 23 | ot >>> 9)) >>> 0, N = (yt ^ ot & (pt ^ yt)) >>> 0, P = (St ^ ct & (wt ^ St)) >>> 0, T = ((u >>> 28 | F << 4) ^ (F >>> 2 | u << 30) ^ (F >>> 7 | u << 25)) >>> 0, h = ((u << 4 | F >>> 28) ^ (F << 30 | u >>> 2) ^ (F << 25 | u >>> 7)) >>> 0, v = (u & z | M & (u ^ z)) >>> 0, g = (F & W | Y & (F ^ W)) >>> 0, gt = Kt + S + P + _[rt][1] + y[rt][1], j = Bt + k + N + _[rt][0] + y[rt][0] + (gt / 4294967296 >>> 0) >>> 0, b = gt >>> 0, gt = h + g, C = T + v + (gt / 4294967296 >>> 0) >>> 0, A = gt >>> 0, Bt = yt, Kt = St, yt = pt, St = wt, pt = ot, wt = ct, gt = Z + b, ot = tt + j + (gt / 4294967296 >>> 0) >>> 0, ct = gt >>> 0, tt = M, Z = Y, M = z, Y = W, z = u, W = F, gt = b + A, u = j + C + (gt / 4294967296 >>> 0) >>> 0, F = gt >>> 0;
            gt = l[0][1] + F, l[0][0] = l[0][0] + u + (gt / 4294967296 >>> 0) >>> 0, l[0][1] = gt >>> 0, gt = l[1][1] + W, l[1][0] = l[1][0] + z + (gt / 4294967296 >>> 0) >>> 0, l[1][1] = gt >>> 0, gt = l[2][1] + Y, l[2][0] = l[2][0] + M + (gt / 4294967296 >>> 0) >>> 0, l[2][1] = gt >>> 0, gt = l[3][1] + Z, l[3][0] = l[3][0] + tt + (gt / 4294967296 >>> 0) >>> 0, l[3][1] = gt >>> 0, gt = l[4][1] + ct, l[4][0] = l[4][0] + ot + (gt / 4294967296 >>> 0) >>> 0, l[4][1] = gt >>> 0, gt = l[5][1] + wt, l[5][0] = l[5][0] + pt + (gt / 4294967296 >>> 0) >>> 0, l[5][1] = gt >>> 0, gt = l[6][1] + St, l[6][0] = l[6][0] + yt + (gt / 4294967296 >>> 0) >>> 0, l[6][1] = gt >>> 0, gt = l[7][1] + Kt, l[7][0] = l[7][0] + Bt + (gt / 4294967296 >>> 0) >>> 0, l[7][1] = gt >>> 0, E -= 128;
          }
        }
        return Ja.exports;
      }
      var Qn = {}, id;
      function g$() {
        if (id) return Qn;
        id = 1;
        var d = Lt();
        gr();
        var t = d.asn1;
        return Qn.privateKeyValidator = {
          name: "PrivateKeyInfo",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "PrivateKeyInfo.version",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.INTEGER,
              constructed: false,
              capture: "privateKeyVersion"
            },
            {
              name: "PrivateKeyInfo.privateKeyAlgorithm",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "AlgorithmIdentifier.algorithm",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.OID,
                  constructed: false,
                  capture: "privateKeyOid"
                }
              ]
            },
            {
              name: "PrivateKeyInfo",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.OCTETSTRING,
              constructed: false,
              capture: "privateKey"
            }
          ]
        }, Qn.publicKeyValidator = {
          name: "SubjectPublicKeyInfo",
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "subjectPublicKeyInfo",
          value: [
            {
              name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "AlgorithmIdentifier.algorithm",
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.OID,
                  constructed: false,
                  capture: "publicKeyOid"
                }
              ]
            },
            {
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.BITSTRING,
              constructed: false,
              composed: true,
              captureBitStringValue: "ed25519PublicKey"
            }
          ]
        }, Qn;
      }
      var Za, cd;
      function w$() {
        if (cd) return Za;
        cd = 1;
        var d = Lt();
        ua(), ar(), al(), Ut();
        var t = g$(), e = t.publicKeyValidator, a = t.privateKeyValidator;
        if (typeof n > "u") var n = d.jsbn.BigInteger;
        var _ = d.util.ByteBuffer, c = typeof Buffer > "u" ? Uint8Array : Buffer;
        d.pki = d.pki || {}, Za = d.pki.ed25519 = d.ed25519 = d.ed25519 || {};
        var s = d.ed25519;
        s.constants = {}, s.constants.PUBLIC_KEY_BYTE_LENGTH = 32, s.constants.PRIVATE_KEY_BYTE_LENGTH = 64, s.constants.SEED_BYTE_LENGTH = 32, s.constants.SIGN_BYTE_LENGTH = 64, s.constants.HASH_BYTE_LENGTH = 64, s.generateKeyPair = function(x) {
          x = x || {};
          var m = x.seed;
          if (m === void 0) m = d.random.getBytesSync(s.constants.SEED_BYTE_LENGTH);
          else if (typeof m == "string") {
            if (m.length !== s.constants.SEED_BYTE_LENGTH) throw new TypeError('"seed" must be ' + s.constants.SEED_BYTE_LENGTH + " bytes in length.");
          } else if (!(m instanceof Uint8Array)) throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
          m = p({
            message: m,
            encoding: "binary"
          });
          for (var E = new c(s.constants.PUBLIC_KEY_BYTE_LENGTH), f = new c(s.constants.PRIVATE_KEY_BYTE_LENGTH), I = 0; I < 32; ++I) f[I] = m[I];
          return k(E, f), {
            publicKey: E,
            privateKey: f
          };
        }, s.privateKeyFromAsn1 = function(x) {
          var m = {}, E = [], f = d.asn1.validate(x, a, m, E);
          if (!f) {
            var I = new Error("Invalid Key.");
            throw I.errors = E, I;
          }
          var D = d.asn1.derToOid(m.privateKeyOid), L = d.oids.EdDSA25519;
          if (D !== L) throw new Error('Invalid OID "' + D + '"; OID must be "' + L + '".');
          var $ = m.privateKey, Q = p({
            message: d.asn1.fromDer($).value,
            encoding: "binary"
          });
          return {
            privateKeyBytes: Q
          };
        }, s.publicKeyFromAsn1 = function(x) {
          var m = {}, E = [], f = d.asn1.validate(x, e, m, E);
          if (!f) {
            var I = new Error("Invalid Key.");
            throw I.errors = E, I;
          }
          var D = d.asn1.derToOid(m.publicKeyOid), L = d.oids.EdDSA25519;
          if (D !== L) throw new Error('Invalid OID "' + D + '"; OID must be "' + L + '".');
          var $ = m.ed25519PublicKey;
          if ($.length !== s.constants.PUBLIC_KEY_BYTE_LENGTH) throw new Error("Key length is invalid.");
          return p({
            message: $,
            encoding: "binary"
          });
        }, s.publicKeyFromPrivateKey = function(x) {
          x = x || {};
          var m = p({
            message: x.privateKey,
            encoding: "binary"
          });
          if (m.length !== s.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError('"options.privateKey" must have a byte length of ' + s.constants.PRIVATE_KEY_BYTE_LENGTH);
          for (var E = new c(s.constants.PUBLIC_KEY_BYTE_LENGTH), f = 0; f < E.length; ++f) E[f] = m[32 + f];
          return E;
        }, s.sign = function(x) {
          x = x || {};
          var m = p(x), E = p({
            message: x.privateKey,
            encoding: "binary"
          });
          if (E.length === s.constants.SEED_BYTE_LENGTH) {
            var f = s.generateKeyPair({
              seed: E
            });
            E = f.privateKey;
          } else if (E.length !== s.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError('"options.privateKey" must have a byte length of ' + s.constants.SEED_BYTE_LENGTH + " or " + s.constants.PRIVATE_KEY_BYTE_LENGTH);
          var I = new c(s.constants.SIGN_BYTE_LENGTH + m.length);
          S(I, m, m.length, E);
          for (var D = new c(s.constants.SIGN_BYTE_LENGTH), L = 0; L < D.length; ++L) D[L] = I[L];
          return D;
        }, s.verify = function(x) {
          x = x || {};
          var m = p(x);
          if (x.signature === void 0) throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.');
          var E = p({
            message: x.signature,
            encoding: "binary"
          });
          if (E.length !== s.constants.SIGN_BYTE_LENGTH) throw new TypeError('"options.signature" must have a byte length of ' + s.constants.SIGN_BYTE_LENGTH);
          var f = p({
            message: x.publicKey,
            encoding: "binary"
          });
          if (f.length !== s.constants.PUBLIC_KEY_BYTE_LENGTH) throw new TypeError('"options.publicKey" must have a byte length of ' + s.constants.PUBLIC_KEY_BYTE_LENGTH);
          var I = new c(s.constants.SIGN_BYTE_LENGTH + m.length), D = new c(s.constants.SIGN_BYTE_LENGTH + m.length), L;
          for (L = 0; L < s.constants.SIGN_BYTE_LENGTH; ++L) I[L] = E[L];
          for (L = 0; L < m.length; ++L) I[L + s.constants.SIGN_BYTE_LENGTH] = m[L];
          return N(D, I, I.length, f) >= 0;
        };
        function p(x) {
          var m = x.message;
          if (m instanceof Uint8Array || m instanceof c) return m;
          var E = x.encoding;
          if (m === void 0) if (x.md) m = x.md.digest().getBytes(), E = "binary";
          else throw new TypeError('"options.message" or "options.md" not specified.');
          if (typeof m == "string" && !E) throw new TypeError('"options.encoding" must be "binary" or "utf8".');
          if (typeof m == "string") {
            if (typeof Buffer < "u") return Buffer.from(m, E);
            m = new _(m, E);
          } else if (!(m instanceof _)) throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.');
          for (var f = new c(m.length()), I = 0; I < f.length; ++I) f[I] = m.at(I);
          return f;
        }
        var l = rt(), y = rt([
          1
        ]), R = rt([
          30883,
          4953,
          19914,
          30187,
          55467,
          16705,
          2637,
          112,
          59544,
          30585,
          16505,
          36039,
          65139,
          11119,
          27886,
          20995
        ]), j = rt([
          61785,
          9906,
          39828,
          60374,
          45398,
          33411,
          5274,
          224,
          53552,
          61171,
          33010,
          6542,
          64743,
          22239,
          55772,
          9222
        ]), b = rt([
          54554,
          36645,
          11616,
          51542,
          42930,
          38181,
          51040,
          26924,
          56412,
          64982,
          57905,
          49316,
          21502,
          52590,
          14035,
          8553
        ]), C = rt([
          26200,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214
        ]), A = new Float64Array([
          237,
          211,
          245,
          92,
          26,
          99,
          18,
          88,
          214,
          156,
          247,
          162,
          222,
          249,
          222,
          20,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          16
        ]), T = rt([
          41136,
          18958,
          6951,
          50414,
          58488,
          44335,
          6150,
          12099,
          55207,
          15867,
          153,
          11085,
          57099,
          20417,
          9344,
          11139
        ]);
        function h(x, m) {
          var E = d.md.sha512.create(), f = new _(x);
          E.update(f.getBytes(m), "binary");
          var I = E.digest().getBytes();
          if (typeof Buffer < "u") return Buffer.from(I, "binary");
          for (var D = new c(s.constants.HASH_BYTE_LENGTH), L = 0; L < 64; ++L) D[L] = I.charCodeAt(L);
          return D;
        }
        function k(x, m) {
          var E = [
            rt(),
            rt(),
            rt(),
            rt()
          ], f, I = h(m, 32);
          for (I[0] &= 248, I[31] &= 127, I[31] |= 64, wt(E, I), F(x, E), f = 0; f < 32; ++f) m[f + 32] = x[f];
          return 0;
        }
        function S(x, m, E, f) {
          var I, D, L = new Float64Array(64), $ = [
            rt(),
            rt(),
            rt(),
            rt()
          ], Q = h(f, 32);
          Q[0] &= 248, Q[31] &= 127, Q[31] |= 64;
          var X = E + 64;
          for (I = 0; I < E; ++I) x[64 + I] = m[I];
          for (I = 0; I < 32; ++I) x[32 + I] = Q[32 + I];
          var G = h(x.subarray(32), E + 32);
          for (v(G), wt($, G), F(x, $), I = 32; I < 64; ++I) x[I] = f[I];
          var J = h(x, E + 64);
          for (v(J), I = 32; I < 64; ++I) L[I] = 0;
          for (I = 0; I < 32; ++I) L[I] = G[I];
          for (I = 0; I < 32; ++I) for (D = 0; D < 32; D++) L[I + D] += J[I] * Q[D];
          return P(x.subarray(32), L), X;
        }
        function N(x, m, E, f) {
          var I, D, L = new c(32), $ = [
            rt(),
            rt(),
            rt(),
            rt()
          ], Q = [
            rt(),
            rt(),
            rt(),
            rt()
          ];
          if (D = -1, E < 64 || W(Q, f)) return -1;
          for (I = 0; I < E; ++I) x[I] = m[I];
          for (I = 0; I < 32; ++I) x[I + 32] = f[I];
          var X = h(x, E);
          if (v(X), pt($, Q, X), wt(Q, m.subarray(32)), g($, Q), F(L, $), E -= 64, Z(m, 0, L, 0)) {
            for (I = 0; I < E; ++I) x[I] = 0;
            return -1;
          }
          for (I = 0; I < E; ++I) x[I] = m[I + 64];
          return D = E, D;
        }
        function P(x, m) {
          var E, f, I, D;
          for (f = 63; f >= 32; --f) {
            for (E = 0, I = f - 32, D = f - 12; I < D; ++I) m[I] += E - 16 * m[f] * A[I - (f - 32)], E = m[I] + 128 >> 8, m[I] -= E * 256;
            m[I] += E, m[f] = 0;
          }
          for (E = 0, I = 0; I < 32; ++I) m[I] += E - (m[31] >> 4) * A[I], E = m[I] >> 8, m[I] &= 255;
          for (I = 0; I < 32; ++I) m[I] -= E * A[I];
          for (f = 0; f < 32; ++f) m[f + 1] += m[f] >> 8, x[f] = m[f] & 255;
        }
        function v(x) {
          for (var m = new Float64Array(64), E = 0; E < 64; ++E) m[E] = x[E], x[E] = 0;
          P(x, m);
        }
        function g(x, m) {
          var E = rt(), f = rt(), I = rt(), D = rt(), L = rt(), $ = rt(), Q = rt(), X = rt(), G = rt();
          gt(E, x[1], x[0]), gt(G, m[1], m[0]), Ct(E, E, G), Tt(f, x[0], x[1]), Tt(G, m[0], m[1]), Ct(f, f, G), Ct(I, x[3], m[3]), Ct(I, I, j), Ct(D, x[2], m[2]), Tt(D, D, D), gt(L, f, E), gt($, D, I), Tt(Q, D, I), Tt(X, f, E), Ct(x[0], L, $), Ct(x[1], X, Q), Ct(x[2], Q, $), Ct(x[3], L, X);
        }
        function u(x, m, E) {
          for (var f = 0; f < 4; ++f) Kt(x[f], m[f], E);
        }
        function F(x, m) {
          var E = rt(), f = rt(), I = rt();
          St(I, m[2]), Ct(E, m[0], I), Ct(f, m[1], I), z(x, f), x[31] ^= ct(E) << 7;
        }
        function z(x, m) {
          var E, f, I, D = rt(), L = rt();
          for (E = 0; E < 16; ++E) L[E] = m[E];
          for (Bt(L), Bt(L), Bt(L), f = 0; f < 2; ++f) {
            for (D[0] = L[0] - 65517, E = 1; E < 15; ++E) D[E] = L[E] - 65535 - (D[E - 1] >> 16 & 1), D[E - 1] &= 65535;
            D[15] = L[15] - 32767 - (D[14] >> 16 & 1), I = D[15] >> 16 & 1, D[14] &= 65535, Kt(L, D, 1 - I);
          }
          for (E = 0; E < 16; E++) x[2 * E] = L[E] & 255, x[2 * E + 1] = L[E] >> 8;
        }
        function W(x, m) {
          var E = rt(), f = rt(), I = rt(), D = rt(), L = rt(), $ = rt(), Q = rt();
          return yt(x[2], y), M(x[1], m), ae(I, x[1]), Ct(D, I, R), gt(I, I, x[2]), Tt(D, x[2], D), ae(L, D), ae($, L), Ct(Q, $, L), Ct(E, Q, I), Ct(E, E, D), Y(E, E), Ct(E, E, I), Ct(E, E, D), Ct(E, E, D), Ct(x[0], E, D), ae(f, x[0]), Ct(f, f, D), tt(f, I) && Ct(x[0], x[0], T), ae(f, x[0]), Ct(f, f, D), tt(f, I) ? -1 : (ct(x[0]) === m[31] >> 7 && gt(x[0], l, x[0]), Ct(x[3], x[0], x[1]), 0);
        }
        function M(x, m) {
          var E;
          for (E = 0; E < 16; ++E) x[E] = m[2 * E] + (m[2 * E + 1] << 8);
          x[15] &= 32767;
        }
        function Y(x, m) {
          var E = rt(), f;
          for (f = 0; f < 16; ++f) E[f] = m[f];
          for (f = 250; f >= 0; --f) ae(E, E), f !== 1 && Ct(E, E, m);
          for (f = 0; f < 16; ++f) x[f] = E[f];
        }
        function tt(x, m) {
          var E = new c(32), f = new c(32);
          return z(E, x), z(f, m), Z(E, 0, f, 0);
        }
        function Z(x, m, E, f) {
          return ot(x, m, E, f, 32);
        }
        function ot(x, m, E, f, I) {
          var D, L = 0;
          for (D = 0; D < I; ++D) L |= x[m + D] ^ E[f + D];
          return (1 & L - 1 >>> 8) - 1;
        }
        function ct(x) {
          var m = new c(32);
          return z(m, x), m[0] & 1;
        }
        function pt(x, m, E) {
          var f, I;
          for (yt(x[0], l), yt(x[1], y), yt(x[2], y), yt(x[3], l), I = 255; I >= 0; --I) f = E[I / 8 | 0] >> (I & 7) & 1, u(x, m, f), g(m, x), g(x, x), u(x, m, f);
        }
        function wt(x, m) {
          var E = [
            rt(),
            rt(),
            rt(),
            rt()
          ];
          yt(E[0], b), yt(E[1], C), yt(E[2], y), Ct(E[3], b, C), pt(x, E, m);
        }
        function yt(x, m) {
          var E;
          for (E = 0; E < 16; E++) x[E] = m[E] | 0;
        }
        function St(x, m) {
          var E = rt(), f;
          for (f = 0; f < 16; ++f) E[f] = m[f];
          for (f = 253; f >= 0; --f) ae(E, E), f !== 2 && f !== 4 && Ct(E, E, m);
          for (f = 0; f < 16; ++f) x[f] = E[f];
        }
        function Bt(x) {
          var m, E, f = 1;
          for (m = 0; m < 16; ++m) E = x[m] + f + 65535, f = Math.floor(E / 65536), x[m] = E - f * 65536;
          x[0] += f - 1 + 37 * (f - 1);
        }
        function Kt(x, m, E) {
          for (var f, I = ~(E - 1), D = 0; D < 16; ++D) f = I & (x[D] ^ m[D]), x[D] ^= f, m[D] ^= f;
        }
        function rt(x) {
          var m, E = new Float64Array(16);
          if (x) for (m = 0; m < x.length; ++m) E[m] = x[m];
          return E;
        }
        function Tt(x, m, E) {
          for (var f = 0; f < 16; ++f) x[f] = m[f] + E[f];
        }
        function gt(x, m, E) {
          for (var f = 0; f < 16; ++f) x[f] = m[f] - E[f];
        }
        function ae(x, m) {
          Ct(x, m, m);
        }
        function Ct(x, m, E) {
          var f, I, D = 0, L = 0, $ = 0, Q = 0, X = 0, G = 0, J = 0, at = 0, ft = 0, ut = 0, kt = 0, jt = 0, Rt = 0, mt = 0, Et = 0, Nt = 0, Qt = 0, Zt = 0, te = 0, qt = 0, ee = 0, Ht = 0, Pt = 0, Ft = 0, or = 0, wr = 0, Yr = 0, $_ = 0, wn = 0, Sn = 0, Vn = 0, ce = E[0], de = E[1], le = E[2], pe = E[3], ue = E[4], fe = E[5], ge = E[6], we = E[7], he = E[8], be = E[9], ye = E[10], ve = E[11], Xt = E[12], oe = E[13], me = E[14], ke = E[15];
          f = m[0], D += f * ce, L += f * de, $ += f * le, Q += f * pe, X += f * ue, G += f * fe, J += f * ge, at += f * we, ft += f * he, ut += f * be, kt += f * ye, jt += f * ve, Rt += f * Xt, mt += f * oe, Et += f * me, Nt += f * ke, f = m[1], L += f * ce, $ += f * de, Q += f * le, X += f * pe, G += f * ue, J += f * fe, at += f * ge, ft += f * we, ut += f * he, kt += f * be, jt += f * ye, Rt += f * ve, mt += f * Xt, Et += f * oe, Nt += f * me, Qt += f * ke, f = m[2], $ += f * ce, Q += f * de, X += f * le, G += f * pe, J += f * ue, at += f * fe, ft += f * ge, ut += f * we, kt += f * he, jt += f * be, Rt += f * ye, mt += f * ve, Et += f * Xt, Nt += f * oe, Qt += f * me, Zt += f * ke, f = m[3], Q += f * ce, X += f * de, G += f * le, J += f * pe, at += f * ue, ft += f * fe, ut += f * ge, kt += f * we, jt += f * he, Rt += f * be, mt += f * ye, Et += f * ve, Nt += f * Xt, Qt += f * oe, Zt += f * me, te += f * ke, f = m[4], X += f * ce, G += f * de, J += f * le, at += f * pe, ft += f * ue, ut += f * fe, kt += f * ge, jt += f * we, Rt += f * he, mt += f * be, Et += f * ye, Nt += f * ve, Qt += f * Xt, Zt += f * oe, te += f * me, qt += f * ke, f = m[5], G += f * ce, J += f * de, at += f * le, ft += f * pe, ut += f * ue, kt += f * fe, jt += f * ge, Rt += f * we, mt += f * he, Et += f * be, Nt += f * ye, Qt += f * ve, Zt += f * Xt, te += f * oe, qt += f * me, ee += f * ke, f = m[6], J += f * ce, at += f * de, ft += f * le, ut += f * pe, kt += f * ue, jt += f * fe, Rt += f * ge, mt += f * we, Et += f * he, Nt += f * be, Qt += f * ye, Zt += f * ve, te += f * Xt, qt += f * oe, ee += f * me, Ht += f * ke, f = m[7], at += f * ce, ft += f * de, ut += f * le, kt += f * pe, jt += f * ue, Rt += f * fe, mt += f * ge, Et += f * we, Nt += f * he, Qt += f * be, Zt += f * ye, te += f * ve, qt += f * Xt, ee += f * oe, Ht += f * me, Pt += f * ke, f = m[8], ft += f * ce, ut += f * de, kt += f * le, jt += f * pe, Rt += f * ue, mt += f * fe, Et += f * ge, Nt += f * we, Qt += f * he, Zt += f * be, te += f * ye, qt += f * ve, ee += f * Xt, Ht += f * oe, Pt += f * me, Ft += f * ke, f = m[9], ut += f * ce, kt += f * de, jt += f * le, Rt += f * pe, mt += f * ue, Et += f * fe, Nt += f * ge, Qt += f * we, Zt += f * he, te += f * be, qt += f * ye, ee += f * ve, Ht += f * Xt, Pt += f * oe, Ft += f * me, or += f * ke, f = m[10], kt += f * ce, jt += f * de, Rt += f * le, mt += f * pe, Et += f * ue, Nt += f * fe, Qt += f * ge, Zt += f * we, te += f * he, qt += f * be, ee += f * ye, Ht += f * ve, Pt += f * Xt, Ft += f * oe, or += f * me, wr += f * ke, f = m[11], jt += f * ce, Rt += f * de, mt += f * le, Et += f * pe, Nt += f * ue, Qt += f * fe, Zt += f * ge, te += f * we, qt += f * he, ee += f * be, Ht += f * ye, Pt += f * ve, Ft += f * Xt, or += f * oe, wr += f * me, Yr += f * ke, f = m[12], Rt += f * ce, mt += f * de, Et += f * le, Nt += f * pe, Qt += f * ue, Zt += f * fe, te += f * ge, qt += f * we, ee += f * he, Ht += f * be, Pt += f * ye, Ft += f * ve, or += f * Xt, wr += f * oe, Yr += f * me, $_ += f * ke, f = m[13], mt += f * ce, Et += f * de, Nt += f * le, Qt += f * pe, Zt += f * ue, te += f * fe, qt += f * ge, ee += f * we, Ht += f * he, Pt += f * be, Ft += f * ye, or += f * ve, wr += f * Xt, Yr += f * oe, $_ += f * me, wn += f * ke, f = m[14], Et += f * ce, Nt += f * de, Qt += f * le, Zt += f * pe, te += f * ue, qt += f * fe, ee += f * ge, Ht += f * we, Pt += f * he, Ft += f * be, or += f * ye, wr += f * ve, Yr += f * Xt, $_ += f * oe, wn += f * me, Sn += f * ke, f = m[15], Nt += f * ce, Qt += f * de, Zt += f * le, te += f * pe, qt += f * ue, ee += f * fe, Ht += f * ge, Pt += f * we, Ft += f * he, or += f * be, wr += f * ye, Yr += f * ve, $_ += f * Xt, wn += f * oe, Sn += f * me, Vn += f * ke, D += 38 * Qt, L += 38 * Zt, $ += 38 * te, Q += 38 * qt, X += 38 * ee, G += 38 * Ht, J += 38 * Pt, at += 38 * Ft, ft += 38 * or, ut += 38 * wr, kt += 38 * Yr, jt += 38 * $_, Rt += 38 * wn, mt += 38 * Sn, Et += 38 * Vn, I = 1, f = D + I + 65535, I = Math.floor(f / 65536), D = f - I * 65536, f = L + I + 65535, I = Math.floor(f / 65536), L = f - I * 65536, f = $ + I + 65535, I = Math.floor(f / 65536), $ = f - I * 65536, f = Q + I + 65535, I = Math.floor(f / 65536), Q = f - I * 65536, f = X + I + 65535, I = Math.floor(f / 65536), X = f - I * 65536, f = G + I + 65535, I = Math.floor(f / 65536), G = f - I * 65536, f = J + I + 65535, I = Math.floor(f / 65536), J = f - I * 65536, f = at + I + 65535, I = Math.floor(f / 65536), at = f - I * 65536, f = ft + I + 65535, I = Math.floor(f / 65536), ft = f - I * 65536, f = ut + I + 65535, I = Math.floor(f / 65536), ut = f - I * 65536, f = kt + I + 65535, I = Math.floor(f / 65536), kt = f - I * 65536, f = jt + I + 65535, I = Math.floor(f / 65536), jt = f - I * 65536, f = Rt + I + 65535, I = Math.floor(f / 65536), Rt = f - I * 65536, f = mt + I + 65535, I = Math.floor(f / 65536), mt = f - I * 65536, f = Et + I + 65535, I = Math.floor(f / 65536), Et = f - I * 65536, f = Nt + I + 65535, I = Math.floor(f / 65536), Nt = f - I * 65536, D += I - 1 + 37 * (I - 1), I = 1, f = D + I + 65535, I = Math.floor(f / 65536), D = f - I * 65536, f = L + I + 65535, I = Math.floor(f / 65536), L = f - I * 65536, f = $ + I + 65535, I = Math.floor(f / 65536), $ = f - I * 65536, f = Q + I + 65535, I = Math.floor(f / 65536), Q = f - I * 65536, f = X + I + 65535, I = Math.floor(f / 65536), X = f - I * 65536, f = G + I + 65535, I = Math.floor(f / 65536), G = f - I * 65536, f = J + I + 65535, I = Math.floor(f / 65536), J = f - I * 65536, f = at + I + 65535, I = Math.floor(f / 65536), at = f - I * 65536, f = ft + I + 65535, I = Math.floor(f / 65536), ft = f - I * 65536, f = ut + I + 65535, I = Math.floor(f / 65536), ut = f - I * 65536, f = kt + I + 65535, I = Math.floor(f / 65536), kt = f - I * 65536, f = jt + I + 65535, I = Math.floor(f / 65536), jt = f - I * 65536, f = Rt + I + 65535, I = Math.floor(f / 65536), Rt = f - I * 65536, f = mt + I + 65535, I = Math.floor(f / 65536), mt = f - I * 65536, f = Et + I + 65535, I = Math.floor(f / 65536), Et = f - I * 65536, f = Nt + I + 65535, I = Math.floor(f / 65536), Nt = f - I * 65536, D += I - 1 + 37 * (I - 1), x[0] = D, x[1] = L, x[2] = $, x[3] = Q, x[4] = X, x[5] = G, x[6] = J, x[7] = at, x[8] = ft, x[9] = ut, x[10] = kt, x[11] = jt, x[12] = Rt, x[13] = mt, x[14] = Et, x[15] = Nt;
        }
        return Za;
      }
      var to, dd;
      function h$() {
        if (dd) return to;
        dd = 1;
        var d = Lt();
        Ut(), ar(), ua(), to = d.kem = d.kem || {};
        var t = d.jsbn.BigInteger;
        d.kem.rsa = {}, d.kem.rsa.create = function(a, n) {
          n = n || {};
          var _ = n.prng || d.random, c = {};
          return c.encrypt = function(s, p) {
            var l = Math.ceil(s.n.bitLength() / 8), y;
            do
              y = new t(d.util.bytesToHex(_.getBytesSync(l)), 16).mod(s.n);
            while (y.compareTo(t.ONE) <= 0);
            y = d.util.hexToBytes(y.toString(16));
            var R = l - y.length;
            R > 0 && (y = d.util.fillString("\0", R) + y);
            var j = s.encrypt(y, "NONE"), b = a.generate(y, p);
            return {
              encapsulation: j,
              key: b
            };
          }, c.decrypt = function(s, p, l) {
            var y = s.decrypt(p, "NONE");
            return a.generate(y, l);
          }, c;
        }, d.kem.kdf1 = function(a, n) {
          e(this, a, 0, n || a.digestLength);
        }, d.kem.kdf2 = function(a, n) {
          e(this, a, 1, n || a.digestLength);
        };
        function e(a, n, _, c) {
          a.generate = function(s, p) {
            for (var l = new d.util.ByteBuffer(), y = Math.ceil(p / c) + _, R = new d.util.ByteBuffer(), j = _; j < y; ++j) {
              R.putInt32(j), n.start(), n.update(s + R.getBytes());
              var b = n.digest();
              l.putBytes(b.getBytes(c));
            }
            return l.truncate(l.length() - p), l.getBytes();
          };
        }
        return to;
      }
      var eo, ld;
      function b$() {
        if (ld) return eo;
        ld = 1;
        var d = Lt();
        Ut(), eo = d.log = d.log || {}, d.log.levels = [
          "none",
          "error",
          "warning",
          "info",
          "debug",
          "verbose",
          "max"
        ];
        var t = {}, e = [], a = null;
        d.log.LEVEL_LOCKED = 2, d.log.NO_LEVEL_CHECK = 4, d.log.INTERPOLATE = 8;
        for (var n = 0; n < d.log.levels.length; ++n) {
          var _ = d.log.levels[n];
          t[_] = {
            index: n,
            name: _.toUpperCase()
          };
        }
        d.log.logMessage = function(j) {
          for (var b = t[j.level].index, C = 0; C < e.length; ++C) {
            var A = e[C];
            if (A.flags & d.log.NO_LEVEL_CHECK) A.f(j);
            else {
              var T = t[A.level].index;
              b <= T && A.f(A, j);
            }
          }
        }, d.log.prepareStandard = function(j) {
          "standard" in j || (j.standard = t[j.level].name + " [" + j.category + "] " + j.message);
        }, d.log.prepareFull = function(j) {
          if (!("full" in j)) {
            var b = [
              j.message
            ];
            b = b.concat([]), j.full = d.util.format.apply(this, b);
          }
        }, d.log.prepareStandardFull = function(j) {
          "standardFull" in j || (d.log.prepareStandard(j), j.standardFull = j.standard);
        };
        for (var c = [
          "error",
          "warning",
          "info",
          "debug",
          "verbose"
        ], n = 0; n < c.length; ++n) (function(b) {
          d.log[b] = function(C, A) {
            var T = Array.prototype.slice.call(arguments).slice(2), h = {
              timestamp: /* @__PURE__ */ new Date(),
              level: b,
              category: C,
              message: A,
              arguments: T
            };
            d.log.logMessage(h);
          };
        })(c[n]);
        if (d.log.makeLogger = function(j) {
          var b = {
            flags: 0,
            f: j
          };
          return d.log.setLevel(b, "none"), b;
        }, d.log.setLevel = function(j, b) {
          var C = false;
          if (j && !(j.flags & d.log.LEVEL_LOCKED)) for (var A = 0; A < d.log.levels.length; ++A) {
            var T = d.log.levels[A];
            if (b == T) {
              j.level = b, C = true;
              break;
            }
          }
          return C;
        }, d.log.lock = function(j, b) {
          typeof b > "u" || b ? j.flags |= d.log.LEVEL_LOCKED : j.flags &= ~d.log.LEVEL_LOCKED;
        }, d.log.addLogger = function(j) {
          e.push(j);
        }, typeof console < "u" && "log" in console) {
          var s;
          if (console.error && console.warn && console.info && console.debug) {
            var p = {
              error: console.error,
              warning: console.warn,
              info: console.info,
              debug: console.debug,
              verbose: console.debug
            }, l = function(j, b) {
              d.log.prepareStandard(b);
              var C = p[b.level], A = [
                b.standard
              ];
              A = A.concat(b.arguments.slice()), C.apply(console, A);
            };
            s = d.log.makeLogger(l);
          } else {
            var l = function(b, C) {
              d.log.prepareStandardFull(C), console.log(C.standardFull);
            };
            s = d.log.makeLogger(l);
          }
          d.log.setLevel(s, "debug"), d.log.addLogger(s), a = s;
        } else console = {
          log: function() {
          }
        };
        if (a !== null && typeof window < "u" && window.location) {
          var y = new URL(window.location.href).searchParams;
          if (y.has("console.level") && d.log.setLevel(a, y.get("console.level").slice(-1)[0]), y.has("console.lock")) {
            var R = y.get("console.lock").slice(-1)[0];
            R == "true" && d.log.lock(a);
          }
        }
        return d.log.consoleLogger = a, eo;
      }
      var ro, pd;
      function y$() {
        return pd || (pd = 1, ro = $r(), mo(), Pn(), Qd(), al()), ro;
      }
      var _o = {
        exports: {}
      }, ud;
      function v$() {
        if (ud) return _o.exports;
        ud = 1;
        var d = Lt();
        fn(), gr(), pa(), gn(), Cn(), tl(), ar(), Ut(), Co();
        var t = d.asn1, e = _o.exports = d.pkcs7 = d.pkcs7 || {};
        e.messageFromPem = function(b) {
          var C = d.pem.decode(b)[0];
          if (C.type !== "PKCS7") {
            var A = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
            throw A.headerType = C.type, A;
          }
          if (C.procType && C.procType.type === "ENCRYPTED") throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
          var T = t.fromDer(C.body);
          return e.messageFromAsn1(T);
        }, e.messageToPem = function(b, C) {
          var A = {
            type: "PKCS7",
            body: t.toDer(b.toAsn1()).getBytes()
          };
          return d.pem.encode(A, {
            maxline: C
          });
        }, e.messageFromAsn1 = function(b) {
          var C = {}, A = [];
          if (!t.validate(b, e.asn1.contentInfoValidator, C, A)) {
            var T = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
            throw T.errors = A, T;
          }
          var h = t.derToOid(C.contentType), k;
          switch (h) {
            case d.pki.oids.envelopedData:
              k = e.createEnvelopedData();
              break;
            case d.pki.oids.encryptedData:
              k = e.createEncryptedData();
              break;
            case d.pki.oids.signedData:
              k = e.createSignedData();
              break;
            default:
              throw new Error("Cannot read PKCS#7 message. ContentType with OID " + h + " is not (yet) supported.");
          }
          return k.fromAsn1(C.content.value[0]), k;
        }, e.createSignedData = function() {
          var b = null;
          return b = {
            type: d.pki.oids.signedData,
            version: 1,
            certificates: [],
            crls: [],
            signers: [],
            digestAlgorithmIdentifiers: [],
            contentInfo: null,
            signerInfos: [],
            fromAsn1: function(T) {
              if (R(b, T, e.asn1.signedDataValidator), b.certificates = [], b.crls = [], b.digestAlgorithmIdentifiers = [], b.contentInfo = null, b.signerInfos = [], b.rawCapture.certificates) for (var h = b.rawCapture.certificates.value, k = 0; k < h.length; ++k) b.certificates.push(d.pki.certificateFromAsn1(h[k]));
            },
            toAsn1: function() {
              b.contentInfo || b.sign();
              for (var T = [], h = 0; h < b.certificates.length; ++h) T.push(d.pki.certificateToAsn1(b.certificates[h]));
              var k = [], S = t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
                t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
                  t.create(t.Class.UNIVERSAL, t.Type.INTEGER, false, t.integerToDer(b.version).getBytes()),
                  t.create(t.Class.UNIVERSAL, t.Type.SET, true, b.digestAlgorithmIdentifiers),
                  b.contentInfo
                ])
              ]);
              return T.length > 0 && S.value[0].value.push(t.create(t.Class.CONTEXT_SPECIFIC, 0, true, T)), k.length > 0 && S.value[0].value.push(t.create(t.Class.CONTEXT_SPECIFIC, 1, true, k)), S.value[0].value.push(t.create(t.Class.UNIVERSAL, t.Type.SET, true, b.signerInfos)), t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
                t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(b.type).getBytes()),
                S
              ]);
            },
            addSigner: function(T) {
              var h = T.issuer, k = T.serialNumber;
              if (T.certificate) {
                var S = T.certificate;
                typeof S == "string" && (S = d.pki.certificateFromPem(S)), h = S.issuer.attributes, k = S.serialNumber;
              }
              var N = T.key;
              if (!N) throw new Error("Could not add PKCS#7 signer; no private key specified.");
              typeof N == "string" && (N = d.pki.privateKeyFromPem(N));
              var P = T.digestAlgorithm || d.pki.oids.sha1;
              switch (P) {
                case d.pki.oids.sha1:
                case d.pki.oids.sha256:
                case d.pki.oids.sha384:
                case d.pki.oids.sha512:
                case d.pki.oids.md5:
                  break;
                default:
                  throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + P);
              }
              var v = T.authenticatedAttributes || [];
              if (v.length > 0) {
                for (var g = false, u = false, F = 0; F < v.length; ++F) {
                  var z = v[F];
                  if (!g && z.type === d.pki.oids.contentType) {
                    if (g = true, u) break;
                    continue;
                  }
                  if (!u && z.type === d.pki.oids.messageDigest) {
                    if (u = true, g) break;
                    continue;
                  }
                }
                if (!g || !u) throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
              }
              b.signers.push({
                key: N,
                version: 1,
                issuer: h,
                serialNumber: k,
                digestAlgorithm: P,
                signatureAlgorithm: d.pki.oids.rsaEncryption,
                signature: null,
                authenticatedAttributes: v,
                unauthenticatedAttributes: []
              });
            },
            sign: function(T) {
              if (T = T || {}, (typeof b.content != "object" || b.contentInfo === null) && (b.contentInfo = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
                t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(d.pki.oids.data).getBytes())
              ]), "content" in b)) {
                var h;
                b.content instanceof d.util.ByteBuffer ? h = b.content.bytes() : typeof b.content == "string" && (h = d.util.encodeUtf8(b.content)), T.detached ? b.detachedContent = t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, h) : b.contentInfo.value.push(t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
                  t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, h)
                ]));
              }
              if (b.signers.length !== 0) {
                var k = C();
                A(k);
              }
            },
            verify: function() {
              throw new Error("PKCS#7 signature verification not yet implemented.");
            },
            addCertificate: function(T) {
              typeof T == "string" && (T = d.pki.certificateFromPem(T)), b.certificates.push(T);
            },
            addCertificateRevokationList: function(T) {
              throw new Error("PKCS#7 CRL support not yet implemented.");
            }
          }, b;
          function C() {
            for (var T = {}, h = 0; h < b.signers.length; ++h) {
              var k = b.signers[h], S = k.digestAlgorithm;
              S in T || (T[S] = d.md[d.pki.oids[S]].create()), k.authenticatedAttributes.length === 0 ? k.md = T[S] : k.md = d.md[d.pki.oids[S]].create();
            }
            b.digestAlgorithmIdentifiers = [];
            for (var S in T) b.digestAlgorithmIdentifiers.push(t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(S).getBytes()),
              t.create(t.Class.UNIVERSAL, t.Type.NULL, false, "")
            ]));
            return T;
          }
          function A(T) {
            var h;
            if (b.detachedContent ? h = b.detachedContent : (h = b.contentInfo.value[1], h = h.value[0]), !h) throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
            var k = t.derToOid(b.contentInfo.value[0].value), S = t.toDer(h);
            S.getByte(), t.getBerValueLength(S), S = S.getBytes();
            for (var N in T) T[N].start().update(S);
            for (var P = /* @__PURE__ */ new Date(), v = 0; v < b.signers.length; ++v) {
              var g = b.signers[v];
              if (g.authenticatedAttributes.length === 0) {
                if (k !== d.pki.oids.data) throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
              } else {
                g.authenticatedAttributesAsn1 = t.create(t.Class.CONTEXT_SPECIFIC, 0, true, []);
                for (var u = t.create(t.Class.UNIVERSAL, t.Type.SET, true, []), F = 0; F < g.authenticatedAttributes.length; ++F) {
                  var z = g.authenticatedAttributes[F];
                  z.type === d.pki.oids.messageDigest ? z.value = T[g.digestAlgorithm].digest() : z.type === d.pki.oids.signingTime && (z.value || (z.value = P)), u.value.push(l(z)), g.authenticatedAttributesAsn1.value.push(l(z));
                }
                S = t.toDer(u).getBytes(), g.md.start().update(S);
              }
              g.signature = g.key.sign(g.md, "RSASSA-PKCS1-V1_5");
            }
            b.signerInfos = p(b.signers);
          }
        }, e.createEncryptedData = function() {
          var b = null;
          return b = {
            type: d.pki.oids.encryptedData,
            version: 0,
            encryptedContent: {
              algorithm: d.pki.oids["aes256-CBC"]
            },
            fromAsn1: function(C) {
              R(b, C, e.asn1.encryptedDataValidator);
            },
            decrypt: function(C) {
              C !== void 0 && (b.encryptedContent.key = C), j(b);
            }
          }, b;
        }, e.createEnvelopedData = function() {
          var b = null;
          return b = {
            type: d.pki.oids.envelopedData,
            version: 0,
            recipients: [],
            encryptedContent: {
              algorithm: d.pki.oids["aes256-CBC"]
            },
            fromAsn1: function(C) {
              var A = R(b, C, e.asn1.envelopedDataValidator);
              b.recipients = _(A.recipientInfos.value);
            },
            toAsn1: function() {
              return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
                t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(b.type).getBytes()),
                t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
                  t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
                    t.create(t.Class.UNIVERSAL, t.Type.INTEGER, false, t.integerToDer(b.version).getBytes()),
                    t.create(t.Class.UNIVERSAL, t.Type.SET, true, c(b.recipients)),
                    t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, y(b.encryptedContent))
                  ])
                ])
              ]);
            },
            findRecipient: function(C) {
              for (var A = C.issuer.attributes, T = 0; T < b.recipients.length; ++T) {
                var h = b.recipients[T], k = h.issuer;
                if (h.serialNumber === C.serialNumber && k.length === A.length) {
                  for (var S = true, N = 0; N < A.length; ++N) if (k[N].type !== A[N].type || k[N].value !== A[N].value) {
                    S = false;
                    break;
                  }
                  if (S) return h;
                }
              }
              return null;
            },
            decrypt: function(C, A) {
              if (b.encryptedContent.key === void 0 && C !== void 0 && A !== void 0) switch (C.encryptedContent.algorithm) {
                case d.pki.oids.rsaEncryption:
                case d.pki.oids.desCBC:
                  var T = A.decrypt(C.encryptedContent.content);
                  b.encryptedContent.key = d.util.createBuffer(T);
                  break;
                default:
                  throw new Error("Unsupported asymmetric cipher, OID " + C.encryptedContent.algorithm);
              }
              j(b);
            },
            addRecipient: function(C) {
              b.recipients.push({
                version: 0,
                issuer: C.issuer.attributes,
                serialNumber: C.serialNumber,
                encryptedContent: {
                  algorithm: d.pki.oids.rsaEncryption,
                  key: C.publicKey
                }
              });
            },
            encrypt: function(C, A) {
              if (b.encryptedContent.content === void 0) {
                A = A || b.encryptedContent.algorithm, C = C || b.encryptedContent.key;
                var T, h, k;
                switch (A) {
                  case d.pki.oids["aes128-CBC"]:
                    T = 16, h = 16, k = d.aes.createEncryptionCipher;
                    break;
                  case d.pki.oids["aes192-CBC"]:
                    T = 24, h = 16, k = d.aes.createEncryptionCipher;
                    break;
                  case d.pki.oids["aes256-CBC"]:
                    T = 32, h = 16, k = d.aes.createEncryptionCipher;
                    break;
                  case d.pki.oids["des-EDE3-CBC"]:
                    T = 24, h = 8, k = d.des.createEncryptionCipher;
                    break;
                  default:
                    throw new Error("Unsupported symmetric cipher, OID " + A);
                }
                if (C === void 0) C = d.util.createBuffer(d.random.getBytes(T));
                else if (C.length() != T) throw new Error("Symmetric key has wrong length; got " + C.length() + " bytes, expected " + T + ".");
                b.encryptedContent.algorithm = A, b.encryptedContent.key = C, b.encryptedContent.parameter = d.util.createBuffer(d.random.getBytes(h));
                var S = k(C);
                if (S.start(b.encryptedContent.parameter.copy()), S.update(b.content), !S.finish()) throw new Error("Symmetric encryption failed.");
                b.encryptedContent.content = S.output;
              }
              for (var N = 0; N < b.recipients.length; ++N) {
                var P = b.recipients[N];
                if (P.encryptedContent.content === void 0) switch (P.encryptedContent.algorithm) {
                  case d.pki.oids.rsaEncryption:
                    P.encryptedContent.content = P.encryptedContent.key.encrypt(b.encryptedContent.key.data);
                    break;
                  default:
                    throw new Error("Unsupported asymmetric cipher, OID " + P.encryptedContent.algorithm);
                }
              }
            }
          }, b;
        };
        function a(b) {
          var C = {}, A = [];
          if (!t.validate(b, e.asn1.recipientInfoValidator, C, A)) {
            var T = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
            throw T.errors = A, T;
          }
          return {
            version: C.version.charCodeAt(0),
            issuer: d.pki.RDNAttributesAsArray(C.issuer),
            serialNumber: d.util.createBuffer(C.serial).toHex(),
            encryptedContent: {
              algorithm: t.derToOid(C.encAlgorithm),
              parameter: C.encParameter ? C.encParameter.value : void 0,
              content: C.encKey
            }
          };
        }
        function n(b) {
          return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
            t.create(t.Class.UNIVERSAL, t.Type.INTEGER, false, t.integerToDer(b.version).getBytes()),
            t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              d.pki.distinguishedNameToAsn1({
                attributes: b.issuer
              }),
              t.create(t.Class.UNIVERSAL, t.Type.INTEGER, false, d.util.hexToBytes(b.serialNumber))
            ]),
            t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(b.encryptedContent.algorithm).getBytes()),
              t.create(t.Class.UNIVERSAL, t.Type.NULL, false, "")
            ]),
            t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, b.encryptedContent.content)
          ]);
        }
        function _(b) {
          for (var C = [], A = 0; A < b.length; ++A) C.push(a(b[A]));
          return C;
        }
        function c(b) {
          for (var C = [], A = 0; A < b.length; ++A) C.push(n(b[A]));
          return C;
        }
        function s(b) {
          var C = t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
            t.create(t.Class.UNIVERSAL, t.Type.INTEGER, false, t.integerToDer(b.version).getBytes()),
            t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              d.pki.distinguishedNameToAsn1({
                attributes: b.issuer
              }),
              t.create(t.Class.UNIVERSAL, t.Type.INTEGER, false, d.util.hexToBytes(b.serialNumber))
            ]),
            t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(b.digestAlgorithm).getBytes()),
              t.create(t.Class.UNIVERSAL, t.Type.NULL, false, "")
            ])
          ]);
          if (b.authenticatedAttributesAsn1 && C.value.push(b.authenticatedAttributesAsn1), C.value.push(t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
            t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(b.signatureAlgorithm).getBytes()),
            t.create(t.Class.UNIVERSAL, t.Type.NULL, false, "")
          ])), C.value.push(t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, b.signature)), b.unauthenticatedAttributes.length > 0) {
            for (var A = t.create(t.Class.CONTEXT_SPECIFIC, 1, true, []), T = 0; T < b.unauthenticatedAttributes.length; ++T) {
              var h = b.unauthenticatedAttributes[T];
              A.values.push(l(h));
            }
            C.value.push(A);
          }
          return C;
        }
        function p(b) {
          for (var C = [], A = 0; A < b.length; ++A) C.push(s(b[A]));
          return C;
        }
        function l(b) {
          var C;
          if (b.type === d.pki.oids.contentType) C = t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(b.value).getBytes());
          else if (b.type === d.pki.oids.messageDigest) C = t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, b.value.bytes());
          else if (b.type === d.pki.oids.signingTime) {
            var A = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z"), T = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z"), h = b.value;
            if (typeof h == "string") {
              var k = Date.parse(h);
              isNaN(k) ? h.length === 13 ? h = t.utcTimeToDate(h) : h = t.generalizedTimeToDate(h) : h = new Date(k);
            }
            h >= A && h < T ? C = t.create(t.Class.UNIVERSAL, t.Type.UTCTIME, false, t.dateToUtcTime(h)) : C = t.create(t.Class.UNIVERSAL, t.Type.GENERALIZEDTIME, false, t.dateToGeneralizedTime(h));
          }
          return t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
            t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(b.type).getBytes()),
            t.create(t.Class.UNIVERSAL, t.Type.SET, true, [
              C
            ])
          ]);
        }
        function y(b) {
          return [
            t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(d.pki.oids.data).getBytes()),
            t.create(t.Class.UNIVERSAL, t.Type.SEQUENCE, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OID, false, t.oidToDer(b.algorithm).getBytes()),
              b.parameter ? t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, b.parameter.getBytes()) : void 0
            ]),
            t.create(t.Class.CONTEXT_SPECIFIC, 0, true, [
              t.create(t.Class.UNIVERSAL, t.Type.OCTETSTRING, false, b.content.getBytes())
            ])
          ];
        }
        function R(b, C, A) {
          var T = {}, h = [];
          if (!t.validate(C, A, T, h)) {
            var k = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
            throw k.errors = k, k;
          }
          var S = t.derToOid(T.contentType);
          if (S !== d.pki.oids.data) throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
          if (T.encryptedContent) {
            var N = "";
            if (d.util.isArray(T.encryptedContent)) for (var P = 0; P < T.encryptedContent.length; ++P) {
              if (T.encryptedContent[P].type !== t.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
              N += T.encryptedContent[P].value;
            }
            else N = T.encryptedContent;
            b.encryptedContent = {
              algorithm: t.derToOid(T.encAlgorithm),
              parameter: d.util.createBuffer(T.encParameter.value),
              content: d.util.createBuffer(N)
            };
          }
          if (T.content) {
            var N = "";
            if (d.util.isArray(T.content)) for (var P = 0; P < T.content.length; ++P) {
              if (T.content[P].type !== t.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
              N += T.content[P].value;
            }
            else N = T.content;
            b.content = d.util.createBuffer(N);
          }
          return b.version = T.version.charCodeAt(0), b.rawCapture = T, T;
        }
        function j(b) {
          if (b.encryptedContent.key === void 0) throw new Error("Symmetric key not available.");
          if (b.content === void 0) {
            var C;
            switch (b.encryptedContent.algorithm) {
              case d.pki.oids["aes128-CBC"]:
              case d.pki.oids["aes192-CBC"]:
              case d.pki.oids["aes256-CBC"]:
                C = d.aes.createDecryptionCipher(b.encryptedContent.key);
                break;
              case d.pki.oids.desCBC:
              case d.pki.oids["des-EDE3-CBC"]:
                C = d.des.createDecryptionCipher(b.encryptedContent.key);
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + b.encryptedContent.algorithm);
            }
            if (C.start(b.encryptedContent.parameter), C.update(b.encryptedContent.content), !C.finish()) throw new Error("Symmetric decryption failed.");
            b.content = C.output;
          }
        }
        return _o.exports;
      }
      var no = {
        exports: {}
      }, fd;
      function m$() {
        if (fd) return no.exports;
        fd = 1;
        var d = Lt();
        fn(), Dn(), mo(), Pn(), Ut();
        var t = no.exports = d.ssh = d.ssh || {};
        t.privateKeyToPutty = function(_, c, s) {
          s = s || "", c = c || "";
          var p = "ssh-rsa", l = c === "" ? "none" : "aes256-cbc", y = "PuTTY-User-Key-File-2: " + p + `\r
`;
          y += "Encryption: " + l + `\r
`, y += "Comment: " + s + `\r
`;
          var R = d.util.createBuffer();
          a(R, p), e(R, _.e), e(R, _.n);
          var j = d.util.encode64(R.bytes(), 64), b = Math.floor(j.length / 66) + 1;
          y += "Public-Lines: " + b + `\r
`, y += j;
          var C = d.util.createBuffer();
          e(C, _.d), e(C, _.p), e(C, _.q), e(C, _.qInv);
          var A;
          if (!c) A = d.util.encode64(C.bytes(), 64);
          else {
            var T = C.length() + 16 - 1;
            T -= T % 16;
            var h = n(C.bytes());
            h.truncate(h.length() - T + C.length()), C.putBuffer(h);
            var k = d.util.createBuffer();
            k.putBuffer(n("\0\0\0\0", c)), k.putBuffer(n("\0\0\0", c));
            var S = d.aes.createEncryptionCipher(k.truncate(8), "CBC");
            S.start(d.util.createBuffer().fillWithByte(0, 16)), S.update(C.copy()), S.finish();
            var N = S.output;
            N.truncate(16), A = d.util.encode64(N.bytes(), 64);
          }
          b = Math.floor(A.length / 66) + 1, y += `\r
Private-Lines: ` + b + `\r
`, y += A;
          var P = n("putty-private-key-file-mac-key", c), v = d.util.createBuffer();
          a(v, p), a(v, l), a(v, s), v.putInt32(R.length()), v.putBuffer(R), v.putInt32(C.length()), v.putBuffer(C);
          var g = d.hmac.create();
          return g.start("sha1", P), g.update(v.bytes()), y += `\r
Private-MAC: ` + g.digest().toHex() + `\r
`, y;
        }, t.publicKeyToOpenSSH = function(_, c) {
          var s = "ssh-rsa";
          c = c || "";
          var p = d.util.createBuffer();
          return a(p, s), e(p, _.e), e(p, _.n), s + " " + d.util.encode64(p.bytes()) + " " + c;
        }, t.privateKeyToOpenSSH = function(_, c) {
          return c ? d.pki.encryptRsaPrivateKey(_, c, {
            legacy: true,
            algorithm: "aes128"
          }) : d.pki.privateKeyToPem(_);
        }, t.getPublicKeyFingerprint = function(_, c) {
          c = c || {};
          var s = c.md || d.md.md5.create(), p = "ssh-rsa", l = d.util.createBuffer();
          a(l, p), e(l, _.e), e(l, _.n), s.start(), s.update(l.getBytes());
          var y = s.digest();
          if (c.encoding === "hex") {
            var R = y.toHex();
            return c.delimiter ? R.match(/.{2}/g).join(c.delimiter) : R;
          } else {
            if (c.encoding === "binary") return y.getBytes();
            if (c.encoding) throw new Error('Unknown encoding "' + c.encoding + '".');
          }
          return y;
        };
        function e(_, c) {
          var s = c.toString(16);
          s[0] >= "8" && (s = "00" + s);
          var p = d.util.hexToBytes(s);
          _.putInt32(p.length), _.putBytes(p);
        }
        function a(_, c) {
          _.putInt32(c.length), _.putString(c);
        }
        function n() {
          for (var _ = d.md.sha1.create(), c = arguments.length, s = 0; s < c; ++s) _.update(arguments[s]);
          return _.digest();
        }
        return no.exports;
      }
      var ao, gd;
      function k$() {
        return gd || (gd = 1, ao = Lt(), fn(), f$(), gr(), vo(), pa(), w$(), Dn(), h$(), b$(), y$(), el(), xo(), Cn(), Xd(), rl(), v$(), _l(), Jd(), $d(), Eo(), ar(), Yd(), m$(), nl(), Ut()), ao;
      }
      var x$ = k$();
      const br = qd(x$);
      class $n {
        constructor(t) {
          this.url = t;
        }
        headers(t = {}) {
          return Object.keys(t).length === 0 ? {} : {
            headers: t
          };
        }
        async serverKeys() {
          const { data: t } = await zt.get(`${this.url}/v0/keys`, this.headers());
          return console.log(t), s$(t);
        }
        async requestProof(t) {
          const a = (await this.serverKeys())[0], n = Xe(t), _ = br.random.getBytesSync(32), c = br.random.getBytesSync(16), s = br.cipher.createCipher("AES-CBC", _);
          s.start({
            iv: c
          }), s.update(br.util.createBuffer(n)), s.finish();
          const p = s.output.getBytes(), l = c + p, y = new br.jsbn.BigInteger(a.pkbPublic.public_n.toString(), 10), R = new br.jsbn.BigInteger(a.pkbPublic.public_e.toString(), 10), b = br.pki.setRsaPublicKey(y, R).encrypt(_, "RSAES-PKCS1-V1_5"), C = {
            preqKeyId: a.pkbId,
            preqAES: br.util.bytesToHex(b),
            preqPayload: br.util.bytesToHex(l)
          }, { data: A } = await zt.post(`${this.url}/v0/prove`, C, this.headers());
          return A;
        }
        async proofStatus(t) {
          const { data: e } = await zt.post(`${this.url}/v0/proof-status`, t, {
            ...this.headers({
              "Content-Type": "application/json"
            }),
            responseType: "text"
          });
          return i$(e);
        }
        async prove(t) {
          const e = (n) => new Promise((_) => setTimeout(_, n)), a = await this.requestProof(t);
          for (; ; ) try {
            const n = await this.proofStatus(a);
            if (console.log(`Status: ${n}`), typeof n == "object") return n;
            await e(3e4);
          } catch (n) {
            return console.error("Error checking status:", n), null;
          }
        }
      }
      function E$(d) {
        const t = [];
        for (let e = 0; e < d.length; e += 2) t.push(parseInt(d.substr(e, 2), 16));
        return Uint8Array.from(t);
      }
      var W_ = ((d) => (d[d.Bech32 = 0] = "Bech32", d[d.Email = 1] = "Email", d))(W_ || {});
      class wd {
        constructor(t, e, a) {
          this.recipientType = t, this.address = e, this.assets = a;
        }
      }
      class Yn {
        constructor(t, e, a) {
          this.freshKey = false, this.backend = t, this.prover = e, this.jwt = a.jwt;
          const n = this.jwt.split("."), _ = JSON.parse(atob(n[1].replace(/-/g, "+").replace(/_/g, "/")));
          if (this.userId = _.email, a.tokenSKey) this.tokenSKey = qe.from_hex(a.tokenSKey);
          else {
            const c = qe.generate_ed25519_bip32().derive(oo(1852)).derive(oo(1815)).derive(oo(0)).derive(0).derive(0);
            this.tokenSKey = c, this.freshKey = true;
          }
        }
        async addressForGmail(t) {
          return await this.backend.walletAddress(t);
        }
        async getAddress() {
          return await this.addressForGmail(this.userId);
        }
        async getBalance() {
          const t = await this.getUtxos(), e = {};
          for (let a = 0; a < t.length; a++) for (const n in t[a].value) n in e || (e[n] = new $t(0)), e[n].increase(t[a].value[n]);
          return e;
        }
        getExtensions() {
          return [];
        }
        async getUtxos() {
          const t = await this.getAddress();
          let e = [];
          try {
            e = await this.backend.addressUtxo(t);
          } catch (a) {
            console.log("getUtxos()"), console.log(a), e = [];
          }
          return e;
        }
        async getUsedAddresses() {
          const t = await this.getUtxos(), e = await this.getAddress();
          return t.length == 0 ? [] : [
            e
          ];
        }
        async getUnusedAddresses() {
          const t = await this.getUtxos(), e = await this.getAddress();
          return t.length == 0 ? [
            e
          ] : [];
        }
        async getRewardAddresses() {
          return [];
        }
        async getChangeAddress() {
          return await this.getAddress();
        }
        async sendTo(t) {
          console.log(t.recipientType), console.log(t.address), console.log(t.assets);
          let e;
          t.recipientType == 1 ? e = await this.addressForGmail(t.address) : e = _e.from_bech32(t.address);
          const a = [];
          t.recipientType == 1 && a.push(t.address);
          let n;
          const _ = [
            {
              address: e.to_bech32(),
              value: t.assets
            }
          ];
          if (!this.freshKey) n = (await this.backend.sendFunds(this.userId, _, this.tokenSKey.to_public().to_raw_key().hash().to_hex())).transaction;
          else {
            const p = this.tokenSKey.to_public().to_raw_key().hash().to_hex(), l = this.jwt.split("."), y = atob(l[0].replace(/-/g, "+").replace(/_/g, "/")), R = atob(l[1].replace(/-/g, "+").replace(/_/g, "/")), j = JSON.parse(y).kid, b = await C$(j), C = l[2].replace(/-/g, "+").replace(/_/g, "/"), A = {
              piPubE: so(b.e.replace(/-/g, "+").replace(/_/g, "/")),
              piPubN: so(b.n.replace(/-/g, "+").replace(/_/g, "/")),
              piSignature: so(C),
              piTokenName: new $t("0x" + p)
            }, T = await this.prover.prove(A);
            n = (await this.backend.createAndSendFunds(this.userId, y + "." + R, p, T, _)).transaction;
          }
          const c = Jr.from_bytes(E$(n));
          c.sign_and_add_vkey_signature(this.tokenSKey.to_raw_key());
          const s = Array.from(new Uint8Array(c.to_bytes())).map((p) => p.toString(16).padStart(2, "0")).join("");
          return await this.backend.submitTx(s, a);
        }
      }
      function oo(d) {
        return 2147483648 + d;
      }
      async function C$(d) {
        const { keys: t } = await fetch("https://www.googleapis.com/oauth2/v3/certs").then((e) => e.json());
        for (const e of t) if (e.kid == d) return e;
        return null;
      }
      function so(d) {
        const t = atob(d), e = [];
        return t.split("").forEach(function(a) {
          let n = a.charCodeAt(0).toString(16);
          n.length % 2 && (n = "0" + n), e.push(n);
        }), new $t(BigInt("0x" + e.join("")));
      }
      class ol {
        constructor() {
          __publicField(this, "listeners", /* @__PURE__ */ new Map());
        }
        on(t, e) {
          this.listeners.has(t) || this.listeners.set(t, []), this.listeners.get(t).push(e);
        }
        off(t, e) {
          const a = this.listeners.get(t);
          if (a) {
            const n = a.indexOf(e);
            n > -1 && a.splice(n, 1);
          }
        }
        emit(t, e) {
          const a = {
            type: t,
            data: e
          }, n = this.listeners.get(t);
          n && n.forEach((_) => {
            try {
              _(a);
            } catch (c) {
              console.error(`Error in event listener for ${t}:`, c);
            }
          });
        }
        removeAllListeners(t) {
          t ? this.listeners.delete(t) : this.listeners.clear();
        }
      }
      class S$ {
        constructor(t) {
          __publicField(this, "googleApi");
          const e = `${t.websiteUrl}/oauth2callback`;
          this.googleApi = new c$(t.clientId, t.clientSecret, e);
        }
        getAuthUrl(t) {
          return this.googleApi.getAuthUrl(t);
        }
        async getJWT(t) {
          return await this.googleApi.getJWT(t) || "";
        }
      }
      const T$ = "10a01cd6ba666b392ef1967c7af500377d9241d5414b2d658f2179aa";
      function j$(d) {
        let t = "";
        for (const [e, a] of Object.entries(d)) if (!e.startsWith(T$)) if (e === "lovelace") {
          const n = Number(a) / 1e6;
          t += `<li><b>${n.toFixed(6)}</b> <i>ada</i></li>`;
        } else t += `<li><b>${a}</b> <i>${e}</i></li>`;
        return t === "" && (t = "<li>No assets available</li>"), t;
      }
      function A$(d) {
        try {
          const t = d.split(".");
          if (t.length !== 3) throw new Error("Invalid JWT format");
          const e = t[1], a = e + "=".repeat((4 - e.length % 4) % 4), n = atob(a.replace(/-/g, "+").replace(/_/g, "/"));
          return JSON.parse(n);
        } catch (t) {
          return console.error("Failed to decode JWT:", t), null;
        }
      }
      class I$ extends ol {
        constructor(t, e) {
          super();
          __publicField(this, "config");
          __publicField(this, "storage");
          __publicField(this, "googleAuth");
          __publicField(this, "wallet", null);
          __publicField(this, "backend", null);
          __publicField(this, "prover", null);
          __publicField(this, "currentWalletId", null);
          this.config = t, this.storage = e, this.googleAuth = new S$(t);
        }
        async initializeWallet(t) {
          try {
            this.backend = this.config.backendApiKey ? new Ke(this.config.backendUrl, this.config.backendApiKey) : new Ke(this.config.backendUrl), this.prover = new $n(this.config.proverUrl);
            const e = this.generateOAuthState();
            this.storage.saveSessionData("oauth_state", e), this.storage.saveSessionData("network", t);
            const a = this.googleAuth.getAuthUrl(e);
            window.location.href = a;
          } catch (e) {
            throw console.error("Failed to initialize wallet:", e), this.emit("walletInitializationFailed", e), e;
          }
        }
        async handleOAuthCallback(t) {
          try {
            this.backend = this.config.backendApiKey ? new Ke(this.config.backendUrl, this.config.backendApiKey) : new Ke(this.config.backendUrl), this.prover = new $n(this.config.proverUrl);
            const e = new URLSearchParams(t), a = e.get("code"), n = e.get("state"), _ = e.get("error");
            if (_) throw new Error(`OAuth error: ${_}`);
            const c = this.storage.getSessionItem("oauth_state");
            if (n !== c) throw new Error("State mismatch. Possible CSRF attack");
            if (!a) throw new Error("Missing authorization code");
            const s = await this.googleAuth.getJWT(a);
            if (!s) throw new Error("Failed to get JWT from authorization code");
            const p = {
              jwt: s
            }, l = this.storage.getSessionItem("network");
            await this.completeWalletInitialization(p, l), this.storage.removeSessionItem("oauth_state"), this.storage.removeSessionItem("network"), window.history.replaceState({}, "", "/");
          } catch (e) {
            throw console.error("OAuth callback failed:", e), this.emit("walletInitializationFailed", e), window.history.replaceState({}, "", "/"), e;
          }
        }
        async completeWalletInitialization(t, e) {
          if (!this.backend) throw new Error("Backend not initialized");
          if (!this.prover) throw new Error("Prover not initialized");
          this.wallet = new Yn(this.backend, this.prover, t);
          const a = await this.wallet.getBalance(), n = await this.wallet.getAddress().then((s) => s.to_bech32());
          console.log(`Initialized a ${e} wallet with address ${n}`), console.log("Balance:", a);
          let _;
          if (t.jwt) {
            const s = A$(t.jwt);
            s && s.email && (_ = s.email);
          }
          let c = null;
          if (_ && (c = this.storage.findWalletByEmail(_)), c) console.log(`Found existing wallet for email ${_}. Reusing existing credential.`), c.state.balance = a, c.state.address = n, c.state.isInitialized = true, this.storage.saveWallet(c), this.storage.setActiveWallet(c.id), this.currentWalletId = c.id, this.wallet = new Yn(this.backend, this.prover, c.credential), this.emit("walletInitialized", c.state);
          else {
            console.log(`No existing wallet found for email ${_}. Creating new wallet.`);
            const s = {
              isInitialized: true,
              address: n,
              balance: a,
              network: e,
              method: "Google Oauth",
              userEmail: _
            }, p = this.generateWalletId(n), l = {
              id: p,
              state: s,
              network: e,
              credential: t
            };
            this.storage.saveWallet(l), this.storage.setActiveWallet(p), this.currentWalletId = p, this.emit("walletInitialized", s);
          }
        }
        async restoreWallet(t) {
          if (!t.isInitialized || !t.address) throw new Error("Invalid wallet state");
          this.backend = this.config.backendApiKey ? new Ke(this.config.backendUrl, this.config.backendApiKey) : new Ke(this.config.backendUrl), this.prover = new $n(this.config.proverUrl);
          const e = this.storage.getActiveWallet();
          if (e && e.credential && e.network) try {
            this.wallet = new Yn(this.backend, this.prover, e.credential), this.currentWalletId = e.id, console.log("Wallet instance restored from persistent storage");
            return;
          } catch (a) {
            console.warn("Failed to restore wallet instance from persistent storage:", a);
          }
          console.log("Wallet state loaded but instance could not be restored. Re-initialization required.");
        }
        async switchToWallet(t) {
          const e = this.storage.getWallet(t);
          if (!e) throw new Error(`Wallet with ID ${t} not found`);
          if (!e.credential || !e.network) throw new Error("Wallet credential not available");
          try {
            this.backend || (this.backend = this.config.backendApiKey ? new Ke(this.config.backendUrl, this.config.backendApiKey) : new Ke(this.config.backendUrl)), this.prover || (this.prover = new $n(this.config.proverUrl)), this.wallet = new Yn(this.backend, this.prover, e.credential), this.currentWalletId = t, this.storage.setActiveWallet(t), console.log(`Switched to wallet: ${e.id}`), this.emit("walletSwitched", e.state);
          } catch (a) {
            throw console.error("Failed to switch wallet:", a), a;
          }
        }
        getAllWallets() {
          return this.storage.getAllWallets();
        }
        getCurrentWalletId() {
          return this.currentWalletId;
        }
        removeWallet(t) {
          if (this.storage.removeWallet(t), this.currentWalletId === t) {
            this.wallet = null, this.currentWalletId = null;
            const e = this.getAllWallets();
            e.length > 0 && this.switchToWallet(e[0].id);
          }
        }
        async sendTransaction(t) {
          try {
            if (this.wallet) console.log("Using existing wallet instance (no restoration needed)");
            else {
              console.log("Wallet instance not available, attempting to restore...");
              const p = this.storage.getActiveWallet();
              if (p && await this.restoreWallet(p.state), !this.wallet) throw new Error("Wallet not initialized");
              console.log("Wallet instance restored successfully");
            }
            console.log(`Sending ${t.amount} ${t.asset} to ${t.recipient} using ${t.recipientType}`);
            const e = {};
            e[t.asset] = new $t(t.amount);
            let a;
            switch (t.recipientType) {
              case W_.Bech32:
                a = new wd(W_.Bech32, t.recipient, e);
                break;
              case W_.Email:
                a = new wd(W_.Email, t.recipient, e);
                break;
              default:
                throw new Error(`Unsupported recipient type: ${t.recipientType}`);
            }
            let n;
            t.recipientType === W_.Email ? n = await this.wallet.addressForGmail(t.recipient).then((p) => p.to_bech32()) : n = t.recipient;
            const _ = {
              txId: "Computing...",
              recipient: n,
              isProofComputing: true
            };
            this.emit("transactionComplete", _);
            const c = await this.wallet.sendTo(a);
            console.log(`Transaction ID: ${c}`);
            const s = {
              txId: c,
              recipient: n,
              isProofComputing: false
            };
            this.emit("proofComputationComplete", s);
          } catch (e) {
            throw console.error("Transaction failed:", e), this.emit("transactionFailed", e), e;
          }
        }
        async checkTransactionStatus(t, e) {
          try {
            if (!this.backend) throw new Error("Backend not initialized");
            const a = _e.from_bech32(e), n = await this.backend.addressUtxo(a);
            for (const _ of n) if (_.ref.transaction_id === t) return {
              outcome: "success",
              data: _
            };
            return {
              outcome: "pending"
            };
          } catch (a) {
            return console.error("Failed to check transaction status:", a), {
              outcome: "failure",
              reason: a
            };
          }
        }
        async getWalletBalance() {
          if (!this.wallet) throw new Error("Wallet not initialized");
          return await this.wallet.getBalance();
        }
        async getWalletAddress() {
          if (!this.wallet) throw new Error("Wallet not initialized");
          return await this.wallet.getAddress().then((t) => t.to_bech32());
        }
        async refreshWalletState() {
          if (this.backend || (this.backend = this.config.backendApiKey ? new Ke(this.config.backendUrl, this.config.backendApiKey) : new Ke(this.config.backendUrl), console.log("Backend instance initialized for refresh")), this.wallet) console.log("Using existing wallet instance for refresh");
          else {
            console.log("Wallet instance not available during refresh, attempting to restore...");
            const c = this.storage.getActiveWallet();
            if (c && await this.restoreWallet(c.state), !this.wallet) throw new Error("Wallet not initialized and could not be restored");
            console.log("Wallet instance restored for refresh");
          }
          const t = await this.wallet.getBalance(), e = await this.wallet.getAddress().then((c) => c.to_bech32()), a = this.storage.getActiveWallet();
          if (!a) throw new Error("No active wallet found");
          const n = {
            ...a.state,
            balance: t,
            address: e
          }, _ = {
            ...a,
            state: n
          };
          return this.storage.saveWallet(_), console.log("Wallet state refreshed with updated balance:", t), n;
        }
        isWalletReady() {
          return this.wallet !== null;
        }
        clearWallet() {
          this.wallet = null, this.backend = null, this.currentWalletId = null, this.storage.clearWalletState();
        }
        logout() {
          this.wallet = null, this.backend = null, this.currentWalletId = null, sessionStorage.clear(), this.emit("walletLoggedOut", {});
        }
        generateOAuthState() {
          const t = new Uint8Array(32);
          return crypto.getRandomValues(t), Array.from(t, (e) => e.toString(16).padStart(2, "0")).join("");
        }
        generateWalletId(t) {
          return t.slice(0, 16);
        }
      }
      class B$ extends ol {
        constructor(t) {
          super();
          __publicField(this, "currentViewData", null);
          __publicField(this, "backendService");
          this.backendService = t;
        }
        setBackendService(t) {
          this.backendService = t;
        }
        navigate(t, e) {
          this.currentViewData = e, this.emit("navigate", {
            view: t,
            data: e
          });
        }
        getViewData() {
          return this.currentViewData;
        }
        renderInitView() {
          const t = document.createElement("main");
          return t.className = "container", t.innerHTML = `
      <a href="https://zkfold.io">
        <img src="logo-200x73.png" style="width:250px;height:100px;">
      </a>
      <br><br>
      <h3 id="header" style="text-align: center; font-weight: 400;">Create your wallet with email</h3>
      <form action="#" method="POST">
        <fieldset>
          <label id="network_selector" hidden>
            Network type
            <select name="network" id="network_option" aria-label="Select network" required>
              <option>Preview</option>
              <option selected="selected">Preprod</option>
            </select>
          </label>


        </fieldset>
        <button
          id="submit"
          type="submit"
          style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;"
        >
          <svg width="18" height="18" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
            <g fill="none" fill-rule="evenodd">
              <path d="M17.64 9.205c0-.639-.057-1.252-.164-1.841H9v3.481h4.844a4.14 4.14 0 0 1-1.796 2.716v2.259h2.908c1.702-1.567 2.684-3.875 2.684-6.615z" fill="#4285F4"/>
              <path d="M9 18c2.43 0 4.467-.806 5.956-2.18l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332A8.997 8.997 0 0 0 9 18z" fill="#34A853"/>
              <path d="M3.964 10.71A5.41 5.41 0 0 1 3.682 9c0-.593.102-1.17.282-1.71V4.958H.957A8.996 8.996 0 0 0 0 9c0 1.452.348 2.827.957 4.042l3.007-2.332z" fill="#FBBC05"/>
              <path d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0A8.997 8.997 0 0 0 .957 4.958L3.964 7.29C4.672 5.163 6.656 3.58 9 3.58z" fill="#EA4335"/>
            </g>
          </svg>
          Continue with Google
        </button>
      </form>
    `, t;
        }
        renderWalletView(t) {
          const e = document.createElement("main");
          e.className = "container";
          const a = t.balance ? j$(t.balance) : "<li>Loading...</li>", n = t.address || "Loading...", _ = t.userEmail || "Unknown";
          return e.innerHTML = `
      <a href="https://zkfold.io">
        <img src="logo-200x73.png" style="width:250px;height:100px;">
      </a>
      <br><br>
      <div style="display: flex; align-items: center;">
        <label name="user_email">
            User: <strong>${_}</strong>
        </label>
        <button type="button" id="copy_email" style="background: none; border: none; cursor: pointer; padding: 0.25rem;" title="Copy email">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M16 1H4C2.9 1 2 1.9 2 3V17H4V3H16V1ZM19 5H8C6.9 5 6 5.9 6 7V21C6 22.1 6.9 23 8 23H19C20.1 23 21 22.1 21 21V7C21 5.9 20.1 5 19 5ZM19 21H8V7H19V21Z" fill="currentColor"/>
          </svg>
        </button>
      </div>
      <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
        <label name="wallet_address">
            Address: <strong>${n}</strong>
        </label>
        <button type="button" id="copy_address" style="background: none; border: none; cursor: pointer; padding: 0.25rem;" title="Copy address">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M16 1H4C2.9 1 2 1.9 2 3V17H4V3H16V1ZM19 5H8C6.9 5 6 5.9 6 7V21C6 22.1 6.9 23 8 23H19C20.1 23 21 22.1 21 21V7C21 5.9 20.1 5 19 5ZM19 21H8V7H19V21Z" fill="currentColor"/>
          </svg>
        </button>
      </div>
      <label name="balance_label">
          Wallet balance: 
          <ul>
              ${a}
          </ul>
      </label>
      <form action="#" method="POST">
        <fieldset>
          <label id="address_type" hidden>
            Type of address 
            <select name="recipient" aria-label="Select the type of address you want to send ADA to" required id="type_selector">
              <option value="${W_.Bech32}">Bech32</option>
              <option value="${W_.Email}" selected="selected">Gmail</option>
            </select>
          </label>
          <label>
            Recipient's address
            <input
              name="zkfold_address" 
              id="address_input" 
              placeholder="example@gmail.com"
              required
            />
          </label>
          <label id="asset_name" hidden>
            Asset name ('lovelace' for ADA or '{PolicyID}.{AssetName}' for other assets) 
            <input
              name="zkfold_asset" 
              value="lovelace"
            />
          </label>
          <label>
            Amount 
            <input
              name="zkfold_amount"
              type="number"
              min="0.000001"
              step="0.000001"
              placeholder="Enter amount in ADA"
              style="-moz-appearance: textfield;"
              required
            />
          </label>
        </fieldset>
        <button type="submit">Send</button>
      </form>
      <label id="faucet_label" hidden>
        Use this address to receive funds from the <a href='https://docs.cardano.org/cardano-testnets/tools/faucet'>Faucet</a>: ${n}
      </label>
      <button id="show_selector">Show all controls</button>
      <button id="logout_button">Log out</button>
    `, setTimeout(() => {
            const c = document.getElementById("copy_email"), s = document.getElementById("copy_address");
            c && c.addEventListener("click", () => {
              this.copyToClipboard(_, "Email copied!", c);
            }), s && s.addEventListener("click", () => {
              this.copyToClipboard(n, "Address copied!", s);
            });
          }, 0), e;
        }
        async copyToClipboard(t, e, a) {
          try {
            await navigator.clipboard.writeText(t), this.showCopyNotification(e, a);
          } catch (n) {
            console.error("Failed to copy text: ", n), this.fallbackCopyTextToClipboard(t, e, a);
          }
        }
        fallbackCopyTextToClipboard(t, e, a) {
          const n = document.createElement("textarea");
          n.value = t, n.style.top = "0", n.style.left = "0", n.style.position = "fixed", n.style.opacity = "0", document.body.appendChild(n), n.focus(), n.select();
          try {
            document.execCommand("copy") ? this.showCopyNotification(e, a) : this.showCopyNotification("Failed to copy text", a);
          } catch (_) {
            console.error("Fallback: Oops, unable to copy", _), this.showCopyNotification("Failed to copy text", a);
          }
          document.body.removeChild(n);
        }
        showCopyNotification(t, e) {
          const a = document.createElement("div");
          a.textContent = t;
          let n = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #4CAF50;
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      z-index: 1000;
      font-size: 14px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      white-space: nowrap;
    `;
          if (e) {
            const _ = e.getBoundingClientRect();
            n = `
        position: fixed;
        top: ${_.top + window.scrollY}px;
        left: ${_.right + 10}px;
        background: #4CAF50;
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        z-index: 1000;
        font-size: 12px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        white-space: nowrap;
      `;
          }
          a.style.cssText = n, document.body.appendChild(a), setTimeout(() => {
            a.parentNode && a.parentNode.removeChild(a);
          }, 2e3);
        }
        renderSuccessView(t) {
          const e = document.createElement("main");
          e.className = "container";
          const a = (t == null ? void 0 : t.txId) || "Unknown", n = (t == null ? void 0 : t.recipient) || "Unknown", _ = (t == null ? void 0 : t.isProofComputing) || false, c = _ ? "Computing zero-knowledge proof. It will take approximately 5 minutes (one time operation)." : "Transaction pending. This page will refresh automatically when transaction succeeds.";
          return e.innerHTML = `
      <a href="https://zkfold.io">
        <img src="logo-200x73.png" style="width:250px;height:100px;">
      </a>
      <br><br>
      <h1 id="tx_status">${c}</h1>
      <label name="txid_label">
          Transaction id: ${a}
      </label>
      <br>
      <button id="new_tx" disabled>Make another transaction</button>
      <button id="new_wallet" disabled>Log out</button>
    `, _ || this.addTransactionStatusScript(e, a, n), e;
        }
        renderFailedView(t) {
          const e = document.createElement("main");
          e.className = "container";
          const a = (t == null ? void 0 : t.reason) || "Unknown error";
          return e.innerHTML = `
      <a href="https://zkfold.io">
        <img src="logo-200x73.png" style="width:250px;height:100px;">
      </a>
      <br><br>
      <h1>Transaction failed.</h1>
      <label name="balance_label">
          Reason: ${a}
      </label>
      <button id="new_tx" disabled>Make another transaction</button>
      <button id="new_wallet" disabled>Log out</button>
    `, e;
        }
        addTransactionStatusScript(t, e, a) {
          this.startTransactionStatusChecking(e, a);
        }
        async startTransactionStatusChecking(t, e) {
          if (!this.backendService) {
            console.error("BackendService not available for transaction status checking"), this.updateTransactionStatus("failure", "Backend service not configured");
            return;
          }
          console.log("Starting transaction status checking:", t, e);
          const a = (n) => new Promise((_) => setTimeout(_, n));
          try {
            let n = await this.backendService.checkTransactionStatus(t, e);
            for (; n.outcome !== "success" && n.outcome !== "failure"; ) console.log("Transaction status:", n), await a(1e4), n = await this.backendService.checkTransactionStatus(t, e);
            this.updateTransactionStatus(n.outcome, n.reason);
          } catch (n) {
            console.error("Error checking transaction status:", n), this.updateTransactionStatus("failure", "Error checking transaction status");
          }
        }
        updateTransactionStatus(t, e) {
          const a = document.getElementById("tx_status"), n = document.getElementById("new_tx"), _ = document.getElementById("new_wallet");
          !a || !n || !_ || (t === "success" ? (a.innerHTML = "Transaction successful!", n.disabled = false, _.disabled = false, n.onclick = () => this.emit("refreshAndNavigate", "wallet"), _.onclick = () => this.navigate("init")) : (a.innerHTML = "Transaction failed: " + (e || "Unknown error"), n.disabled = false, _.disabled = false, n.onclick = () => this.emit("refreshAndNavigate", "wallet"), _.onclick = () => this.navigate("init")));
        }
        updateProofComputationComplete(t, e) {
          const a = document.getElementById("tx_status"), n = document.querySelector('label[name="txid_label"]');
          a && (a.innerHTML = "Transaction pending. This page will refresh automatically when transaction succeeds.", this.startTransactionStatusChecking(t, e)), n && (n.innerHTML = `Transaction id: ${t}`);
        }
      }
      class R$ {
        constructor() {
          __publicField(this, "MULTI_WALLET_KEY", "smart-wallets");
          __publicField(this, "SESSION_KEY", "smart-wallet-session");
        }
        saveWallet(t) {
          try {
            const e = this.getMultiWalletStorage();
            e.wallets[t.id] = t, localStorage.setItem(this.MULTI_WALLET_KEY, Xe(e));
          } catch (e) {
            console.warn("Failed to save wallet to localStorage:", e);
          }
        }
        getWallet(t) {
          try {
            return this.getMultiWalletStorage().wallets[t] || null;
          } catch (e) {
            return console.warn("Failed to retrieve wallet from localStorage:", e), null;
          }
        }
        getAllWallets() {
          try {
            const t = this.getMultiWalletStorage();
            return Object.values(t.wallets);
          } catch (t) {
            return console.warn("Failed to retrieve wallets from localStorage:", t), [];
          }
        }
        findWalletByEmail(t) {
          try {
            return this.getAllWallets().find((a) => a.state.userEmail === t) || null;
          } catch (e) {
            return console.warn("Failed to find wallet by email:", e), null;
          }
        }
        removeWallet(t) {
          try {
            const e = this.getMultiWalletStorage();
            delete e.wallets[t], e.activeWalletId === t && (e.activeWalletId = void 0), localStorage.setItem(this.MULTI_WALLET_KEY, Xe(e));
          } catch (e) {
            console.warn("Failed to remove wallet from localStorage:", e);
          }
        }
        setActiveWallet(t) {
          try {
            const e = this.getMultiWalletStorage();
            e.wallets[t] && (e.activeWalletId = t, localStorage.setItem(this.MULTI_WALLET_KEY, Xe(e)));
          } catch (e) {
            console.warn("Failed to set active wallet:", e);
          }
        }
        getActiveWallet() {
          try {
            const t = this.getMultiWalletStorage();
            return t.activeWalletId && t.wallets[t.activeWalletId] || null;
          } catch (t) {
            return console.warn("Failed to get active wallet:", t), null;
          }
        }
        clearWalletState() {
          try {
            localStorage.removeItem(this.MULTI_WALLET_KEY);
          } catch (t) {
            console.warn("Failed to clear wallet state from localStorage:", t);
          }
        }
        saveSessionData(t, e) {
          try {
            const a = this.getSessionData();
            a[t] = e, sessionStorage.setItem(this.SESSION_KEY, Xe(a));
          } catch (a) {
            console.warn("Failed to save session data:", a);
          }
        }
        getSessionData() {
          try {
            const t = sessionStorage.getItem(this.SESSION_KEY);
            return t ? Tc(t) : {};
          } catch (t) {
            return console.warn("Failed to retrieve session data:", t), {};
          }
        }
        getSessionItem(t) {
          return this.getSessionData()[t];
        }
        removeSessionItem(t) {
          try {
            const e = this.getSessionData();
            delete e[t], sessionStorage.setItem(this.SESSION_KEY, Xe(e));
          } catch (e) {
            console.warn("Failed to remove session item:", e);
          }
        }
        getMultiWalletStorage() {
          try {
            const t = localStorage.getItem(this.MULTI_WALLET_KEY);
            if (t) return Tc(t);
            {
              const e = {
                wallets: {}
              };
              return localStorage.setItem(this.MULTI_WALLET_KEY, Xe(e)), e;
            }
          } catch (t) {
            console.warn("Failed to parse multi-wallet storage:", t);
            const e = {
              wallets: {}
            };
            return localStorage.setItem(this.MULTI_WALLET_KEY, Xe(e)), e;
          }
        }
      }
      class N$ {
        constructor(t) {
          __publicField(this, "backend");
          this.backend = t.backendApiKey ? new Ke(t.backendUrl, t.backendApiKey) : new Ke(t.backendUrl);
        }
        async checkTransactionStatus(t, e) {
          try {
            const a = _e.from_bech32(e), n = await this.backend.addressUtxo(a);
            for (const _ of n) if (_.ref.transaction_id === t) return {
              outcome: "success",
              data: _
            };
            return {
              outcome: "pending"
            };
          } catch (a) {
            return console.error("Failed to check transaction status:", a), {
              outcome: "failure",
              reason: a
            };
          }
        }
      }
      class L$ {
        constructor() {
          __publicField(this, "config");
          __publicField(this, "walletManager");
          __publicField(this, "router");
          __publicField(this, "storage");
          __publicField(this, "backendService");
          __publicField(this, "currentView", "init");
          __publicField(this, "walletState", {
            isInitialized: false
          });
          this.config = this.loadConfig(), this.storage = new R$(), this.backendService = new N$(this.config), this.walletManager = new I$(this.config, this.storage), this.router = new B$(this.backendService), this.setupEventListeners();
        }
        loadConfig() {
          return {
            clientId: "371998750978-pcvugvvnfq9ohea16hqgsroslrsm8mrc.apps.googleusercontent.com",
            clientSecret: "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",
            websiteUrl: "http://localhost:8080",
            backendUrl: "https://api.wallet.zkfold.io",
            backendApiKey: void 0,
            proverUrl: "https://b0sacrdukf.execute-api.eu-central-1.amazonaws.com"
          };
        }
        setupEventListeners() {
          this.walletManager.on("walletInitialized", (t) => {
            this.walletState = t.data, this.router.navigate("wallet");
          }), this.walletManager.on("transactionComplete", (t) => {
            this.router.navigate("success", t.data);
          }), this.walletManager.on("proofComputationComplete", (t) => {
            this.router.updateProofComputationComplete(t.data.txId, t.data.recipient);
          }), this.walletManager.on("transactionFailed", (t) => {
            this.router.navigate("failed", {
              reason: t.data.message
            });
          }), this.walletManager.on("walletLoggedOut", () => {
            this.router.navigate("init");
          }), this.router.on("navigate", (t) => {
            this.currentView = t.data.view, this.render();
          }), this.router.on("refreshAndNavigate", async (t) => {
            const e = t.data;
            if (e === "wallet") try {
              this.walletState = await this.walletManager.refreshWalletState(), this.currentView = "wallet", this.render();
            } catch (a) {
              console.error("Failed to refresh wallet state:", a), this.router.navigate("wallet");
            }
            else this.router.navigate(e);
          });
        }
        async init() {
          try {
            if (new URLSearchParams(window.location.search).has("code")) {
              await this.walletManager.handleOAuthCallback(window.location.search);
              return;
            }
            const e = this.storage.getActiveWallet();
            e && e.state.isInitialized ? (this.walletState = e.state, await this.walletManager.restoreWallet(e.state), this.router.navigate("wallet")) : this.router.navigate("init"), this.render();
          } catch (t) {
            console.error("Failed to initialize app:", t), this.router.navigate("init");
          }
        }
        render() {
          const t = document.getElementById("app");
          if (!t) throw console.error("App element not found"), new Error("App element not found");
          t.innerHTML = "";
          let e;
          switch (this.currentView) {
            case "init":
              e = this.router.renderInitView();
              break;
            case "wallet":
              e = this.router.renderWalletView(this.walletState);
              break;
            case "success":
              e = this.router.renderSuccessView(this.router.getViewData());
              break;
            case "failed":
              e = this.router.renderFailedView(this.router.getViewData());
              break;
            default:
              e = this.router.renderInitView();
          }
          t.appendChild(e), this.setupViewEventHandlers();
        }
        setupViewEventHandlers() {
          switch (this.currentView) {
            case "init":
              this.setupInitHandlers();
              break;
            case "wallet":
              this.setupWalletHandlers();
              break;
            case "failed":
              this.setupFailedHandlers();
              break;
          }
        }
        setupInitHandlers() {
          const t = document.querySelector("form");
          t && t.addEventListener("submit", async (e) => {
            e.preventDefault();
            const n = new FormData(t).get("network");
            await this.walletManager.initializeWallet(n);
          });
        }
        setupWalletHandlers() {
          const t = document.querySelector("form");
          t && t.addEventListener("submit", async (c) => {
            c.preventDefault();
            const s = new FormData(t), p = parseFloat(s.get("zkfold_amount")), l = Math.round(p * 1e6).toString();
            await this.walletManager.sendTransaction({
              recipient: s.get("zkfold_address"),
              recipientType: parseInt(s.get("recipient")),
              amount: l,
              asset: s.get("zkfold_asset") || "lovelace"
            });
          });
          const e = document.getElementById("show_address");
          e && e.addEventListener("click", () => {
            this.toggleAddressDisplay();
          });
          const a = document.getElementById("show_selector");
          a && a.addEventListener("click", () => {
            this.toggleSelector();
          });
          const n = document.getElementById("type_selector");
          n && n.addEventListener("change", () => {
            this.updateTypeUI();
          });
          const _ = document.getElementById("logout_button");
          _ && _.addEventListener("click", () => {
            this.walletManager.logout();
          });
        }
        setupFailedHandlers() {
          const t = document.getElementById("new_tx"), e = document.getElementById("new_wallet");
          t && (t.removeAttribute("disabled"), t.addEventListener("click", async () => {
            try {
              this.walletState = await this.walletManager.refreshWalletState(), this.currentView = "wallet", this.render();
            } catch (a) {
              console.error("Failed to refresh wallet state:", a), this.router.navigate("wallet");
            }
          })), e && (e.removeAttribute("disabled"), e.addEventListener("click", () => {
            this.router.navigate("init");
          }));
        }
        updateTypeUI() {
          const t = document.getElementById("address_input"), e = document.getElementById("type_selector");
          t && e && (e.value === "1" ? t.placeholder = "example@gmail.com" : t.placeholder = "addr_test1xyz...(Bech32)");
        }
        toggleAddressDisplay() {
          const t = document.getElementById("faucet_label"), e = document.getElementById("show_address");
          t && e && (t.hidden ? (t.hidden = false, e.innerHTML = "Hide address") : (t.hidden = true, e.innerHTML = "Show address"));
        }
        toggleSelector() {
          const t = document.getElementById("address_type"), e = document.getElementById("show_selector"), a = document.getElementById("type_selector"), n = document.getElementById("asset_name");
          t && e && n && (t.hidden ? (t.hidden = false, e.innerHTML = "Hide address selector", n.hidden = false) : (t.hidden = true, e.innerHTML = "Show all controls", a && (a.value = "1"), n.hidden = true, this.updateTypeUI()));
        }
      }
      function hd() {
        try {
          new L$().init();
        } catch (d) {
          console.error("Failed to initialize app:", d);
        }
      }
      document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", hd) : hd();
    })();
  }
});
export default require_stdin();
